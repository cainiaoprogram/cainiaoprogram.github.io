<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《现代C&#43;&#43;语言核心特性解析》笔记（三） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《现代C&#43;&#43;语言核心特性解析》笔记（三）" />
<meta property="og:description" content="二十四、三向比较（C&#43;&#43;20） 1. “太空飞船”（spaceship）运算符 C&#43;&#43;20标准新引入了一个名为“太空飞船”（spaceship）的运算符 &lt;=&gt;，它是一个三向比较运算符。&lt;=&gt; 之所以被称为“太空飞船”运算符是因为 &lt;=&gt; 让著名的Perl语言专家兰德尔·L.施瓦茨想起1971年的一款电子游戏《星际迷航》中的太空飞船。读者应该也看出来了，&lt;=&gt; 并不是 C&#43;&#43;20首创的，实际上Perl、PHP、Ruby等语言早已支持了三向比较运算符，C&#43;&#43;是后来的学习者。
顾名思义，三向比较就是在形如 lhs &lt;=&gt; rhs 的表达式中，两个比较的操作数 lhs 和 rhs 通过 &lt;=&gt; 比较可能产生3种结果，该结果可以和0比较，小于0、等于0或者大于0分别对应 lhs &lt; rhs、lhs == rhs 和 lhs &gt; rhs。举例来说：
bool b = 7 &lt;=&gt; 11 &lt; 0; // b == true 请注意，运算符&lt;=&gt;的返回值只能与0和自身类型来比较，如果同其他数值比较，编译器会报错：
bool b = 7 &lt;=&gt; 11 &lt; 100; // 编译失败，&lt;=&gt; 的结果不能与除 0 以外的数值比较 2. 三向比较的返回类型 可以看出 &lt;=&gt; 的返回结果并不是一个普通类型，根据标准三向比较会返回3种类型，分别为 std::strong_ordering、std::weak_ordering 以及 std::partial_ordering，而这3种类型又会分为有3～4种最终结果，下面就来一一介绍它们。
1. std::strong_ordering std::strong_ordering 类型有3种比较结果，分别为 std::strong_ordering::less、std::strong_ordering::equal 以及 std::strong_ordering::greater。表达式 lhs &lt;=&gt; rhs 分别表示 lhs &lt; rhs、lhs == rhs 以及 lhs &gt; rhs。std::strong_ordering 类型的结果强调的是 strong 的含义，表达的是一种可替换性，简单来说，若 lhs == rhs，那么在任何情况下 rhs 和 lhs 都可以相互替换，也就是 fx(lhs) == fx(rhs)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e829ee5b511438414a310fb698055b4a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T19:04:28+08:00" />
<meta property="article:modified_time" content="2024-01-05T19:04:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《现代C&#43;&#43;语言核心特性解析》笔记（三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C20_0"></a>二十四、三向比较（C++20）</h2> 
<h3><a id="1_spaceship_2"></a><strong>1. “太空飞船”（spaceship）运算符</strong></h3> 
<p>C++20标准新引入了一个名为“太空飞船”（spaceship）的运算符 <code>&lt;=&gt;</code>，它是一个三向比较运算符。<code>&lt;=&gt;</code> 之所以被称为“太空飞船”运算符是因为 <code>&lt;=&gt;</code> 让著名的Perl语言专家兰德尔·L.施瓦茨想起1971年的一款电子游戏《星际迷航》中的太空飞船。读者应该也看出来了，<code>&lt;=&gt;</code> 并不是 C++20首创的，实际上Perl、PHP、Ruby等语言早已支持了三向比较运算符，C++是后来的学习者。</p> 
<p>顾名思义，三向比较就是在形如 <code>lhs &lt;=&gt; rhs</code> 的表达式中，两个比较的操作数 <code>lhs</code> 和 <code>rhs</code> 通过 <code>&lt;=&gt;</code> 比较可能产生3种结果，该结果可以和<code>0</code>比较，小于<code>0</code>、等于<code>0</code>或者大于<code>0</code>分别对应 <code>lhs &lt; rhs</code>、<code>lhs == rhs</code> 和 <code>lhs &gt; rhs</code>。举例来说：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token number">7</span> <span class="token operator">&lt;=&gt;</span> <span class="token number">11</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// b == true</span>
</code></pre> 
<p>请注意，运算符<code>&lt;=&gt;</code>的返回值只能与<code>0</code>和自身类型来比较，如果同其他数值比较，编译器会报错：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token number">7</span> <span class="token operator">&lt;=&gt;</span> <span class="token number">11</span> <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，&lt;=&gt; 的结果不能与除 0 以外的数值比较</span>
</code></pre> 
<h3><a id="2__19"></a>2. 三向比较的返回类型</h3> 
<p>可以看出 <code>&lt;=&gt;</code> 的返回结果并不是一个普通类型，根据标准三向比较会返回3种类型，分别为 <code>std::strong_ordering</code>、<code>std::weak_ordering</code> 以及 <code>std::partial_ordering</code>，而这3种类型又会分为有3～4种最终结果，下面就来一一介绍它们。</p> 
<h4><a id="1_stdstrong_ordering_23"></a>1. std::strong_ordering</h4> 
<p><code>std::strong_ordering</code> 类型有3种比较结果，分别为 <code>std::strong_ordering::less</code>、<code>std::strong_ordering::equal</code> 以及 <code>std::strong_ordering::greater</code>。表达式 <code>lhs &lt;=&gt; rhs</code> 分别表示 <code>lhs &lt; rhs</code>、<code>lhs == rhs</code> 以及 <code>lhs &gt; rhs</code>。<code>std::strong_ordering</code> 类型的结果强调的是 strong 的含义，表达的是一种可替换性，简单来说，若 <code>lhs == rhs</code>，那么在任何情况下 <code>rhs</code> 和 <code>lhs</code> 都可以相互替换，也就是 <code>fx(lhs) == fx(rhs)</code>。</p> 
<p>对于基本类型中的<code>int</code>类型，三向比较返回的是<code>std::strong_ordering</code>，例如：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">&lt;=&gt;</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>用MSVC编译运行以上代码，会在输出窗口显示 class <code>std::strong_ordering</code>，刻意使用 MSVC 是因为它的 <code>typeid(x).name()</code> 可以输出友好可读的类型名称。对于有复杂结构的类型，<code>std::strong_ordering</code> 要求其数据成员和基类的三向比较结果都为 <code>std::strong_ordering</code>。例如：</p> 
<pre><code class="prism language-java">#include <span class="token generics"><span class="token punctuation">&lt;</span>compare<span class="token punctuation">&gt;</span></span>

struct <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">long</span> b<span class="token punctuation">;</span>
	auto operator <span class="token operator">&lt;=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">B</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

struct <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">short</span> c<span class="token punctuation">;</span>
	auto operator <span class="token operator">&lt;=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">D</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">D</span> x1<span class="token punctuation">,</span> x2<span class="token punctuation">;</span>
std<span class="token operator">::</span><span class="token function">cout</span> <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span><span class="token function">decltype</span><span class="token punctuation">(</span>x1 <span class="token operator">&lt;=</span><span class="token operator">&gt;</span> x2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面这段代码用 MSVC 编译运行会输出 class <code>std::strong_ordering</code>。请注意，默认情况下自定义类型是不存在三向比较运算符函数的，需要用户显式默认声明，比如在结构体 B 和 D 中声明 <code>auto operator &lt;=&gt; (const B&amp;) const = default;</code> 和 <code>auto operator &lt;=&gt; (const D&amp;) const = default;</code>。对结构体 B 而言，由于 <code>int</code> 和 <code>long</code> 的比较结果都是 <code>std::strong_ordering</code>，因此结构体 B 的三向比较结果也是 <code>std::strong_ordering</code>。同理，对于结构体 D，其基类和成员的比较结果是 <code>std::strong_ordering</code>，D 的三向比较结果同样是 <code>std::strong_ordering</code>。另外，明确运算符的返回类型，使用 <code>std::strong_ordering</code> 替换 <code>auto</code> 也是没问题的。</p> 
<h4><a id="2_stdweak_ordering_56"></a>2. std::weak_ordering</h4> 
<p><code>std::weak_ordering</code> 类型也有3种比较结果，分别为 <code>std::weak_ordering::less</code>、<code>std::weak_ordering::equivalent</code> 以及 <code>std::weak_ordering::greater</code>。<code>std::weak_ordering</code> 的含义正好与 <code>std::strong_ordering</code> 相对，表达的是不可替换性。即若有 <code>lhs == rhs</code>，则 <code>rhs</code> 和 <code>lhs</code> 不可以相互替换，也就是 <code>fx(lhs) != fx(rhs)</code>。这种情况在基础类型中并没有，但是它常常发生在用户自定义类中，比如一个大小写不敏感的字符串类：</p> 
<pre><code class="prism language-java">#include <span class="token generics"><span class="token punctuation">&lt;</span>compare<span class="token punctuation">&gt;</span></span>
#include <span class="token generics"><span class="token punctuation">&lt;</span>string<span class="token punctuation">&gt;</span></span>
#include <span class="token generics"><span class="token punctuation">&lt;</span>iostream<span class="token punctuation">&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">ci_compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">tolower</span><span class="token punctuation">(</span><span class="token operator">*</span>s1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">tolower</span><span class="token punctuation">(</span><span class="token operator">*</span>s2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>s1<span class="token operator">++</span> <span class="token operator">==</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token function">tolower</span><span class="token punctuation">(</span><span class="token operator">*</span>s1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">tolower</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">--</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">CIString</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token class-name">CIString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	std<span class="token operator">::</span><span class="token function">weak_ordering</span> operator<span class="token operator">&lt;=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">CIString</span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">ci_compare</span><span class="token punctuation">(</span>str_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>str_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span><span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token operator">::</span><span class="token function">string</span> str_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">CIString</span> s1<span class="token punctuation">{<!-- --></span> <span class="token string">"HELLO"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> s2<span class="token punctuation">{<!-- --></span><span class="token string">"hello"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">cout</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;=</span><span class="token operator">&gt;</span> s2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出为true</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码实现了一个简单的大小写不敏感的字符串类，它对于 <code>s1</code> 和 <code>s2</code> 的比较结果是 <code>std::weak_ordering::equivalent</code>，表示两个操作数是等价的，但是它们不是相等的也不能相互替换。</p> 
<p>当 <code>std::weak_ordering</code> 和 <code>std::strong_ordering</code> 同时出现在基类和数据成员的类型中时，该类型的三向比较结果是 <code>std::weak_ordering</code>，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span></span>
<span class="token punctuation">{<!-- --></span>
	CIString c<span class="token punctuation">{<!-- --></span><span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> <span class="token keyword">operator</span> <span class="token operator">&lt;=&gt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

D w1<span class="token punctuation">,</span> w2<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>w1 <span class="token operator">&lt;=&gt;</span> w2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>用 MSVC 编译运行上面这段代码会输出 class <code>std::weak_ordering</code>，因为 D 中的数据成员 <code>CIString</code> 的三向比较结果为 <code>std::weak_ordering</code>。请注意，如果显式声明默认三向比较运算符函数为 <code>std::strong_ordering operator &lt;=&gt; (const D&amp;) const = default;</code>，那么一定会遭遇到一个编译错误。</p> 
<h4><a id="3_stdpartial_ordering_108"></a>3. std::partial_ordering</h4> 
<p><code>std::partial_ordering</code> 类型有4种比较结果，分别为 <code>std::partial_ordering::less</code>、<code>std::partial_ordering::equivalent</code>、<code>std::partial_ordering::greater</code> 以及 <code>std::partial_ordering::unordered</code>。<code>std::partial_ordering</code> 约束力比 <code>std::weak_ordering</code> 更弱，它可以接受当 <code>lhs == rhs</code> 时 <code>rhs</code> 和 <code>lhs</code> 不能相互替换，同时它还能给出第四个结果 <code>std::partial_ordering::unordered</code>，表示进行比较的两个操作数没有关系。比如基础类型中的浮点数：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token number">7.7</span> <span class="token operator">&lt;=&gt;</span> <span class="token number">11.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>用 MSVC 编译运行以上代码会输出 class <code>std::partial_ordering</code>。之所以会输出 class <code>std::partial_ordering</code> 而不是 <code>std::strong_ordering</code>，是因为浮点的集合中存在一个特殊的 NaN，它和其他浮点数值是没关系的：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.0</span> <span class="token operator">/</span> <span class="token number">0.0</span> <span class="token operator">&lt;=&gt;</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>partial_ordering<span class="token double-colon punctuation">::</span>unordered<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这段代码编译输出的结果为 <code>true</code>。当 <code>std::weak_ordering</code> 和 <code>std::partial_ordering</code> 同时出现在基类和数据成员的类型中时，该类型的三向比较结果是 <code>std::partial_ordering</code>，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span></span>
<span class="token punctuation">{<!-- --></span>
	CIString c<span class="token punctuation">{<!-- --></span><span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">float</span> u<span class="token punctuation">;</span>
	<span class="token keyword">auto</span> <span class="token keyword">operator</span> <span class="token operator">&lt;=&gt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

D w1<span class="token punctuation">,</span> w2<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>w1 <span class="token operator">&lt;=&gt;</span> w2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>用 MSVC 编译运行以上代码会输出 class <code>std::partial_ordering</code>，因为 D 中的数据成员 <code>u</code> 的三向比较结果为 <code>std::partial_ordering</code>。同样，显式声明为其他返回类型也会让编译器报错。</p> 
<p>在 C++20 的标准库中有一个模板元函数 <code>std::common_comparison_category</code>，它可以帮助我们在一个类型合集中判断出最终三向比较的结果类型。当类型合集中存在不支持三向比较的类型时，该模板元函数返回 <code>void</code>。</p> 
<p>再次强调一下，<code>std::strong_ordering</code>、<code>std::weak_ordering</code> 和 <code>std::partial_ordering</code> 只能与 <code>0</code> 和类型自身比较。深究其原因，是这3个类只实现了参数类型为自身类型和 <code>nullptr_t</code> 的比较运算符函数。</p> 
<h3><a id="3__142"></a>3. 对基础类型的支持</h3> 
<ol><li> <p>对两个算术类型的操作数进行一般算术转换，然后进行比较。其中整型的比较结果为 <code>std::strong_ordering</code>，浮点型的比较结果为 <code>std::partial_ordering</code>。例如 <code>7 &lt;=&gt; 11.1</code> 中，整型 <code>7</code> 会转换为浮点类型，然后再进行比较，最终结果为 <code>std::partial_ordering</code> 类型。</p> </li><li> <p>对于无作用域枚举类型和整型操作数，枚举类型会转换为整型再进行比较，无作用域枚举类型无法与浮点类型比较：</p> </li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">enum</span> <span class="token class-name">color</span> <span class="token punctuation">{<!-- --></span>
	red
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> r <span class="token operator">=</span> red <span class="token operator">&lt;=&gt;</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">//编译成功</span>
<span class="token keyword">auto</span> r <span class="token operator">=</span> red <span class="token operator">&lt;=&gt;</span> <span class="token number">11.1</span><span class="token punctuation">;</span> <span class="token comment">//编译失败</span>
</code></pre> 
<ol start="3"><li>对两个相同枚举类型的操作数比较结果，如果枚举类型不同，则无法编译。</li><li>对于其中一个操作数为<code>bool</code>类型的情况，另一个操作数必须也是<code>bool</code>类型，否则无法编译。比较结果为<code>std::strong_ordering</code>。</li><li>不支持作比较的两个操作数为数组的情况，会导致编译出错，例如：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> r <span class="token operator">=</span> arr1 <span class="token operator">&lt;=&gt;</span> arr2<span class="token punctuation">;</span> <span class="token comment">// 编译失败</span>
</code></pre> 
<ol start="6"><li>对于其中一个操作数为指针类型的情况，需要另一个操作数是同样类型的指针，或者是可以转换为相同类型的指针，比如数组到指针的转换、派生类指针到基类指针的转换等，最终比较结果为 <code>std::strong_ordering</code>：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> arr1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> arr2<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">*</span> ptr <span class="token operator">=</span> arr2<span class="token punctuation">;</span>
<span class="token keyword">auto</span> r <span class="token operator">=</span> ptr <span class="token operator">&lt;=&gt;</span> arr1<span class="token punctuation">;</span>
</code></pre> 
<p>上面的代码可以编译成功。若将代码中的 <code>arr1</code> 改写为 <code>int arr1[5]</code>，则无法编译，因为 <code>int [5]</code> 无法转换为 <code>char *</code>。如果将 <code>char * ptr = arr2;</code> 修改为 <code>void * ptr = arr2;</code>，代码就可以编译成功了。</p> 
<h3><a id="4__175"></a><strong>4. 自动生成的比较运算符函数</strong></h3> 
<p>标准库中提供了一个名为 <code>std::rel_ops</code> 的命名空间，在用户自定义类型已经提供了 <code>==</code> 运算符函数和 <code>&lt;</code> 运算符函数的情况下，帮助用户实现其他4种运算符函数，包括 <code>!=</code>、<code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code>，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span>
<span class="token keyword">class</span> <span class="token class-name">CIString2</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">CIString2</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	
	<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> CIString2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">ci_compare</span><span class="token punctuation">(</span>str_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>str_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>string str_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>rel_ops<span class="token punctuation">;</span>
CIString2 s1<span class="token punctuation">{<!-- --></span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> s2<span class="token punctuation">{<!-- --></span> <span class="token string">"world"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> r <span class="token operator">=</span> s1 <span class="token operator">&gt;=</span> s2<span class="token punctuation">;</span>
</code></pre> 
<p>不过因为 C++20 标准有了三向比较运算符的关系，所以不推荐上面这种做法了。C++20 标准规定，如果用户为自定义类型声明了三向比较运算符，那么编译器会为其自动生成 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 这4种运算符函数。对于 <code>CIString</code> 我们可以直接使用这4种运算符函数：</p> 
<pre><code class="prism language-cpp">CIString s1<span class="token punctuation">{<!-- --></span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> s2<span class="token punctuation">{<!-- --></span> <span class="token string">"world"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> r <span class="token operator">=</span> s1 <span class="token operator">&gt;=</span> s2<span class="token punctuation">;</span>
</code></pre> 
<p>那么这里就会产生一个疑问，很明显三向比较运算符能表达两个操作数是相等或者等价的含义，为什么标准只允许自动生成4种运算符函数，却不能自动生成 <code>==</code> 和 <code>!=</code> 这两个运算符函数呢？实际上这里存在一个严重的性能问题。在 C++20 标准拟定三向比较的早期，是允许通过三向比较自动生成6个比较运算符函数的，而三向比较的结果类型也不是3种而是5种，多出来的两种分别是 <code>std::strong_equality</code> 和 <code>std::weak_equality</code>。但是在提案文档 p1190 中提出了一个严重的性能问题。简单来说，假设有一个结构体：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">S</span> <span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> names<span class="token punctuation">;</span>
	<span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">&lt;=&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> S <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>它的三向比较运算符的默认实现这样的：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>strong_ordering <span class="token keyword">operator</span><span class="token operator">&lt;=&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t min_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rhs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> min_size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token keyword">const</span> cmp <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">compare_3way</span><span class="token punctuation">(</span>lhs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cmp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> cmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> lhs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=&gt;</span> rhs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个实现对于 <code>&lt;</code> 和 <code>&gt;</code> 这样的运算符函数没有问题，因为需要比较容器中的每个元素。但是 <code>==</code> 运算符就显得十分低效，对于 <code>==</code> 运算符高效的做法是先比较容器中的元素数量是否相等，如果元素数量不同，则直接返回 <code>false</code>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> size_t size <span class="token operator">=</span> lhs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> rhs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> rhs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>想象一下，如果标准允许用三向比较的算法自动生成 <code>==</code> 运算符函数会发生什么事情，很多旧代码升级编译环境后会发现运行效率下降了，尤其是在容器中元素数量众多且每个元素数据量庞大的情况下。很少有程序员会注意到三向比较算法的细节，导致这个性能问题难以排查。</p> 
<p>基于这种考虑，C++ 委员会修改了原来的三向比较提案，规定声明三向比较运算符函数只能够自动生成4种比较运算符函数。由于不需要负责判断是否相等，因此 <code>std::strong_equality</code> 和 <code>std::weak_equality</code> 也退出了历史舞台。对于 <code>==</code> 和 <code>!=</code> 两种比较运算符函数，只需要多声明一个 <code>==</code> 运算符函数，<code>!=</code> 运算符函数会根据前者自动生成：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">CIString</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">CIString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	
	std<span class="token double-colon punctuation">::</span>weak_ordering <span class="token keyword">operator</span><span class="token operator">&lt;=&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> CIString<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">ci_compare</span><span class="token punctuation">(</span>str_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>str_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> CIString<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">ci_compare</span><span class="token punctuation">(</span>str_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>str_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>string str_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

CIString s1<span class="token punctuation">{<!-- --></span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> s2<span class="token punctuation">{<!-- --></span> <span class="token string">"world"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> r1 <span class="token operator">=</span> s1 <span class="token operator">&gt;=</span> s2<span class="token punctuation">;</span> <span class="token comment">// 调用operator&lt;=&gt;</span>
<span class="token keyword">bool</span> r2 <span class="token operator">=</span> s1 <span class="token operator">==</span> s2<span class="token punctuation">;</span> <span class="token comment">// 调用operator ==</span>
</code></pre> 
<h3><a id="5__269"></a>5. 兼容旧代码</h3> 
<p>现在 C++20 标准已经推荐使用 <code>&lt;=&gt;</code> 和 <code>==</code> 运算符自动生成其他比较运算符函数，而使用 <code>&lt;</code>、<code>==</code> 以及 <code>std::rel_ops</code> 生成其他比较运算符函数则会因为 <code>std::rel_ops</code> 已经不被推荐使用而被编译器警告。</p> 
<p>那么对于老代码，我们是否需要去实现一套 <code>&lt;=&gt;</code> 和 <code>==</code> 运算符函数呢？其实大可不必，C++ 委员会在裁决这项修改的时候已经考虑到老代码的维护成本，所以做了兼容性处理，即在用户自定义类型中，实现了 <code>&lt;</code>、<code>==</code> 运算符函数的数据成员类型，在该类型的三向比较中将自动生成合适的比较代码。比如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;compare&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">Legacy</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Legacy<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> n <span class="token operator">==</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Legacy<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> n <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">TreeWay</span> <span class="token punctuation">{<!-- --></span>
	Legacy m<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>strong_ordering <span class="token keyword">operator</span><span class="token operator">&lt;=&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> TreeWay <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    TreeWay t1<span class="token punctuation">,</span> t2<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> r <span class="token operator">=</span> t1 <span class="token operator">&lt;</span> t2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，结构体 <code>TreeWay</code> 的三向比较操作会调用结构体 <code>Legacy</code> 中的 <code>&lt;</code> 和 <code>==</code> 运算符来完成，其代码类似于：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeWay</span> <span class="token punctuation">{<!-- --></span>
	Legacy m<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>strong_ordering <span class="token keyword">operator</span><span class="token operator">&lt;=&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> TreeWay<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>m<span class="token punctuation">)</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>strong_ordering<span class="token double-colon punctuation">::</span>less<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> rhs<span class="token punctuation">.</span>m<span class="token punctuation">)</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>strong_ordering<span class="token double-colon punctuation">::</span>equal<span class="token punctuation">;</span>
		<span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>strong_ordering<span class="token double-colon punctuation">::</span>greater<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>需要注意的是，这里 <code>operator&lt;=&gt;</code> 必须显式声明返回类型为 <code>std::strong_ordering</code>，使用 <code>auto</code> 是无法通过编译的。</p> 
<h3><a id="_315"></a>总结</h3> 
<p>本章介绍了 C++20 新增的三向比较特性，该特性的引入为实现比较运算提供了方便。我们只需要实现 <code>==</code> 和 <code>&lt;=&gt;</code> 两个运算符函数，剩下的4个运算符函数就可以交给编译器自动生成了。虽说 <code>std::rel_ops</code> 在实现了 <code>==</code> 和 <code>&lt;</code> 两个运算符函数以后也能自动提供剩下的4个运算符函数，但显然用三向比较更加便捷。另外，三向比较提供的3种结果类型也是 <code>std::rel_ops</code> 无法媲美的。进一步来说，由于三向比较的出现，<code>std::rel_ops</code> 在 C++20 中已经不被推荐使用了。最后，C++ 委员会没有忘记兼容性问题，这让三向比较能够通过运算符函数 <code>&lt;</code> 和 <code>==</code> 来自动生成。</p> 
<h2><a id="C11_318"></a>二十五、线程局部存储（C++11）</h2> 
<h3><a id="1__320"></a>1. 操作系统和编译器对线程局部存储的支持</h3> 
<p>线程局部存储是指对象内存在线程开始后分配，线程结束时回收且每个线程有该对象自己的实例，简单地说，线程局部存储的对象都是独立于各个线程的。实际上，这并不是一个新鲜的概念，虽然 C++ 一直没有在语言层面支持它，但是很早之前操作系统就有办法支持线程局部存储了。</p> 
<p>由于线程本身是操作系统中的概念，因此线程局部存储这个功能是离不开操作系统支持的。而不同的操作系统对线程局部存储的实现也不同，以至于使用的系统 API 也有区别，这里主要以 Windows 和 Linux 为例介绍它们使用线程局部存储的方法。</p> 
<p>在 Windows 中可以通过调用 API 函数 <code>TlsAlloc</code> 来分配一个未使用的线程局部存储槽索引（TLS slot index），这个索引实际上是 Windows 内部线程环境块（TEB）中线程局部存储数组的索引。通过 API 函数 <code>TlsGetValue</code> 与 <code>TlsSetValue</code> 可以获取和设置线程局部存储数组对应于索引元素的值。API 函数 <code>TlsFree</code> 用于释放线程局部存储槽索引。</p> 
<p>Linux 使用了 pthreads（POSIX threads）作为线程接口，在 pthreads 中我们可以调用 <code>pthread_key_create</code> 与 <code>pthread_key_delete</code> 创建与删除一个类型为 <code>pthread_key_t</code> 的键。利用这个键可以使用 <code>pthread_setspecific</code> 函数设置线程相关的内存数据，当然，我们随后还能够通过 <code>pthread_getspecific</code> 函数获取之前设置的内存数据。</p> 
<p>在 C++11 标准确定之前，各个编译器也用了自定义的方法支持线程局部存储。比如 gcc 和 clang 添加了关键字 <code>__thread</code> 来声明线程局部存储变量，而 Visual Studio C++ 则是使用 <code>__declspec(thread)</code>。虽然它们都有各自的方法声明线程局部存储变量，但是其使用范围和规则却存在一些区别，这种情况增加了 C++ 的学习成本，也是 C++ 标准委员会不愿意看到的。于是在 C++11 标准中正式添加了新的 <code>thread_local</code> 说明符来声明线程局部存储变量。</p> 
<h3><a id="2_thread_local__332"></a>2. thread_local 说明符</h3> 
<p><code>thread_local</code> 说明符可以用来声明线程生命周期的对象，它能与 <code>static</code> 或 <code>extern</code> 结合，分别指定内部或外部链接，不过额外的 <code>static</code> 并不影响对象的生命周期。换句话说，<code>static</code> 并不影响其线程局部存储的属性：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">thread_local</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">thread_local</span> X a<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">thread_local</span> X b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从上面的代码可以看出，声明一个线程局部存储变量相当简单，只需要在普通变量声明上添加 <code>thread_local</code> 说明符。被 <code>thread_local</code> 声明的变量在行为上非常像静态变量，只不过多了线程属性，当然这也是线程局部存储能出现在我们的视野中的一个关键原因，它能够解决全局变量或者静态变量在多线程操作中存在的问题，一个典型的例子就是 <code>errno</code>。</p> 
<p><code>errno</code> 通常用于存储程序当中上一次发生的错误，早期它是一个静态变量，由于当时大多数程序是单线程的，因此没有任何问题。但是到了多线程时代，这种 <code>errno</code> 就不能满足需求了。设想一下，一个多线程程序的线程A在某个时刻刚刚调用过一个函数，正准备获取其错误码，也正是这个时刻，另外一个线程B在执行了某个函数后修改了这个错误码，那么线程A接下来获取的错误码自然不会是它真正想要的那个。这种线程间的竞争关系破坏了 <code>errno</code> 的准确性，导致不可确定的结果。为了规避由此产生的不确定性，POSIX 将 <code>errno</code> 重新定义为线程独立的变量，为了实现这个定义就需要用到线程局部存储，直到 C++11 之前，<code>errno</code> 都是一个静态变量，而从 C++11 开始 <code>errno</code> 被修改为一个线程局部存储变量。</p> 
<p>在了解了线程局部存储的意义之后，让我们回头仔细阅读其定义，会发现线程局部存储只是定义了对象的生命周期，而没有定义可访问性。也就是说，我们可以获取线程局部存储变量的地址并将其传递给其他线程，并且其他线程可以在其生命周期内自由使用变量。不过这样做除了用于诊断功能以外没有实际意义，而且其危险性过大，一旦没有掌握好目标线程的声明周期，就很可能导致内存访问异常，造成未定义的程序行为，通常情况下是程序崩溃。</p> 
<p>值得注意的是，使用取地址运算符 <code>&amp;</code> 取到的线程局部存储变量的地址是运行时被计算出来的，它不是一个常量，也就是说无法和 <code>constexpr</code> 结合：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> sv<span class="token punctuation">;</span>
<span class="token keyword">thread_local</span> <span class="token keyword">int</span> tv<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>sp <span class="token operator">=</span> <span class="token operator">&amp;</span>sv<span class="token punctuation">;</span>	<span class="token comment">// 编译成功，sv的地址在编译时确定</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">;</span>	<span class="token comment">// 编译失败，tv的地址在运行时确定</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，由于 <code>sv</code> 是一个静态变量，因此在编译时可以获取其内存常量地址，并赋值到常量表达式 <code>sp</code>。但是 <code>tv</code> 则不同，它在线程创建时才可能确定内存地址，所以这里会产生编译错误。</p> 
<p>最后来说明一下线程局部存储对象的初始化和销毁。在同一个线程中，一个线程局部存储对象只会初始化一次，即使在某个函数中被多次调用。这一点和单线程程序中的静态对象非常相似。相对应的，对象的销毁也只会发生一次，通常发生在线程退出的时刻。下面来看一个例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>mutex g_out_lock<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">RefCount</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">RefCount</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">func</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>g_out_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token operator">&lt;&lt;</span> <span class="token string">"|"</span> <span class="token operator">&lt;&lt;</span> func
			<span class="token operator">&lt;&lt;</span> <span class="token string">" : ctor i("</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">RefCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>g_out_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token operator">&lt;&lt;</span> <span class="token string">"|"</span> <span class="token operator">&lt;&lt;</span> func
			<span class="token operator">&lt;&lt;</span> <span class="token string">" : dtor i("</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>g_out_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token operator">&lt;&lt;</span> <span class="token string">"|"</span> <span class="token operator">&lt;&lt;</span> func
			<span class="token operator">&lt;&lt;</span> <span class="token string">" : ref count add 1 to i("</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>string func<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
RefCount <span class="token operator">*</span>lp_ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> f<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string <span class="token function">func</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">thread_local</span> RefCount <span class="token function">tv</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"#foo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	tv<span class="token punctuation">.</span><span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> f<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string <span class="token function">func</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">thread_local</span> RefCount <span class="token function">tv</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"#bar"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	tv<span class="token punctuation">.</span><span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">threadfunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> func <span class="token operator">=</span> <span class="token string">"threadfunc1"</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">threadfunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> func <span class="token operator">=</span> <span class="token string">"threadfunc2"</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">threadfunc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> func <span class="token operator">=</span> <span class="token string">"threadfunc3"</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">bar</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">bar</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>threadfunc1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>threadfunc2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>threadfunc3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码并发3个工作线程，前两个线程 <code>threadfunc1</code> 和 <code>threadfunc2</code> 分别调用了3次 <code>foo</code> 函数。而第三个线程 <code>threadfunc3</code> 调用了1次 <code>foo</code> 函数和2次 <code>bar</code> 函数。其中 <code>foo</code> 和 <code>bar</code> 函数的功能相似，它们分别声明并初始化了一个线程局部存储对象 <code>tv</code>，并调用其自增函数 <code>inc</code>，而 <code>inc</code> 函数会递增对象成员变量 <code>i</code>。为了保证输出的日志不会受到线程竞争的干扰，在输出之前加了互斥锁。下面是在Windows上的运行结果：</p> 
<pre><code class="prism language-cpp"><span class="token number">27300</span><span class="token operator">|</span>threadfunc1#foo <span class="token operator">:</span> ctor <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">27300</span><span class="token operator">|</span>threadfunc1#foo <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">27300</span><span class="token operator">|</span>threadfunc1#foo <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">27300</span><span class="token operator">|</span>threadfunc1#foo <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">25308</span><span class="token operator">|</span>threadfunc3#foo <span class="token operator">:</span> ctor <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">25308</span><span class="token operator">|</span>threadfunc3#foo <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">25308</span><span class="token operator">|</span>threadfunc3#bar <span class="token operator">:</span> ctor <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">25308</span><span class="token operator">|</span>threadfunc3#bar <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">25308</span><span class="token operator">|</span>threadfunc3#bar <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">10272</span><span class="token operator">|</span>threadfunc2#foo <span class="token operator">:</span> ctor <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">10272</span><span class="token operator">|</span>threadfunc2#foo <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">10272</span><span class="token operator">|</span>threadfunc2#foo <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">10272</span><span class="token operator">|</span>threadfunc2#foo <span class="token operator">:</span> ref count add <span class="token number">1</span> to <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">27300</span><span class="token operator">|</span>threadfunc1#foo <span class="token operator">:</span> dtor <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">25308</span><span class="token operator">|</span>threadfunc3#bar <span class="token operator">:</span> dtor <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">25308</span><span class="token operator">|</span>threadfunc3#foo <span class="token operator">:</span> dtor <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">10272</span><span class="token operator">|</span>threadfunc2#foo <span class="token operator">:</span> dtor <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> 
<p>从结果可以看出，线程 <code>threadfunc1</code> 和 <code>threadfunc2</code> 分别只调用了一次构造和析构函数，而且引用计数的递增也不会互相干扰，也就是说两个线程中线程局部存储对象是独立存在的。对于线程 <code>threadfunc3</code>，它进行了两次线程局部存储对象的构造和析构，这两次分别对应 <code>foo</code> 和 <code>bar</code> 函数里的线程局部存储对象 <code>tv</code>。可以发现，虽然这两个对象具有相同的对象名，但是由于不在同一个函数中，因此也应该认为是相同线程中不同的线程局部存储对象，它们的引用计数的递增同样不会相互干扰。</p> 
<h3><a id="_482"></a>总结</h3> 
<p>多线程已经成为现代程序应用中不可缺少的技术环节，但是在 C++11 标准出现之前，C++ 语言标准对多线程的支持是不完善的，无法创建线程局部存储对象就是其中的一个缺陷。幸好 C++11 的推出挽救了这种尴尬的局面。本章中介绍的 <code>thread_local</code> 说明符终于让 C++ 在语言层面统一了声明线程局部存储对象的方法。当然，想要透彻地理解线程局部存储，只是学习 <code>thread_local</code> 说明符的内容是不够的，还需要深入操作系统层面，探究系统处理线程局部存储的方法。</p> 
<h2><a id="_inline_C17_486"></a>二十六、扩展的 inline 说明符（C++17）</h2> 
<h3><a id="1__488"></a>1. 定义非常量静态成员变量的问题</h3> 
<p>在C++17标准之前，定义类的非常量静态成员变量是一件让人头痛的事情，因为变量的声明和定义必须分开进行，比如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>string X<span class="token double-colon punctuation">::</span>text<span class="token punctuation">{<!-- --></span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	X<span class="token double-colon punctuation">::</span>text <span class="token operator">+=</span> <span class="token string">" world"</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> X<span class="token double-colon punctuation">::</span>text <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这里 <code>static std::string text</code> 是静态成员变量的声明，<code>std::string X::text{ "hello" }</code> 是静态成员变量的定义和初始化。为了保证代码能够顺利地编译，我们必须保证静态成员变量的定义有且只有一份，稍有不慎就会引发错误，比较常见的错误是为了方便将静态成员变量的定义放在头文件中：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">X_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">X_H</span></span>
<span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>string X<span class="token double-colon punctuation">::</span>text<span class="token punctuation">{<!-- --></span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>将上面的代码包含到多个 CPP 文件中会引发一个链接错误，因为 <code>include</code> 是单纯的宏替换，所以会存在多份 <code>X::text</code> 的定义导致链接失败。对于一些字面量类型，比如整型、浮点类型等，这种情况有所缓解，至少对于它们而言常量静态成员变量是可以一边声明一边定义的：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> num<span class="token punctuation">{<!-- --></span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> X<span class="token double-colon punctuation">::</span>num <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>不过有得有失，虽然常量性能让它们方便地声明和定义，但却丢失了修改变量的能力。对于<code>std::string</code>这种非字面量类型，这种方法是无能为力的。</p> 
<h3><a id="2__inline__540"></a>2. 使用 inline 说明符</h3> 
<p>为了解决上面这些问题，C++17标准中增强了<code>inline</code>说明符的能力，它允许我们内联定义静态变量，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">inline</span> <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">{<!-- --></span><span class="token string">"hello"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	X<span class="token double-colon punctuation">::</span>text <span class="token operator">+=</span> <span class="token string">" world"</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> X<span class="token double-colon punctuation">::</span>text <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码可以成功编译和运行，而且即使将类X的定义作为头文件包含在多个CPP中也不会有任何问题。在这种情况下，编译器会在类X的定义首次出现时对内联静态成员变量进行定义和初始化。</p> 
<h3><a id="_560"></a>总结</h3> 
<p>本章介绍的 <code>inline</code> 说明符的扩展特性解决了 C++ 中定义静态成员变量烦琐且容易出错的问题，它让编译器能够聪明地选择首次出现的变量进行定义和初始化。这种能力也正是 <code>inline</code> 说明符的提案文档中的第一段话所提到的：“<code>inline</code> 说明符可以应用于变量以及函数。声明为 <code>inline</code> 的变量与函数具有相同的语义：它们一方面可以在多个翻译单元中定义，另一方面又必须在每个使用它们的翻译单元中定义，并且程序的行为就像是同一个变量。”</p> 
<h2><a id="C11C20_565"></a>二十七、常量表达式（C++11～C++20）</h2> 
<h3><a id="1__567"></a>1. 常量的不确定性</h3> 
<p>在C++11标准以前，我们没有一种方法能够有效地要求一个变量或者函数在编译阶段就计算出结果。由于无法确保在编译阶段得出结果，导致很多看起来合理的代码却引来编译错误。这些场景主要集中在需要编译阶段就确定的值语法中，比如<code>case</code>语句、数组长度、枚举成员的值以及非类型的模板参数。让我们先看一看这些场景的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> index0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">index1</span> <span class="token expression"><span class="token number">1</span></span></span>

<span class="token comment">// case语句</span>
<span class="token keyword">int</span> argc <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>argc<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> index0<span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index0"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> index1<span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"none"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> x_size <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">y_size</span> <span class="token expression"><span class="token number">6</span> <span class="token operator">+</span> <span class="token number">7</span></span></span>

<span class="token comment">// 数组长度</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x_size<span class="token punctuation">]</span><span class="token punctuation">[</span>y_size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 枚举成员</span>
<span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>
    enum_index0 <span class="token operator">=</span> index0<span class="token punctuation">,</span>
    enum_index1 <span class="token operator">=</span> index1
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> tp <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 非类型的模板参数</span>
<span class="token keyword">int</span> x1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>index0<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> x2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>index1<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>在上面的代码中，<code>const</code>定义的常量和宏都能在要求编译阶段确定值的语句中使用。其中宏在编译之前的预处理阶段就被替换为定义的文字。而对于<code>const</code>定义的常量，上面这种情况下编译器能在编译阶段确定它们的值，并在<code>case</code>语句以及数组长度等语句中使用。</p> 
<p>让人遗憾的是上面这些方法并不可靠。首先，C++程序员应该尽量少使用宏，因为预处理器对于宏只是简单的字符替换，完全没有类型检查，而且宏使用不当出现的错误难以排查。其次，对<code>const</code>定义的常量可能是一个运行时常量，这种情况下是无法在<code>case</code>语句以及数组长度等语句中使用的。</p> 
<p>让我们稍微修改一下上面的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">get_index0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">get_index1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">get_x_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">get_y_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> index0 <span class="token operator">=</span> <span class="token function">get_index0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">index1</span> <span class="token expression"><span class="token function">get_index1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">switch</span> <span class="token punctuation">(</span>argc<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">case</span>  index0<span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index0"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> index1<span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">default</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"none"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> x_size <span class="token operator">=</span> <span class="token function">get_x_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">y_size</span> <span class="token expression"><span class="token function">get_y_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x_size<span class="token punctuation">]</span><span class="token punctuation">[</span>y_size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>
    enum_index0 <span class="token operator">=</span> index0<span class="token punctuation">,</span>
    enum_index1 <span class="token operator">=</span> index1<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> tp <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>index0<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> x2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>index1<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们这里做的修改仅仅是将宏定义为一个函数调用以及用一个函数将<code>const</code>变量进行初始化，但是编译这段代码时会发现已经无法通过编译了。因为，无论是宏定义的函数调用，还是通过函数返回值初始化<code>const</code>变量都是在运行时确定的。</p> 
<p>像上面这种尴尬的情况不仅可能出现在我们的代码中，实际上标准库中也有这样的情况，其中<code>&lt;limits&gt;</code>就是一个典型的例子。在C语言中存在头文件<code>&lt;limits.h&gt;</code>，在这个头文件中用宏定义了各种整型类型的最大值和最小值，比如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UCHAR_MAX</span> <span class="token expression"><span class="token number">0xff</span> </span><span class="token comment">// unsigned char类型的最大值</span></span>
</code></pre> 
<p>我们可以用这些宏代替数字，让代码有更好的可读性。这其中就包括要求编译阶段必须确定值的语句，例如定义一个数组：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span>UCHAR_MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>代码编译起来没有任何障碍。但是正如上文中提到的，C++程序员应该尽量避开宏。标准库为我们提供了一个<code>&lt;limits&gt;</code>，使用它同样能获得<code>unsigned char</code>类型的最大值：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>但是，如果想用它来声明数组的大小是无法编译成功的：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>原因和之前讨论过的一样，<code>std::numeric_limits&lt;unsigned char&gt;::max()</code>函数的返回值必须在运行时计算。</p> 
<p>为了解决以上常量无法确定的问题，C++标准委员会决定在C++11标准中定义一个新的关键字<code>constexpr</code>，它能够有效地定义常量表达式，并且达到类型安全、可移植、方便库和嵌入式系统开发的目的。</p> 
<h3><a id="2_constexpr__689"></a>2. constexpr 值</h3> 
<p><code>constexpr</code>值即常量表达式值，是一个用<code>constexpr</code>说明符声明的变量或者数据成员，它要求该值必须在编译期计算。另外，常量表达式值必须被常量表达式初始化。定义常量表达式值的方法非常简单，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码定义了一个常量表达式值<code>x</code>，并将其初始化为42，然后用<code>x</code>作为数组长度定义了数组<code>buffer</code>。从这段代码来看，<code>constexpr</code>和<code>const</code>是没有区别的，我们将关键字替换为<code>const</code>同样能达到目的：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>从结果来看确实如此，在使用常量表达式初始化的情况下<code>constexpr</code>和<code>const</code>拥有相同的作用。但是<code>const</code>并没有确保编译期常量的特性，所以在下面的代码中，它们会有不同的表现：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> x2 <span class="token operator">=</span> x1<span class="token punctuation">;</span> <span class="token comment">// 定义和初始化成功</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，x2无法作为数组长度</span>
</code></pre> 
<p>在上面这段代码中，虽然<code>x2</code>初始化编译成功，但是编译器并不一定把它作为一个编译期需要确定的值，所以在声明<code>buffer</code>的时候会编译错误。注意，这里我说的是不一定，因为并没有人规定编译期应该怎么处理这种情况。比如在GCC中，这段代码可以编译成功，但是MSVC和CLang则会编译失败。如果把<code>const</code>替换为<code>constexpr</code>，会有不同的情况发生：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> x2 <span class="token operator">=</span> x1<span class="token punctuation">;</span> <span class="token comment">// 编译失败，x2无法用x1初始化</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>修改后，编译器编译第二句代码的时候就会报错，因为常量表达式值必须由常量表达式初始化，而<code>x1</code>并不是常量，明确地违反了<code>constexpr</code>的规则，编译器自然就会报错。可以看出，<code>constexpr</code>是一个加强版的<code>const</code>，它不仅要求常量表达式是常量，并且要求是一个编译阶段就能够确定其值的常量。</p> 
<h3><a id="3_constexpr__719"></a>3. constexpr 函数</h3> 
<p><code>constexpr</code>不仅能用来定义常量表达式值，还能定义一个常量表达式函数，即<code>constexpr</code>函数，常量表达式函数的返回值可以在编译阶段就计算出来。不过在定义常量表示函数的时候，我们会遇到更多的约束规则（在C++14和后续的标准中对这些规则有所放宽）。</p> 
<ol><li>函数必须返回一个值，所以它的返回值类型不能是<code>void</code>。</li><li>函数体必须只有一条语句：<code>return expr</code>，其中<code>expr</code>必须也是一个常量表达式。如果函数有形参，则将形参替换到<code>expr</code>中后，<code>expr</code>仍然必须是一个常量表达式。</li><li>函数使用之前必须有定义。</li><li>函数必须用<code>constexpr</code>声明。</li></ol> 
<p>让我们来看一看下面这个例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">max_unsigned_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">0xff</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> x <span class="token operator">:</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> buffer1<span class="token punctuation">[</span><span class="token function">max_unsigned_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> buffer2<span class="token punctuation">[</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> buffer3<span class="token punctuation">[</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码定义了3个常量表达式函数，由于它们的返回值能够在编译期计算出来，因此可以直接将这些函数的返回值使用在数组长度的定义上。需要注意的是<code>square</code>和<code>abs</code>两个函数，它们接受一个形参<code>x</code>，当<code>x</code>确定为一个常量时（这里分别是5和−8），其常量表达式函数也就成立了。我们通过<code>abs</code>可以发现一个小技巧，由于标准规定函数体中只能有一个表达式<code>return expr</code>，因此是无法使用<code>if</code>语句的，幸运的是用条件表达式也能完成类似的效果。</p> 
<p>接着让我们看一看反例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">++</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">max_unsigned_char2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>
	max_uchar <span class="token operator">=</span> <span class="token function">max_unsigned_char2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">abs2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		result <span class="token operator">+=</span> x<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上<code>constexpr</code>函数都会编译失败。其中函数<code>foo</code>的返回值不能为<code>void</code>，<code>next</code>函数体中的<code>++x</code>和<code>f</code>中的<code>g()</code>都不是一个常量表达式，函数<code>max_unsigned_char2</code>只有声明没有定义，函数<code>abs2</code>和<code>sum</code>不能有多条语句。我们注意到<code>abs2</code>中<code>if</code>语句可以用条件表达式替换，可是<code>sum</code>函数这样的循环结构有办法替换为单语句吗？答案是可以的，我们可以使用递归来完成循环的操作，现在就来重写<code>sum</code>函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> x <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上函数比较容易理解，当<code>x</code>大于0时，将<code>x</code>和<code>sum(x−1)</code>相加，直到<code>sum</code>的参数为0。由于这里<code>sum</code>本身被声明为常量表达式函数，因此整个返回语句也是一个常量表达式，遵守了常量表达式的规则。于是我们能通过递归调用<code>sum</code>函数完成循环计算的任务。有趣的是，在刚开始提出常量表达式函数的时候，有些C++专家认为这种函数不应该支持递归调用，但是最终标准还是确定支持了递归调用。</p> 
<p>需要强调一点的是，虽然常量表达式函数的返回值可以在编译期计算出来，但是这个行为并不是确定的。例如，当带形参的常量表达式函数接受了一个非常量实参时，常量表达式函数可能会退化为普通函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里由于<code>x</code>不是一个常量，因此<code>square</code>的返回值也可能无法在编译期确定，但是它依然能成功编译运行，因为该函数退化成了一个普通函数。这种退化机制对于程序员来说是非常友好的，它意味着我们不用为了同时满足编译期和运行期计算而定义两个相似的函数。另外，这里也存在着不确定性，因为GCC依然能在编译阶段计算<code>square</code>的结果，但是MSVC和CLang则不行。</p> 
<p>有了常量表达式函数的支持，C++标准对STL也做了一些改进，比如在<code>&lt;limits&gt;</code>中增加了<code>constexpr</code>声明，正因如此下面的代码也可以顺利编译成功了：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="4_constexpr__834"></a>4. constexpr 构造函数</h3> 
<p><code>constexpr</code>可以声明基础类型从而获得常量表达式值，除此之外<code>constexpr</code>还能够声明用户自定义类型，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> X x <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x<span class="token punctuation">.</span>x1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> x1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X x<span class="token punctuation">;</span> <span class="token comment">// 编译失败，X不是字面类型</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，x.get()无法在编译阶段计算</span>
</code></pre> 
<p>以上代码自定义了一个结构体<code>X</code>，并且使用<code>constexpr</code>声明和初始化了变量<code>x</code>。到目前为止一切顺利，不过有时候我们并不希望成员变量被暴露出来，于是修改了<code>X</code>的结构：</p> 
<p>经过修改的代码不能通过编译了，因为<code>constexpr</code>说明符不能用来声明这样的自定义类型。解决上述问题的方法很简单，只需要用<code>constexpr</code>声明<code>X</code>类的构造函数，也就是声明一个常量表达式构造函数，当然这个构造函数也有一些规则需要遵循。</p> 
<ol><li>构造函数必须用<code>constexpr</code>声明。</li><li>构造函数初始化列表中必须是常量表达式。</li><li>构造函数的函数体必须为空（这一点基于构造函数没有返回值，所以不存在<code>return expr</code>）。</li></ol> 
<p>根据以上规则让我们改写类<code>X</code>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">constexpr</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">constexpr</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x1</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> x1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X x<span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>x<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面这段代码只是简单地给构造函数和<code>get</code>函数添加了<code>constexpr</code>说明符就可以编译成功，因为它们本身都符合常量表达式构造函数和常量表达式函数的要求，我们称这样的类为字面量类类型（literal class type）。其实代码中<code>constexpr int get() const</code> 的 <code>const</code> 有点多余，因为在C++11中，<code>constexpr</code>会自动给函数带上<code>const</code>属性。请注意，常量表达式构造函数拥有和常量表达式函数相同的退化特性，当它的实参不是常量表达式的时候，构造函数可以退化为普通构造函数，当然，这么做的前提是类型的声明对象不能为常量表达式值：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> X <span class="token function">x</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，不能使用constexpr声明</span>
X <span class="token function">y</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
</code></pre> 
<p>由于<code>i</code>不是一个常量，因此<code>X</code>的常量表达式构造函数退化为普通构造函数，这时对象<code>x</code>不能用<code>constexpr</code>声明，否则编译失败。</p> 
<p>最后需要强调的是，使用<code>constexpr</code>声明自定义类型的变量，必须确保这个自定义类型的析构函数是平凡的，否则也是无法通过编译的。平凡析构函数必须满足下面3个条件：</p> 
<ol><li>自定义类型中不能有用户自定义的析构函数。</li><li>析构函数不能是虚函数。</li><li>基类和成员的析构函数必须都是平凡的。</li></ol> 
<h3><a id="5__903"></a>5. 对浮点的支持</h3> 
<p>在<code>constexpr</code>说明符被引入之前，C++程序员经常使用enum hack来促使编译器在编译阶段计算常量表达式的值。但是因为<code>enum</code>只能操作整型，所以一直无法完成对于浮点类型的编译期计算。<code>constexpr</code>说明符则不同，它支持声明浮点类型的常量表达式值，而且标准还规定其精度必须至少和运行时的精度相同，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> x <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">constexpr</span> <span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="6_C14__916"></a>6. C++14 标准对常量表达式函数的增强</h3> 
<p>C++11标准对常量表达式函数的要求可以说是非常的严格，这一点影响该特性的实用性。幸好这个问题在C++14中得到了非常巨大的改善，C++14标准对常量表达式函数的改进如下。</p> 
<ol><li>函数体允许声明变量，除了没有初始化、<code>static</code>和 <code>thread_local</code>变量。</li><li>函数允许出现<code>if</code>和<code>switch</code>语句，不能使用<code>go</code>语句。</li><li>函数允许所有的循环语句，包括<code>for</code>、<code>while</code>、<code>do-while</code>。</li><li>函数可以修改生命周期和常量表达式相同的对象。</li><li>函数的返回值可以声明为<code>void</code>。</li><li><code>constexpr</code>声明的成员函数不再具有<code>const</code>属性。</li></ol> 
<p>因为这些改进的发布，在C++11中无法成功编译的常量表达式函数，在C++14中可以编译成功了：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		result <span class="token operator">+=</span> x<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> buffer1<span class="token punctuation">[</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer2<span class="token punctuation">[</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码中的<code>abs</code>和<code>sum</code>函数相比于前面使用条件表达式和递归方法实现的函数更加容易阅读和理解了。看到这里读者是否会有一些兴奋，但是别急，后面还有好戏：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">++</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里我们惊喜地发现，原来由于<code>++x</code>不是常量表达式，因此无法编译通过的问题也消失了，这就是基于第4点规则。需要强调的是，对于常量表达式函数的增强同样也会影响常量表达式构造函数：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">constexpr</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">constexpr</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			x1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			x1 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		x1 <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> x1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X <span class="token function">make_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	X x<span class="token punctuation">;</span>
	x<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">constexpr</span> X <span class="token function">x1</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">constexpr</span> X x2 <span class="token operator">=</span> <span class="token function">make_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> a1 <span class="token operator">=</span> x1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> a2 <span class="token operator">=</span> x2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>请注意，<code>main</code>函数里的4个变量<code>x1</code>、<code>x2</code>、<code>a1</code>和<code>a2</code>都有<code>constexpr</code>声明，也就是说它们都是编译期必须确定的值。有了这个前提条件，我们再来分析这段代码的神奇之处。首先对于常量表达式构造函数，我们发现可以在其函数体内使用<code>if</code>语句并且对<code>x1</code>进行赋值操作了。可以看到返回类型为<code>void</code>的<code>set</code>函数也被声明为<code>constexpr</code>了，这也意味着该函数能够运用在<code>constexpr</code>声明的函数体内，<code>make_x</code>函数就是利用了这个特性。根据规则4和规则6，<code>set</code>函数也能成功地修改<code>x1</code>的值了。让我们来看一看GCC生成的中间代码：</p> 
<pre><code class="prism language-cpp"><span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> D<span class="token punctuation">.</span><span class="token number">39319</span><span class="token punctuation">;</span>

  <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> x1<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> x2<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> a1<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> a2<span class="token punctuation">;</span>

    <span class="token keyword">try</span>
      <span class="token punctuation">{<!-- --></span>
        x1<span class="token punctuation">.</span>x1 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
        x2<span class="token punctuation">.</span>x1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
        a1 <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
        a2 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
        _1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>cout<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>_1<span class="token punctuation">,</span> endl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        _2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>cout<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>_2<span class="token punctuation">,</span> endl<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    finally
      <span class="token punctuation">{<!-- --></span>
        x1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>CLOBBER<span class="token punctuation">}</span><span class="token punctuation">;</span>
        x2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>CLOBBER<span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  D<span class="token punctuation">.</span><span class="token number">39319</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">39319</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从上面的中间代码可以清楚地看到，编译器直接给<code>x1.x1</code>、<code>x2.x1</code>、<code>a1</code>、<code>a2</code>进行了赋值，并没有运行时的计算操作。</p> 
<p>最后需要指出的是，C++14标准除了在常量表达式函数特性方面做了增强，也在标准库方面做了增强，包括 <code>&lt;complex&gt;</code>、<code>&lt;chrono&gt;</code>、<code>&lt;array&gt;</code>、<code>&lt;initializer_list&gt;</code>、<code>&lt;utility&gt;</code> 和 <code>&lt;tuple&gt;</code>。对于标准库的增强细节这里就不做介绍了，大家可以直接参阅STL源代码。</p> 
<h3><a id="7_constexpr_lambdas__1049"></a>7. constexpr lambdas 表达式</h3> 
<p>从C++17开始，lambda表达式在条件允许的情况下都会隐式声明为<code>constexpr</code>。这里所说的条件，即是上一节中提到的常量表达式函数的规则，本节里就不再重复论述。结合lambda的这个新特性，先看一个简单的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">58</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> get_size <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer1<span class="token punctuation">[</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer2<span class="token punctuation">[</span><span class="token function">get_size</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以看到，以上代码定义的是一个“普通”的lambda表达式，但是在 C++17标准中，这些“普通”的lambda表达式却可以用在常量表达式函数和数组长度中，可见该lambda表达式的结果在编译阶段已经计算出来了。实际上这里的<code>[](int i) { return i * 2; }</code>相当于：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">GetSize</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>当lambda表达式不满足<code>constexpr</code>的条件时，lambda表达式也不会出现编译错误，它会作为运行时lambda表达式存在：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 情况1</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> get_size <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer1<span class="token punctuation">[</span><span class="token function">get_size</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，get_size需要运行时调用</span>
<span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 情况2</span>
<span class="token keyword">auto</span> get_count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码中情况1和常量表达式函数相同，<code>get_size</code>可能会退化为运行时lambda表达式对象。当这种情况发生的时候，<code>get_size</code>的返回值不再具有作为数组长度的能力，但是运行时调用<code>get_size</code>对象还是没有问题的。GCC在这种情况下依然能够在编译阶段求出<code>get_size</code>的值，MSVC和CLang则不行。对于情况2，由于<code>static</code>变量的存在，lambda表达式对象<code>get_count</code>不可能在编译期运算，因此它最终会在运行时计算。</p> 
<p>值得注意的是，我们也可以强制要求lambda表达式是一个常量表达式，用<code>constexpr</code>去声明它即可。这样做的好处是可以检查lambda表达式是否有可能是一个常量表达式，如果不能则会编译报错，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> get_size <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">constexpr</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer2<span class="token punctuation">[</span><span class="token function">get_size</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> get_count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">constexpr</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，x是一个static变量</span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="8_constexpr__1107"></a>8. constexpr 的内联属性</h3> 
<p>在C++17标准中，<code>constexpr</code>声明静态成员变量时，也被赋予了该变量的内联属性，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num<span class="token punctuation">{<!-- --></span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码在C++17中等同于：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num<span class="token punctuation">{<!-- --></span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>那么问题来了，自C++11标准推行以来<code>static constexpr int num{ 5 }</code>这种用法就一直存在了，那么同样的代码在C++11和C++17中究竟又有什么区别呢？</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num<span class="token punctuation">{<!-- --></span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>代码中，<code>num</code>是只有声明没有定义的，虽然我们可以通过 <code>std::cout &lt;&lt; X::num &lt;&lt; std::endl</code> 输出其结果，但这实际上是编 译器的一个小把戏，它将 <code>X::num</code> 直接替换为了5。如果将输出语句修改 为 <code>std::cout &lt;&lt; &amp;X::num &lt;&lt; std::endl</code>，那么链接器会明确报 告 <code>X::num</code> 缺少定义。但是从 C++17 开始情况发生了变化，<code>static constexpr int num{5}</code> 既是声明也是定义，所以在 C++17 标准中 <code>std::cout &lt;&lt; &amp;X::num &lt;&lt; std::endl</code> 可以顺利编译链接，并且输出 正确的结果。值得注意的是，对于编译器而言为 <code>X::num</code> 产生定义并不 是必需的，如果代码只是引用了 <code>X::num</code> 的值，那么编译器完全可以使 用直接替换为值的技巧。只有当代码中引用到变量指针的时候，编译器 才会为其生成定义。</p> 
<h3><a id="9_if_constexpr_1137"></a>9. if constexpr</h3> 
<p><code>if constexpr</code> (C++17 标准提出的一个非常有用的特性，可以用 于编写紧凑的模板代码，让代码能够根据编译时的条件进行实例化。这 里有两点需要特别注意。</p> 
<p>1．<code>if constexpr</code>的条件必须是编译期能确定结果的常量表达式。<br> 2．条件结果一旦确定，编译器将只编译符合条件的代码块。</p> 
<p>由此可见，该特性只有在使用模板的时候才具有实际意义，若是用在普通函数上，效果会非常尴尬，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">check1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>					<span class="token comment">// 编译失败，不是常量表达式</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i &gt; 0"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i &lt;= 0"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">check2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(int) &gt; sizeof(char)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(int) &lt;= sizeof(char)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对于函数<code>check1</code>，由于<code>if constexpr</code>的条件不是一个常量表达式，因此无法编译通过。而对于函数<code>check2</code>，这里的代码最后会被编 译器省略为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">check2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(int) &gt; sizeof(char)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是当<code>if constexpr</code>运用于模板时，情况将非常不同。来看下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">bool</span> <span class="token function">is_same_value</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a <span class="token operator">==</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">bool</span> <span class="token generic-function"><span class="token function">is_same_value</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">abs</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.0001</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.1</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"is_same_value(5, 5)	: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">is_same_value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x == 0.0			: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0.</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"is_same_value(x, 0.)	: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">is_same_value</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">0.</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>计算结果如下：</p> 
<pre><code class="prism language-cpp"><span class="token function">is_same_value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token boolean">true</span>
x <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token function">is_same_value</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">0.</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token boolean">true</span>
</code></pre> 
<p>我们知道浮点数的比较和整数是不同的，通常情况下它们的差小于 某个阈值就认为两个浮点数相等。我们把<code>is_same_value</code>写成函数模 板，并且对<code>double</code>类型进行特化。这里如果使用<code>if constexpr</code>表达 式，代码会简化很多而且更加容易理解，让我们看一看简化后的代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">bool</span> <span class="token function">is_same_value</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">abs</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.0001</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> a <span class="token operator">==</span> b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面这段代码中，直接使用<code>if constexpr</code>判断模板参数是否 为<code>double</code>，如果条件成立，则使用<code>double</code>的比较方式；否则使用普通 的比较方式，代码变得简单明了。再次强调，这里的选择是编译期做出 的，一旦确定了条件，那么就只有被选择的代码块才会被编译；另外的 代码块则会被忽略。说到这里，需要提醒读者注意这样一种陷阱：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">auto</span> <span class="token function">minus</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">abs</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.0001</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0.</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">5.11</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">5.60002</span><span class="token punctuation">,</span> <span class="token number">5.600011</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上是一个带精度限制的减法函数，当参数类型为<code>double</code>且计算 结果小于<code>0.0001</code>的时候，我们就可以认为计算结果为<code>0</code>。当参数类型为 整型时，则不用对精度做任何限制。上面的代码编译运行没有任何问 题，因为编译器根据不同的类型选择不同的分支进行编译。但是如果修改一下上面的代码，结果可能就很难预料了：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">auto</span> <span class="token function">minus</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">abs</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.0001</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0.</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码删除了<code>else</code>关键词而直接将<code>else</code>代码块提取出来，不过 根据以往运行时<code>if</code>的经验，它并不会影响代码运行的逻辑。遗憾的是， 这种写法有可能导致编译失败，因为它可能会导致函数有多个不同的返 回类型。当实参为整型时一切正常，编译器会忽略<code>if</code>的代码块，直接编译<code>return static_cast&lt;int&gt;(a − b)</code>，这样返回类型只有<code>int</code>一种。 但是当实参类型为<code>double</code>的时候，情况发生了变化。<code>if</code>的代码块会被 正常地编译，代码块内部的返回结果类型为<code>double</code>，而代码块外部的 <code>return static_cast&lt;int&gt;(a − b)</code>同样会照常编译，这次的返回类 型为<code>int</code>。编译器遇到了两个不同的返回类型，只能报错。</p> 
<p>和运行时<code>if</code>的另一个不同点：<code>if constexpr</code>不支持短路规则。这 在程序编写时往往也能成为一个陷阱：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">auto</span> <span class="token function">any2i</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&amp;&amp;</span> T<span class="token double-colon punctuation">::</span>npos <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">atoi</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> t<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">any2i</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"6"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">any2i</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码很好理解，函数模板<code>any2i</code>的实参如果是一个<code>std::string</code>，那么它肯定满足<code>std::is_same&lt;T, std::string&gt;::value &amp;&amp; T::npos == -1</code>的条件，所以编译器会编 译<code>if</code>分支的代码。如果实参类型是一个<code>int</code>，那么<code>std::is_same&lt;T, std::string&gt;::value</code>会返回<code>false</code>，根据短路规则，<code>if</code>代码块不会 被编译，而是编译<code>else</code>代码块的内容。一切看起来是那么简单直接，但 是编译过后会发现，代码<code>std::cout &lt;&lt; any2i(std:: string("6")) &lt;&lt; std::endl</code>顺利地编译成功，<code>std::cout &lt;&lt; any2i(6) &lt;&lt; std::endl</code>则会编译失败，因为<code>if constexpr</code>不支持短 路规则。当函数实参为<code>int</code>时，<code>std::is_same&lt;T, std::string&gt;::value</code>和<code>T::npos == -1</code>都会被编译，由于 <code>int::npos</code>显然是一个非法的表达式，因此会造成编译失败。这里正确 的写法是通过嵌套<code>if constexpr</code>来替换上面的操作：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">auto</span> <span class="token function">any2i</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token keyword">constexpr</span><span class="token punctuation">(</span>T<span class="token double-colon punctuation">::</span>npos <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">atoi</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> t<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="10__constexpr__1314"></a>10. 允许 constexpr 虚函数</h3> 
<p>在<code>C++20</code>标准之前，虚函数是不允许声明为<code>constexpr</code>的。看似有 道理的规则其实并不合理，因为虚函数很多时候可能是无状态的，这种 情况下它是有条件作为常量表达式被优化的，比如下面这个函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    X x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码会先执行<code>X::f</code>函数，然后将结果赋值给<code>i</code>，它的 GIMPLE中间的代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> D<span class="token punctuation">.</span><span class="token number">2137</span><span class="token punctuation">;</span>

  <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">X</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">try</span>
      <span class="token punctuation">{<!-- --></span>
        _1 <span class="token operator">=</span> <span class="token operator">&amp;</span>_ZTV1X <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>_vptr<span class="token punctuation">.</span>X <span class="token operator">=</span> _1<span class="token punctuation">;</span>
        i <span class="token operator">=</span> <span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">f</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意此处赋值</span>
      <span class="token punctuation">}</span>
    finally
      <span class="token punctuation">{<!-- --></span>
        x <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>CLOBBER<span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  D<span class="token punctuation">.</span><span class="token number">2137</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">2137</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">f</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> D<span class="token punctuation">.</span><span class="token number">2139</span><span class="token punctuation">;</span>

  D<span class="token punctuation">.</span><span class="token number">2139</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">2139</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>观察上面的两份代码，虽然<code>X::f</code>是一个虚函数，但是它非常适合作 为常量表达式进行优化。这样一来，<code>int i = x.f();</code>可以被优化 为<code>int i = 1;</code>，减少一次函数的调用过程。可惜在<code>C++17</code>标准中不允 许我们这么做，直到<code>C++20</code>标准明确允许在常量表达式中使用虚函数， 所以上面的代码可以修改为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">constexpr</span> <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">constexpr</span> X x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>它的中间代码也会优化为：</p> 
<pre><code class="prism language-cpp"><span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> D<span class="token punctuation">.</span><span class="token number">2138</span><span class="token punctuation">;</span>

  <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">try</span>
      <span class="token punctuation">{<!-- --></span>
        _1 <span class="token operator">=</span> <span class="token operator">&amp;</span>_ZTV1X <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>_vptr<span class="token punctuation">.</span>X <span class="token operator">=</span> _1<span class="token punctuation">;</span>
        i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 注意此处赋值</span>
      <span class="token punctuation">}</span>
    finally
      <span class="token punctuation">{<!-- --></span>
        x <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>CLOBBER<span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  D<span class="token punctuation">.</span><span class="token number">2138</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">2138</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从中间代码中可以看到，<code>i</code>被直接赋值为<code>1</code>，在此之前并没有调 用<code>X::f</code>函数。另外值得一提的是，<code>constexpr</code>的虚函数在继承重写上并 没有其他特殊的要求，<code>constexpr</code>的虚函数可以覆盖重写普通虚函数， 普通虚函数也可以覆盖重写<code>constexpr</code>的虚函数，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X1</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">X2</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">X1</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">constexpr</span> <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">X3</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">X2</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">X4</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">X3</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">constexpr</span> <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token punctuation">(</span>X1<span class="token double-colon punctuation">::</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>X1<span class="token double-colon punctuation">::</span>f<span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X2 x2<span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> x2<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>x2<span class="token punctuation">.</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X1 <span class="token keyword">const</span><span class="token operator">&amp;</span> r2 <span class="token operator">=</span> x2<span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> r2<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>r2<span class="token punctuation">.</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X1 <span class="token keyword">const</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>x2<span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> p2<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>p2<span class="token operator">-&gt;</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X4 x4<span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> x4<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>x4<span class="token punctuation">.</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X1 <span class="token keyword">const</span><span class="token operator">&amp;</span> r4 <span class="token operator">=</span> x4<span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> r4<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>r4<span class="token punctuation">.</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> X1 <span class="token keyword">const</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>x4<span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> p4<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>p4<span class="token operator">-&gt;</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>最后要说明的是，我在验证这条规则时，<code>GCC</code>无论在<code>C++17</code>还是 C++20 标准中都可以顺利编译通过，而<code>Clang</code>在<code>C++17</code>中会给出 <code>constexpr</code>无法用于虚函数的错误提示。</p> 
<h3><a id="11__constexpr__Trycatch_1455"></a>11. 允许在 constexpr 函数中出现 Try-catch</h3> 
<p>在C++20标准以前<code>Try-catch</code>是不能出现在<code>constexpr</code>函数中的，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span>…<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>不过似乎编译器对此规则的态度都十分友好，当我们用<code>C++17</code>标准 去编译这份代码时，编译器会编译成功并给出一个友好的警告，说明这 条特性需要使用<code>C++20</code>标准。<code>C++20</code>标准允许<code>Try-catch</code>存在于 constexpr函数，但是<code>throw</code>语句依旧是被禁止的，所以<code>try</code>语句是不能 抛出异常的，这也就意味着<code>catch</code>永远不会执行。实际上，当函数被评 估为常量表达式的时候<code>Try-catch</code>是没有任何作用的。</p> 
<h3><a id="12__constexpr__1467"></a>12. 允许在 constexpr 中进行平凡的默认初始化</h3> 
<p>从C++20开始，标准允许在<code>constexpr</code>中进行平凡的默认初始化，这样进一步减少<code>constexpr</code>的特殊性。例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">bool</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面的代码非常简单，在任何环境下都可以顺利编译。不过如果将函数<code>f</code>改为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么在<code>C++17</code>标准的编译环境就会报错，提示<code>x</code>没有初始化，它需 要用户提供一个构造函数。当然这个问题在<code>C++17</code>标准中也很容易解 决，例如修改<code>X</code>为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">bool</span> val <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="13__constexpr__1496"></a>13. 允许在 constexpr 中更改联合类型的有效成员</h3> 
<p>在C++20标准之前对<code>constexpr</code>的另外一个限制就是禁止更改联合类型的有效成员，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">union</span> Foo <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">float</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	Foo foo<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	foo<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	foo<span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token number">1.2f</span><span class="token punctuation">;</span> <span class="token comment">// C++20之前编译失败</span>
	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>foo</code>是一个联合类型对象，<code>foo.i = 3;</code>首次确定 了有效成员为<code>i</code>，这没有问题，接下来代码<code>foo.f = 1.2f;</code>改变有效成 员为<code>f</code>，这就违反了标准中关于不能更改联合类型的有效成员的规则， 所以导致编译失败。现在<code>C++20</code>标准已经删除了这条规则，以上代码可 以编译成功。实际编译过程中，只有<code>Clang</code>会在<code>C++17</code>标准中对以上代 码报错，而<code>GCC</code>和<code>MSVC</code>均能用<code>C++17</code>和<code>C++20</code>标准编译成功。 <code>C++20</code>标准对<code>constexpr</code>做了很多修改，除了上面提到的修改以 外，还修改了一些并不常用的地方，包括允许<code>dynamic_cast</code>和<code>typeid</code> 出现在常量表达式中；允许在<code>constexpr</code>函数使用未经评估的内联汇 编。这些修改都没有需要详细介绍的特别之处，有兴趣的读者可以自己 写点实验代码测试一下。</p> 
<h3><a id="14__consteval__1514"></a>14. 使用 consteval 声明立即函数</h3> 
<p>前面我们曾提到过，<code>constexpr</code>声明函数时并不依赖常量表达式上 下文环境，在非常量表达式的环境中，函数可以表现为普通函数。不过 有时候，我们希望确保函数在编译期就执行计算，对于无法在编译期执 行计算的情况则让编译器直接报错。于是在<code>C++20</code>标准中出现了一个新 的概念——立即函数，该函数需要使用<code>consteval</code>说明符来声明：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">consteval</span> <span class="token keyword">int</span> <span class="token function">sqr</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> n<span class="token operator">*</span>n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sqr</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> r2 <span class="token operator">=</span> <span class="token function">sqr</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败</span>
</code></pre> 
<p>在上面的代码中<code>sqr(100);</code>是一个常量表达式上下文环境，可以编 译成功。相反，因为<code>sqr(x);</code>中的<code>x</code>是可变量，不能作为常量表达式， 所以编译器抛出错误。要让代码成功编译，只需要给<code>x</code>加上<code>const</code>即 可。需要注意的是，如果一个立即函数在另外一个立即函数中被调用， 则函数定义时的上下文环境不必是一个常量表达式，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">consteval</span> <span class="token keyword">int</span> <span class="token function">sqrsqr</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">sqr</span><span class="token punctuation">(</span><span class="token function">sqr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>sqrsqr</code>是否能编译成功取决于如何调用，如果调用时处于一个常量表达式环境，那么就能通过编译：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">sqrsqr</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>反之则编译失败：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">sqrsqr</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>lambda</code>表达式也可以使用<code>consteval</code>说明符：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> sqr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token keyword">consteval</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> n <span class="token operator">*</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sqr</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> sqr<span class="token punctuation">;</span> <span class="token comment">// 编译失败，尝试获取立即函数的函数地址</span>
</code></pre> 
<h3><a id="15__constinit__1556"></a>15. 使用 constinit 检查常量初始化</h3> 
<p>在C++中有一种典型的错误叫作“Static Initialization Order Fiasco”， 指的是因为静态初始化顺序错误导致的问题。因为这种错误往往发生在 main函数之前，所以比较难以排查。举一个典型的例子，假设有两个静 态对象<code>x</code>和<code>y</code>分别存在于两个不同的源文件中。其中一个对象<code>x</code>的构造函 数依赖于对象<code>y</code>。没错，就是这样，现在我们有50%的可能性会出错， 因为我们没有办法控制哪个对象先构造。如果对象<code>x</code>在<code>y</code>之前构造，那么 就会引发一个未定义的结果。为了避免这种问题的发生，我们通常希望 使用常量初始化程序去初始化静态变量。不幸的是，常量初始化的规则 很复杂，需要一种方法帮助我们完成检查工作，当不符合常量初始化程 序的时候可以在编译阶段报错。于是在<code>C++20</code>标准中引入了新的 constinit说明符。</p> 
<p>正如上文所描述的<code>constinit</code>说明符主要用于具有静态存储持续时 间的变量声明上，它要求变量具有常量初始化程序。首先，<code>constinit</code> 说明符作用的对象是必须具有静态存储持续时间的，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constinit</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功，全局变量具有静态存储持续</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">constinit</span> <span class="token keyword">static</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功，静态变量具有静态存储持续</span>
	<span class="token keyword">constinit</span> <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，局部变量是动态分配的</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其次，<code>constinit</code>要求变量具有常量初始化程序：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token string">"cpp"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">constinit</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str1 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误，f()不是一个常量初始化程序</span>
<span class="token keyword">constinit</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str2 <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
</code></pre> 
<p><code>constinit</code>还能用于非初始化声明，以告知编译器<code>thread_local</code>变量已被初始化：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">extern</span> <span class="token keyword">thread_local</span> <span class="token keyword">constinit</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p>最后值得一提的是，虽然<code>constinit</code>说明符一直在强调常量初始化，但是初始化的对象并不要求具有常量属性。</p> 
<h3><a id="16__1586"></a>16. 判断常量求值环境</h3> 
<p><code>std::is_constant_evaluated</code>是<code>C++20</code>新加入标准库的函数，它 用于检查当前表达式是否是一个常量求值环境，如果在一个明显常量求 值的表达式中，则返回<code>true</code>；否则返回<code>false</code>。该函数包含 在<code>&lt;type_traits&gt;</code>头文件中，虽然看上去像是一个标准库实现的函数， 但实际上调用的是编译器内置函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">is_constant_evaluated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">__builtin_is_constant_evaluated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该函数通常会用于代码优化中，比如在确定为常量求值的环境时， 使用<code>constexpr</code>能够接受的算法，让数值在编译阶段就得出结果。而对 于其他环境则采用运行时计算结果的方法。提案文档中提供了一个很好 的例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span>
<span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">is_constant_evaluated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">,</span> p <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>u <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> r <span class="token operator">*=</span> p<span class="token punctuation">;</span>
      u <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
      p <span class="token operator">*=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">constexpr</span> <span class="token keyword">double</span> kilo <span class="token operator">=</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 常量求值</span>
  <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> mucho <span class="token operator">=</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 非常量求值</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>power</code>函数根 据<code>std::is_constant_evaluated()</code>和<code>x &gt;= 0</code>的结果选择不同的实现 方式。其中，<code>kilo = power(10.0, 3);</code>是一个常量求值，所以 <code>std::is_constant_evaluated() &amp;&amp; x &gt;= 0</code>返回<code>true</code>，编译器在 编译阶段求出结果。反之，<code>mucho = power(10.0, n)</code>则需要调 用<code>std::pow</code>在运行时求值。让我们通过中间代码看一看编译器具体做了什么：</p> 
<pre><code class="prism language-cpp"><span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> D<span class="token punctuation">.</span><span class="token number">25877</span><span class="token punctuation">;</span>

  <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">double</span> kilo<span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">double</span> mucho<span class="token punctuation">;</span>

    kilo <span class="token operator">=</span> <span class="token number">1.0e+3</span><span class="token punctuation">;</span>              <span class="token comment">// 直接赋值</span>
    n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    mucho <span class="token operator">=</span> <span class="token function">power</span> <span class="token punctuation">(</span><span class="token number">1.0e+1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 运行时计算</span>
    D<span class="token punctuation">.</span><span class="token number">25877</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">25877</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  D<span class="token punctuation">.</span><span class="token number">25877</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">25877</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token function">power</span> <span class="token punctuation">(</span><span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">bool</span> retval<span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">bool</span> iftmp<span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> D<span class="token punctuation">.</span><span class="token number">25892</span><span class="token punctuation">;</span>

  <span class="token punctuation">{<!-- --></span>
    _1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">is_constant_evaluated</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_1 <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25883</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25881</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25883</span><span class="token operator">&gt;</span><span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25884</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25881</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25884</span><span class="token operator">&gt;</span><span class="token operator">:</span>
    iftmp<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25882</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25881</span><span class="token operator">&gt;</span><span class="token operator">:</span>
    iftmp<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25882</span><span class="token operator">&gt;</span><span class="token operator">:</span>
    retval<span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">=</span> iftmp<span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25885</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25886</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25885</span><span class="token operator">&gt;</span><span class="token operator">:</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">double</span> r<span class="token punctuation">;</span>
      <span class="token keyword">double</span> p<span class="token punctuation">;</span>
      <span class="token keyword">unsigned</span> <span class="token keyword">int</span> u<span class="token punctuation">;</span>

      r <span class="token operator">=</span> <span class="token number">1.0e+0</span><span class="token punctuation">;</span>
      p <span class="token operator">=</span> b<span class="token punctuation">;</span>
      u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>
      <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25887</span><span class="token operator">&gt;</span><span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">24379</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25888</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
      <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25888</span><span class="token operator">&gt;</span><span class="token operator">:</span>
      _2 <span class="token operator">=</span> u <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>_2 <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25889</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25890</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
      <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25889</span><span class="token operator">&gt;</span><span class="token operator">:</span>
      r <span class="token operator">=</span> r <span class="token operator">*</span> p<span class="token punctuation">;</span>
      <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25891</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
      <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25890</span><span class="token operator">&gt;</span><span class="token operator">:</span>
      <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25891</span><span class="token operator">&gt;</span><span class="token operator">:</span>
      u <span class="token operator">=</span> u <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
      p <span class="token operator">=</span> p <span class="token operator">*</span> p<span class="token punctuation">;</span>
      <span class="token keyword">goto</span> <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25887</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
      <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">24379</span><span class="token operator">&gt;</span><span class="token operator">:</span>
      D<span class="token punctuation">.</span><span class="token number">25892</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
      <span class="token comment">// predicted unlikely by early return (on trees) predictor.</span>
      <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">25892</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">&lt;</span>D<span class="token punctuation">.</span><span class="token number">25886</span><span class="token operator">&gt;</span><span class="token operator">:</span>
    _3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>
    D<span class="token punctuation">.</span><span class="token number">25892</span> <span class="token operator">=</span> <span class="token function">pow</span> <span class="token punctuation">(</span>b<span class="token punctuation">,</span> _3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">25892</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


std<span class="token double-colon punctuation">::</span><span class="token function">is_constant_evaluated</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">bool</span> D<span class="token punctuation">.</span><span class="token number">25894</span><span class="token punctuation">;</span>

  <span class="token keyword">try</span>
    <span class="token punctuation">{<!-- --></span>
      D<span class="token punctuation">.</span><span class="token number">25894</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">25894</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">catch</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token function">eh_must_not_throw</span> <span class="token punctuation">(</span>terminate<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>观察上面的中间代码，首先让我们注意到的就是<code>main</code>函数中<code>kilo</code> 和<code>mucho</code>赋值形式的不同。正如我们刚才讨论的那样，对于<code>kilo</code>的结果 编译器在编译期已经计算完成，所以这里是直接为<code>1.0e+3</code>，而对于 <code>mucho</code>则需要调用<code>std::power</code>函数。接着，我们可以观察 <code>std::is_constant_evaluated()</code>这个函数的实现，很明显编译器让 它直接返回<code>0</code>（也就是<code>false</code>），在代码中实现的<code>power</code>函数虽然 有<code>std::is_constant_evaluated()</code>结果为<code>true</code>时的算法实现，但是 却永远不会被调用。因为当<code>std::is_constant_evaluated()</code>为<code>true</code> 时，编译器计算了函数结果；反之函数会交给<code>std::power</code>计算结果。</p> 
<p>在了解了<code>std::is_constant_evaluated()</code>的用途之后，我们还需要弄清楚何为明显常量求值。只有弄清楚这个概念，才可能合理运 用<code>std::is_constant_evaluated()</code>函数。明显常量求值在标准文档中列举了下面几个类别。</p> 
<p>1．常量表达式，这个类别包括很多种情况，比如数组长度、case 表达式、非类型模板实参等。</p> 
<p>2．<code>if constexpr</code>语句中的条件。</p> 
<p>3．<code>constexpr</code>变量的初始化程序。</p> 
<p>4．立即函数调用。</p> 
<p>5．约束概念表达式。</p> 
<p>6．可在常量表达式中使用或具有常量初始化的变量初始化程序。</p> 
<p>下面我们通过几个标准文档中的例子来体会以上规则：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
X<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span><span class="token function">is_constant_evaluated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> x<span class="token punctuation">;</span> <span class="token comment">// 非类型模板实参，函数返回true，最终类型为 X&lt;true&gt;</span>

<span class="token keyword">int</span> y<span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">is_constant_evaluated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">13</span> <span class="token operator">:</span> <span class="token number">17</span><span class="token punctuation">;</span> <span class="token comment">// n是13</span>
	<span class="token keyword">int</span> m <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">is_constant_evaluated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">13</span> <span class="token operator">:</span> <span class="token number">17</span><span class="token punctuation">;</span> <span class="token comment">// m可能是13或者17，取决于函数环境</span>
	<span class="token keyword">char</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// char[13]</span>
	<span class="token keyword">return</span> m <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// m是13；p结果如下26</span>
<span class="token keyword">int</span> q <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// m是17；q结果如下56</span>
</code></pre> 
<p>上面的代码中需要解释的是<code>int p = f();</code>和<code>int q = p + f();</code> 的区别，对于前者，<code>std::is_constant_evaluated() == true</code>时<code>p</code> 一定是一个恒定值，它是明显常量求值，所以<code>p</code>的结果是<code>26</code>。相 反，<code>std::is_constant_evaluated() == true</code>时，<code>q</code>的结果会依 赖<code>p</code>，所以明显常量求值的结论显然不成立，需要采 用<code>std::is_constant_evaluated() == false</code>的方案，于是<code>f()</code>函数 中的<code>m</code>为<code>17</code>，最终<code>q</code>的求值结果是<code>56</code>。另外，如果这里的<code>p</code>初始化改变 为<code>const int p = f();</code>，那么<code>f()</code>函数 中的<code>m</code>为<code>13</code>，<code>q</code>的求值结果也会 改变为<code>52</code>。</p> 
<p>最后需要注意的是，如果当判断是否为明显常量求值时存在多个条 件，那么编译器会试探<code>std::is_constant_evaluated()</code>两种情况求值，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">is_constant_evaluated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> y <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 函数返回false，a运行时初始化为1</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">is_constant_evaluated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> y<span class="token punctuation">;</span> <span class="token comment">// 函数返回true，b编译时初始化为2</span>
</code></pre> 
<p>当对<code>a</code>求值时，编译器试探<code>std::is_constant_evaluated() == true</code>的情况，发现<code>y</code>会改变<code>a</code>的值，所以最后选择 <code>std::is_constant_evaluated() == false</code>；当对<code>b</code>求值时，编译器 同样试探<code>std::is_constant_evaluated() == true</code>的情况，发现<code>b</code> 的结果恒定为<code>2</code>，于是直接在编译时完成初始化。</p> 
<h2><a id="C17_1763"></a>二十八、确定的表达式求值顺序（C++17）</h2> 
<h3><a id="1__1764"></a>1. 表达式求值顺序的不确定性</h3> 
<p>在C++语言之父本贾尼·斯特劳斯特卢普的作品《C++程序设计语言（第4版）》中有一段这样的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">"but I have heard it works even if you don't believe in it"</span><span class="token punctuation">;</span>
	s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"even"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"only"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">" don't"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"I have heard it works only if you believe in it"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码的本意是描述<code>std::string</code>成员函数<code>replace</code>的用法，但 令人意想不到的是，在<code>C++17</code>之前它隐含着一个很大的问题，该问题的 根源是表达式求值顺序。具体来说，是指一个表达式中的子表达式的求 值顺序，而这个顺序在<code>C++17</code>之前是没有具体说明的，所以编译器可以 以任何顺序对子表达式进行求值。比如说<code>foo(a, b, c)</code>，这里的 foo、a、b和c的求值顺序是没有确定的。回到上面的替换函数，如果 这里的执行顺序为：</p> 
<pre><code class="prism language-cpp"><span class="token number">1</span>． <span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
<span class="token number">2</span>． tmp1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"even"</span><span class="token punctuation">)</span>
<span class="token number">3</span>． <span class="token function">replace</span><span class="token punctuation">(</span>tmp1<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"only"</span><span class="token punctuation">)</span>
<span class="token number">4</span>． tmp2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token string">" don't"</span><span class="token punctuation">)</span>
<span class="token number">5</span>． <span class="token function">replace</span><span class="token punctuation">(</span>tmp2<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
</code></pre> 
<p>那结果肯定是“I have heard it works only if you believe in it”，没有任何问题。但是由于没有对表达式求值顺序的严格规定，因此其求值顺序可能会变成：</p> 
<pre><code class="prism language-cpp"><span class="token number">1</span>． tmp1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"even"</span><span class="token punctuation">)</span>
<span class="token number">2</span>． tmp2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token string">" don't"</span><span class="token punctuation">)</span>
<span class="token number">3</span>． <span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
<span class="token number">4</span>． <span class="token function">replace</span><span class="token punctuation">(</span>tmp1<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"only"</span><span class="token punctuation">)</span>
<span class="token number">5</span>． <span class="token function">replace</span><span class="token punctuation">(</span>tmp2<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
</code></pre> 
<p>相应的结果就不是那么正确了，我们会得到“I have heard it works evenonlyyoudonieve in it”。<br> 为了证实这种问题发生的可能性，我找到了两个版本的GCC编译运 行上面的代码，在最新GCC中可以得到期望的字符串，其中间代码 GIMPLE也很好地描述了编译后表达式求值的顺序：</p> 
<pre><code class="prism language-cpp">_1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">replace</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
_2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">find</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token string">"even"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
_3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">replace</span> <span class="token punctuation">(</span>_1<span class="token punctuation">,</span> _2<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"only"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
_4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">find</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token string">" don\'t"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">replace</span> <span class="token punctuation">(</span>_3<span class="token punctuation">,</span> _4<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>但是在使用GCC5.4的时候，出现了“I have heard it works evenonlyyou donieve in it”的结果，查看GIMPLE以后会发现其表达式求值顺序发生了变化：</p> 
<pre><code class="prism language-cpp">D<span class="token punctuation">.</span><span class="token number">22309</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">find</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token string">" don\'t"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
D<span class="token punctuation">.</span><span class="token number">22310</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">find</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token string">"even"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
D<span class="token punctuation">.</span><span class="token number">22311</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">replace</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
D<span class="token punctuation">.</span><span class="token number">22312</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">replace</span> <span class="token punctuation">(</span>D<span class="token punctuation">.</span><span class="token number">22311</span><span class="token punctuation">,</span> D<span class="token punctuation">.</span><span class="token number">22310</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"only"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">replace</span> <span class="token punctuation">(</span>D<span class="token punctuation">.</span><span class="token number">22312</span><span class="token punctuation">,</span> D<span class="token punctuation">.</span><span class="token number">22309</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>除了上述的例子之外，我们常用的<code>&lt;&lt;</code>操作符也面临同样的问题：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>虽然我们认为上面的表达式应该按照<code>f()、g()、h()</code>顺序对表达式求值，但是编译器对此并不买单，在它看来这个顺序可以是任意的。</p> 
<h3><a id="2__1823"></a>2. 表达式求值顺序详解</h3> 
<p>从<code>C++17</code>开始，函数表达式一定会在函数的参数之前求值。也就是 说在<code>foo(a, b, c)</code>中，<code>foo</code>一定会在<code>a</code>、<code>b</code>和<code>c</code>之前求值。但是请注意， 参数之间的求值顺序依然没有确定，也就是说<code>a</code>、<code>b</code>和<code>c</code>谁先求值还是没 有规定。对于这一点我和读者应该是同样的吃惊，因为从提案文档上看 来，有充分的理由说明从左往右进行参数列表的表达式求值的可行性。 我想一个可能的原因是求值顺序的改变影响到代码的优化路径，比如内 行决策和寄存器分配方式，对于编译器实现来说也是不小的挑战吧。不 过既然标准已经这么定下来了，我们就应该去适应标准。在函数的参数 列表中，尽可能少地修改共享的对象，否则会很难确认实参的真实值。</p> 
<p>对于后缀表达式和移位操作符而言，表达式求值总是从左往右，比 如：</p> 
<pre><code class="prism language-cpp">E1<span class="token punctuation">[</span>E2<span class="token punctuation">]</span>
E1<span class="token punctuation">.</span>E2
E1<span class="token punctuation">.</span><span class="token operator">*</span>E2
E1<span class="token operator">-&gt;</span><span class="token operator">*</span>E2
E1<span class="token operator">&lt;&lt;</span>E2
E1<span class="token operator">&gt;&gt;</span>E2
</code></pre> 
<p>在上面的表达式中，子表达式求值<code>E1</code>总是优先于<code>E2</code>。而对于赋值表 达式，这个顺序又正好相反，它的表达式求值总是从右往左，比如：</p> 
<pre><code class="prism language-cpp">E1<span class="token operator">=</span>E2
E1<span class="token operator">+=</span>E2
E1<span class="token operator">-=</span>E2
E1<span class="token operator">*=</span>E2
E1<span class="token operator">/=</span>E2
…
</code></pre> 
<p>在上面的表达式中，子表达式求值<code>E2</code>总是优先于<code>E1</code>。这里虽然只列 出了几种赋值表达式的形式，但实际上对于<code>E1@=E2</code>这种形式的表达式 （其中<code>@</code>可以为<code>+、−、*、/、%</code>等）<code>E2</code>早于<code>E1</code>求值总是成立的。</p> 
<p>对于<code>new</code>表达式，<code>C++17</code>也做了规定。对于：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span>
</code></pre> 
<p>这里<code>new</code>表达式的内存分配总是优先于<code>T</code>构造函数中参数<code>E</code>的求值。 最后<code>C++17</code>还明确了一条规则：涉及重载运算符的表达式的求值顺序应 由与之相应的内置运算符的求值顺序确定，而不是函数调用的顺序规 则。</p> 
<p>在经过C++17标准一系列对于表达式求值顺序的改善之后，《C++程序设计语言》中的那段代码就可以确保最终获得的字符串为：“I have heard it works only if you believe in it”。</p> 
<h2><a id="C11C17_1863"></a>二十九、字面量优化（C++11～C++17）</h2> 
<h3><a id="1__1864"></a>1. 十六进制浮点字面量</h3> 
<p>从<code>C++11</code>开始，标准库中引入了<code>std::hexfloat</code>和 <code>std::defaultfloat</code>来修改浮点输入和输出的默认格式化，其中 <code>std::hexfloat</code>可以将浮点数格式化为十六进制的字符串， 而<code>std::defaultfloat</code>可以将格式还原到十进制，以输出为例：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">double</span> float_array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token number">5.875</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">0.117</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> float_array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>hexfloat <span class="token operator">&lt;&lt;</span> elem 
			<span class="token operator">&lt;&lt;</span> <span class="token string">" = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>defaultfloat <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码分别使用<code>std::hexfloat</code>和<code>std::defaultfloat</code>格式化输出了数组<code>x</code>里的元素，输出结果如下：</p> 
<pre><code class="prism language-cpp"><span class="token number">0x1.780000p+2</span> <span class="token operator">=</span> <span class="token number">5.875</span>
<span class="token number">0x1.f40000p+9</span> <span class="token operator">=</span> <span class="token number">1000</span>
<span class="token number">0x1.df3b64p-4</span> <span class="token operator">=</span> <span class="token number">0.117</span>
</code></pre> 
<p>这里有必要简单说明一下十六进制浮点数的表示方法，以 <code>0x1.f40000p+9</code>为例：其中 <code>0x1.f4</code>是一个十六进制的有效数， <code>p+9</code>是一个以<code>2</code>为底数，<code>9</code>为指数的幂。其中底数一定为<code>2</code>，指数使用的是十进制。也就是说 <code>0x1.f40000p+9</code>可以表示为： <code>0x1.f4 * 2^9</code>。</p> 
<p>虽然<code>C++11</code>已经具备了在输入输出的时候将浮点数格式化为十六进制的能力，但遗憾的是我们并不能在源代码中使用十六进制浮点字面量来表示一个浮点数。幸运的是，这个问题在<code>C++17</code>标准中得到了解决：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">double</span> float_array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token number">0x1.7p+2</span><span class="token punctuation">,</span> <span class="token number">0x1.f4p+9</span><span class="token punctuation">,</span> <span class="token number">0x1.df3b64p-4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> float_array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>hexfloat <span class="token operator">&lt;&lt;</span> elem 
			<span class="token operator">&lt;&lt;</span> <span class="token string">" = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>defaultfloat <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用十六进制浮点字面量的优势显而易见，它可以更加精准地表示浮点数。例如，<code>IEEE-754</code>标准最小的单精度值很容易写为<code>0x1.0p−126</code>。当然了，十六进制浮点字面量的劣势也很明显，它不便于代码的阅读理解。总之，我们在<code>C++17</code>中可以根据实际需求选择浮点数的表示方法，当需要精确表示某个浮点数的时候可以采用十六进制浮点字面量，其他情况使用十进制浮点字面量即可。</p> 
<h3><a id="2__1906"></a>2. 二进制整数字面量</h3> 
<p>在<code>C++14</code>标准中定义了二进制整数字面量，正如十六进制（<code>0x</code>，<code>0X</code>）和八进制（<code>0</code>）都有固定前缀一样，二进制整数字面量也有前缀<code>0b</code>和<code>0B</code>。实际上<code>GCC</code>的扩展早已支持了二进制整数字面量，只不过到了<code>C++14</code>才作为标准引入：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">0b11001101L</span> <span class="token operator">+</span> <span class="token number">0xcdl</span> <span class="token operator">+</span> <span class="token number">077LL</span> <span class="token operator">+</span> <span class="token number">42</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", sizeof(x) = "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre> 
<p>除了添加二进制整数字面量以外，C++14标准还增加了一个用单引号作为整数分隔符的特性，目的是让比较长的整数阅读起来更加容易。单引号整数分隔符对于十进制、八进制、十六进制、二进制整数都是有效的，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">123'456</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0x1e'240</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">036'11'00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0b11'110'001'001'000'000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>值得注意的是，由于单引号在过去有用于界定字符的功能，因此这种改变可能会引起一些代码的兼容性问题，比如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">M</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> …<span class="token punctuation">)</span> __VA_ARGS__</span></span>

<span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token number">1'2</span><span class="token punctuation">,</span><span class="token number">3'4</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x[0] = "</span><span class="token operator">&lt;&lt;</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", x[1] = "</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码在C++11和C++14标准下编译运行的结果不同，在C++11标准下输出结果为<code>x[0] = 0, x[1] = 0</code>，而在C++14标准下输出结果为<code>x[0] = 34, x[1] = 0</code>。这个现象很容易解释，在C++11中<code>1'2,3'4</code>是一个参数，所以<code>__VA_ARGS__</code>为空，而在C++14中它是两个参数<code>12</code>和<code>34</code>，所以<code>__VA_ARGS__</code>为<code>34</code>。虽然会引起一点兼容性问题，但是读者不必过于担心，上面这种代码很少会出现在真实的项目中，大部分情况下我们还是可以放心地将编程环境升级到C++14或者更高标准的，只不过如果真的出现了编译错误，不妨留意一下是不是这个问题造成的。</p> 
<h3><a id="4__1938"></a>4. 原生字符串字面量</h3> 
<p>过去想在C++中嵌入一段带格式和特殊符号的字符串是一件非常令人头痛的事情，比如在程序中嵌入一份HTML代码，我们不得不写成这样：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> hello_world_html<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token string">"&lt;!DOCTYPE html&gt;\r\n"</span>
<span class="token string">"&lt;html lang = \"en\"&gt;\r\n"</span>
<span class="token string">" &lt;head&gt;\r\n"</span>
<span class="token string">" &lt;meta charset = \"utf-8\"&gt;\r\n"</span>
<span class="token string">" &lt;meta name = \"viewport\" content = \"width=device-width, initialscale=1, user-scalable=yes\"&gt;\r\n"</span>
<span class="token string">" &lt;title&gt;Hello World!&lt;/title&gt;\r\n"</span>
<span class="token string">" &lt;/head&gt;\r\n"</span>
<span class="token string">" &lt;body&gt;\r\n"</span>
<span class="token string">" Hello World!\r\n"</span>
<span class="token string">" &lt;/body&gt;\r\n"</span>
<span class="token string">"&lt;/html&gt;\r\n"</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以看到上面代码里的字符串非常难以阅读和维护，这是因为它包含的大量转义字符影响了阅读的流畅性。为了解决这种问题，<code>C++11</code>标准引入原生字符串字面量的概念。</p> 
<p>原生字符串字面量并不是一个新的概念，比如在<code>Python</code>中已经支持在字符串之前加<code>R</code>来声明原生字符串字面量了。使用原生字符串字面量的代码会在编译的时候被编译器直接使用，也就是说保留了字符串里的格式和特殊字符，同时它也会忽略转移字符，概括起来就是所见即所得。</p> 
<p>声明原生字符串字面量的语法很简单，即<code>prefix R"delimiter(raw_characters)delimiter"</code>，这其中<code>prefix</code>和<code>delimiter</code>是可选部分，我们可以忽略它们，所以最简单的原生字符串字面量声明是<code>R"(raw_characters)"</code>。以上面的HTML字符串为例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> hello_world_html<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token raw-string string">R"(&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="utf-8"&gt;
	&lt;meta name="viewport" content="width=device-width, initial-scale=1,
user-scalable=yes"&gt;
	&lt;title&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
Hello World!
&lt;/body&gt;
&lt;/html&gt;
)"</span><span class="token punctuation">;</span>
</code></pre> 
<p>从上面的代码可以看到，原生字符串中不需要<code>\r\n</code>，也不需要对引号使用转义字符，编译后字符串的内容和格式与代码里的一模一样。读者在这里可能会有一个疑问，如果在声明的字符串内部有一个字符组合正好是<code>)"</code>，这样原生字符串不就会被截断了吗？没错，如果出现这样的情况，编译会出错。不过，我们也不必担心这种情况，C++11标准已经考虑到了这个问题，所以有了<code>delimiter</code>（分隔符）这个元素。<code>delimiter</code>可以是由除括号、反斜杠和空格以外的任何源字符构成的字符序列，长度至多为16个字符。通过添加<code>delimiter</code>可以改变编译器对原生字符串字面量范围的判定，从而顺利编译带有<code>)"</code>的字符串，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> hello_world_html<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token raw-string string">R"cpp(&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="utf-8"&gt;
	&lt;meta name="viewport" content="width=device-width, initial-scale=1,
	user-scalable=yes"&gt;
	&lt;title&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
"(Hello World!)"
&lt; / body &gt;
&lt; / html&gt;
)cpp"</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中，字符串虽然包含<code>"(Hello World!)"</code>这个比较特殊的子字符串，但是因为我们添加了<code>cpp</code>这个分隔符，所以编译器能正确地获取字符串的真实范围，从而顺利地通过编译。</p> 
<p>C++11标准除了让我们能够定义<code>char</code>类型的原生字符串字面量外，对于<code>wchar_t</code>、<code>char8_t</code>（C++20标准开始）、<code>char16_t</code>和<code>char32_t</code>类型的原生字符串字面量也有支持。要支持这4种字符类型，就需要用到另外一个可选元素<code>prefix</code>了。这里的<code>prefix</code>实际上是声明4个类型字符串的前缀<code>L</code>、<code>u</code>、<code>U</code>和<code>u8</code>。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char8_t</span> utf8<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token raw-string string">R"(你好世界)"</span><span class="token punctuation">;</span> <span class="token comment">// C++20标准开始</span>
<span class="token keyword">char16_t</span> utf16<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token raw-string string">R"(你好世界)"</span><span class="token punctuation">;</span>
<span class="token keyword">char32_t</span> utf32<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> U<span class="token raw-string string">R"(你好世界)"</span><span class="token punctuation">;</span>
<span class="token keyword">wchar_t</span> wstr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token raw-string string">R"(你好世界)"</span><span class="token punctuation">;</span>
</code></pre> 
<p>最后，关于原生字符串字面量的连接规则实际上和普通字符串字面量是一样的，唯一需要注意的是，原生字符串字面量除了能连接原生字符串字面量以外，还能连接普通字符串字面量。</p> 
<h3><a id="5__2007"></a>5. 用户自定义字面量</h3> 
<p>在<code>C++11</code>标准中新引入了一个用户自定义字面量的概念，程序员可以通过自定义后缀将整数、浮点数、字符和字符串转化为特定的对象。这个特性往往用在需要大量声明某个类型对象的场景中，它能够减少一些重复类型的书写，避免代码冗余。一个典型的例子就是不同单位对象的互相操作，比如长度、重量、时间等，举个例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> scale<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> unit_char<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">LengthUnit</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">constexpr</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> scale<span class="token punctuation">;</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">static</span> <span class="token keyword">char</span> unit_str<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>unit_char<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> unit_char<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token char">'\0'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">LengthWithUnit</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">LengthWithUnit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">length_unit_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">LengthWithUnit</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> length<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">length_unit_</span><span class="token punctuation">(</span>length <span class="token operator">*</span> T<span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
	LengthWithUnit<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>conditional_t<span class="token operator">&lt;</span><span class="token punctuation">(</span>T<span class="token double-colon punctuation">::</span>value <span class="token operator">&gt;</span> U<span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> U<span class="token punctuation">,</span> T<span class="token operator">&gt;&gt;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> LengthWithUnit<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">using</span> unit_type <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>conditional_t<span class="token operator">&lt;</span><span class="token punctuation">(</span>T<span class="token double-colon punctuation">::</span>value <span class="token operator">&gt;</span> U<span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> U<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token generic-function"><span class="token function">LengthWithUnit</span><span class="token generic class-name"><span class="token operator">&lt;</span>unit_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>length_unit_ <span class="token operator">+</span> rhs<span class="token punctuation">.</span><span class="token function">get_length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> unit_type<span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">get_length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> length_unit_<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">get_unit_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> T<span class="token double-colon punctuation">::</span>unit_str<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> length_unit_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> out<span class="token punctuation">,</span> <span class="token keyword">const</span> LengthWithUnit<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>unit<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	out <span class="token operator">&lt;&lt;</span> unit<span class="token punctuation">.</span><span class="token function">get_length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> T<span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> <span class="token class-name">LengthWithUnit</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">get_unit_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">using</span> MMUnit <span class="token operator">=</span> LengthUnit<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> CMUnit <span class="token operator">=</span> LengthUnit<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> DMUnit <span class="token operator">=</span> LengthUnit<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> MUnit <span class="token operator">=</span> LengthUnit<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> KMUnit <span class="token operator">=</span> LengthUnit<span class="token operator">&lt;</span><span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token char">'k'</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">using</span> LengthWithMMUnit <span class="token operator">=</span> LengthWithUnit<span class="token operator">&lt;</span>MMUnit<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> LengthWithCMUnit <span class="token operator">=</span> LengthWithUnit<span class="token operator">&lt;</span>CMUnit<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> LengthWithDMUnit <span class="token operator">=</span> LengthWithUnit<span class="token operator">&lt;</span>DMUnit<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> LengthWithMUnit <span class="token operator">=</span> LengthWithUnit<span class="token operator">&lt;</span>MUnit<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> LengthWithKMUnit <span class="token operator">=</span> LengthWithUnit<span class="token operator">&lt;</span>KMUnit<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> total_length <span class="token operator">=</span> <span class="token function">LengthWithCMUnit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">LengthWithMUnit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">LengthWithMMUnit</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> total_length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码定义了两个类模板，一个是长度单位<code>LengthUnit</code>，另外一个是带单位的长度<code>LengthWithUnit</code>，然后基于这两个类模板生成了毫米、厘米、分米、米和千米单位类以及它们对应的带单位的长度类。为了不同单位的数据相加，我们在类模板<code>LengthWithUnit</code>中重载了加号运算符，函数中总是会将较大的单位转换到较小的单位进行求和，比如千米和厘米相加得到的结果单位为厘米。最后，我们在<code>main</code>函数中对不同单位的对象求和并且输出求和结果。类模板的编写用到了一些模板元编程的知识，我们暂时可以忽略它们，现在需要关注的是<code>main</code>函数里的代码。我们发现每增加一个求和的操作数就需要重复写一个类型<code>LengthWithXXUnit</code>，当操作数很多的时候代码会变得很长，难以阅读和维护。当遇到这种情况的时候，我们可以考虑使用用户自定义字面量来简化代码，比如：</p> 
<pre><code class="prism language-cpp">LengthWithMMUnit <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_mm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> length<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">LengthWithMMUnit</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

LengthWithCMUnit <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_cm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> length<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">LengthWithCMUnit</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

LengthWithDMUnit <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_dm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> length<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">LengthWithDMUnit</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

LengthWithMUnit <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_m</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> length<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">LengthWithMUnit</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

LengthWithKMUnit <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_km</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> length<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">LengthWithKMUnit</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> total_length <span class="token operator">=</span> <span class="token number">1</span>_cm <span class="token operator">+</span> <span class="token number">2</span>_m <span class="token operator">+</span> <span class="token number">4</span>_mm<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> total_length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码定义了5个字面量运算符函数，这些函数返回不同单位的长度对象，分别对应于毫米、厘米、分米、米和千米。字面量运算符函数的函数名会作为后缀应用于字面量。在<code>main</code>函数中，我们可以看到现在的代码省略了<code>LengthWithXXUnit</code>的类型声明，取而代之的是一个整型的字面量紧跟着一个以下画线开头的后缀 <code>_cm</code>、<code>_m</code> 或者 <code>_mm</code>。在这里编译器会根据字面量的后缀去查找对应的字面量运算符函数，并根据函数形式对字面量做相应处理后调用该函数，如果编译器没有找到任何对应的函数，则会报错。所以这里的 <code>1_cm</code>、<code>2_m</code> 和 <code>4_mm</code> 分别等于调用了 <code>LengthWithCMUnit(1)</code>、<code>LengthWithMUnit(2)</code> 和 <code>LengthWithMMUnit(4)</code>。</p> 
<p>接下来让我们看一看字面量运算符函数的语法规则，字面量运算符函数的语法和其他运算符函数一样都是由返回类型、<code>operator</code>关键字、标识符以及函数形参组成的：</p> 
<pre><code class="prism language-cpp">retrun_type <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">identifier</span> <span class="token punctuation">(</span>params<span class="token punctuation">)</span>
</code></pre> 
<p>值得注意的是在<code>C++11</code>的标准中，双引号和紧跟的标识符中间必须有空格，不过这个规则在<code>C++14</code>标准中被去除。在<code>C++14</code>标准中，标识符不但可以紧跟在双引号后，而且还能使用<code>C++</code>的保留字作为标识符。标准中还建议用户定义的字面量运算符函数的标识符应该以下画线开始，把没有下画线开始的标识符保留给标准库使用。虽然标准并没有强制规定自定义的字面量运算符函数标识符必须以下画线开始，但是我们还是应该尽量遵循标准的建议。这一点编译器也会提示我们，如果使用了非下画线开始的标识符，它会给出明确的警告信息。</p> 
<p>上文曾提到，用户自定义字面量支持整数、浮点数、字符和字符串4种类型。虽然它们都通过字面量运算符函数来定义，但是对于不同的类型字面量运算符函数，语法在参数上有略微的区别。</p> 
<p>对于整数字面量运算符函数有3种不同的形参类型<code>unsigned long long</code>、<code>const char *</code>以及形参为空。其中<code>unsigned long long</code>和<code>const char *</code>比较简单，编译器会将整数字面量转换为对应的无符号<code>long long</code>类型或者常量字符串类型，然后将其作为参数传递给运算符函数。而对于无参数的情况则使用了模板参数，形如<code>operator "" identifier&lt;char...c&gt;()</code>，这个稍微复杂一些，我们在后面的例子中详细介绍。</p> 
<p>对于浮点数字面量运算符函数也有3种形参类型<code>long double</code>、<code>const char *</code>以及形参为空。和整数字面量运算符函数相比，除了将<code>unsigned long long</code>换成了<code>long double</code>，没有其他的区别。</p> 
<p>对于字符串字面量运算符函数目前只有一种形参类型列表<code>const char * str, size_t len</code>。其中<code>str</code>为字符串字面量的具体内容，<code>len</code>是字符串字面量的长度。</p> 
<p>对于字符字面量运算符函数也只有一种形参类型<code>char</code>，参数内容为字符字面量本身：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_w1</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_w2</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_w3</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>string <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_w4</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_w5</span><span class="token punctuation">(</span><span class="token keyword">char</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">operator</span> <span class="token string">""</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token number">123</span>_w1<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> x2_1 <span class="token operator">=</span> <span class="token number">123</span>_w2<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> x2_2 <span class="token operator">=</span> <span class="token number">12.3</span>_w2<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token number">12.3</span>_w3<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> x4 <span class="token operator">=</span> <span class="token string">"hello world"</span>_w4<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token char">'a'</span>_w5<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> x6 <span class="token operator">=</span> <span class="token number">123</span>if<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，根据字面量运算符函数的语法规则，后缀 <code>_w1</code> 和 <code>_w2</code> 可以用于整数，后缀 <code>_w3</code> 和 <code>_w2</code> 可以用于浮点数，而 <code>_w4</code> 和 <code>_w5</code> 分别用于字符串和字符。请注意最后一个 <code>if</code> 后缀，它必须用支持<code>C++14</code>标准的编译器才能编译成功。这个后缀有两点比较特殊，首先它使用保留关键字 <code>if</code> 作为后缀，其次它没有用下画线开头。前者能够这么做是因为<code>C++14</code>标准中字面量运算符函数双引号后紧跟的标识符允许使用保留字，而对于后者支持<code>C++11</code>标准的编译器通常允许这么做，只是会给出警告。</p> 
<p>最后来看一下字面量运算符函数使用模板参数的情况，在这种情况下函数本身没有任何形参，字面量的内容通过可变模板参数列表 <code>&lt;char...&gt;</code> 传到函数</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> c<span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_w</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">123</span>_w<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> y <span class="token operator">=</span> <span class="token number">12.3</span>_w<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面这段代码展示了一个使用可变参数模板的字面量运算符函数，该函数通过声明数组展开参数包的技巧将<code>char</code>类型的模板参数 <code>push_back</code> 到 <code>str</code> 中。实际上，通常情况下很少会用到这种形式的字面量运算符函数，从易用性和可读性的角度来说它都不是一个好的选择，所以我建议还是采用上面提到的那些带有形参的字面量运算符函数。</p> 
<h2><a id="alignasalignofC11_C17_2188"></a>三十、alignas和alignof（C++11 C++17）</h2> 
<h3><a id="1__2189"></a>1. 不可忽视的数据对齐问题</h3> 
<p><code>C++11</code>中新增了<code>alignof</code>和<code>alignas</code>两个关键字，其中<code>alignof</code>运算符可以用于获取类型的对齐字节长度，<code>alignas</code>说明符可以用来改变类型的默认对齐字节长度。这两个关键字的出现解决了长期以来<code>C++</code>标准中无法对数据对齐进行处理的问题。</p> 
<p>在详细介绍这两个关键字之前，我们先来看一看下面这段代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a1<span class="token punctuation">;</span>
	<span class="token keyword">int</span> a2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> a3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">short</span> b1<span class="token punctuation">;</span>
	<span class="token keyword">bool</span> b2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> b3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(A::a1) + sizeof(A::a2) + sizeof(A::a3) = "</span> 
		<span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span>a1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span>a2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span>a3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(B::b1) + sizeof(B::b2) + sizeof(B::b3) = "</span> 
		<span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token double-colon punctuation">::</span>b1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token double-colon punctuation">::</span>b2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token double-colon punctuation">::</span>b3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(A) = "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(B) = "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译运行这段代码会得到以下结果：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span>a1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span>a2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span>a3<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">13</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token double-colon punctuation">::</span>b1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token double-colon punctuation">::</span>b2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token double-colon punctuation">::</span>b3<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">11</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span>
</code></pre> 
<p>奇怪的事情发生了，<code>A</code> 和 <code>B</code> 两个类的成员变量的数据长度之和分别为13字节和11字节，与它们本身的数据长度16字节不同。对比这两个类，它们在成员变量数据长度之和上明明不同，却在类整体数据长度上相同。有经验的程序员应该一眼就能看出其中的原因。实际上，一个类型的属性除了其数据长度，还有一个重要的属性——数据对齐的字节长度。</p> 
<p>在上面的代码中，<code>char</code> 以1字节对齐，<code>short</code> 以2字节对齐，<code>int</code> 以4字节对齐，<code>double</code> 以8字节对齐，所以它们的实际数据结构应该是这样的：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a1<span class="token punctuation">;</span>
	<span class="token keyword">char</span> a1_pad<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> a2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> a3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>内存布局如表所示。</p> 
<p><img src="https://images2.imgbox.com/a9/30/cJ3U7QxD_o.png" alt="在这里插入图片描述" width="600"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">short</span> b1<span class="token punctuation">;</span>
	<span class="token keyword">bool</span> b2<span class="token punctuation">;</span>
	<span class="token keyword">char</span> b2_pad<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> b3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>内存布局如表所示。</p> 
<p><img src="https://images2.imgbox.com/69/68/b1xCYfEV_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>通过上述示例应该能够对数据对齐有比较直观的理解了。但是为什么我们需要数据对齐呢？原因说起来很简单，就是硬件需要。首当其冲的就是CPU了，CPU对数据对齐有着迫切的需求，一个好的对齐字节长度可以让CPU运行起来更加轻松快速。反过来说，不好的对齐字节长度则会让CPU运行速度减慢，甚至抛出错误。通常来说所谓好的对齐长度和CPU访问数据总线的宽度有关系，比如CPU访问32位宽度的数据总线，就会期待数据是按照32位对齐，也就是4字节。这样CPU读取4字节的数据只需要对总线访问一次，但是如果要访问的数据并没有按照4字节对齐，那么CPU需要访问数据总线两次，运算速度自然也就减慢了。另外，对于数据对齐问题引发错误的情况（Alignment Fault），通常会发生在ARM架构的计算机上。当然除了CPU之外，还有其他硬件也需要数据对齐，比如通过DMA访问硬盘，就会要求内存必须是4K对齐的。总的来说，配合现代编译器和CPU架构，可以让程序获得令人难以置信的性能，但这种良好的性能取决于某些编程实践，其中一种编程实践是正确的数据对齐。</p> 
<h3><a id="2_C11_2262"></a>2. C++11标准之前控制数据对齐的方法</h3> 
<p>在<code>C++11</code>标准之前我们没有一个标准方法来设定数据的对齐字节长度，只能依靠一些编程技巧和各种编译器自身提供的扩展功能来达到这一目的。</p> 
<p>首先让我们来看一看如何获得类型的对齐字节长度。在<code>alignof</code>运算符被引入之前，程序员常用<code>offsetof</code>来间接实现<code>alignof</code>的功能，其中一种实现方法如下：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ALIGNOF</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">,</span> result<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">struct</span> <span class="token class-name">type</span></span><span class="token punctuation">##</span><span class="token expression">_alignof_trick<span class="token punctuation">{<!-- --></span> <span class="token keyword">char</span> c<span class="token punctuation">;</span> type member<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
	<span class="token expression">result <span class="token operator">=</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>type</span><span class="token punctuation">##</span><span class="token expression">_alignof_trick<span class="token punctuation">,</span> member<span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">ALIGNOF</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> x1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码用宏定义了一个结构体，其中用<code>type</code>定义了成员变量<code>member</code>，然后用<code>offsetof</code>获取<code>member</code>的偏移量，从而获取指定类型的对齐字节长度。该方法运用在大部分类型上没有问题，不过还是有些例外，比如函数指针类型：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">ALIGNOF</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 无法编译通过</span>
</code></pre> 
<p>当然了，我们可以用<code>typedef</code>来解决这个问题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">ALIGNOF</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> x1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>实际上我们还有第二种更好的方案：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">alignof_trick</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">char</span> c<span class="token punctuation">;</span> T member<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ALIGNOF</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>alignof_trick<span class="token operator">&lt;</span>type<span class="token operator">&gt;</span><span class="token punctuation">,</span> member<span class="token punctuation">)</span></span></span>

<span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token function">ALIGNOF</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token function">ALIGNOF</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面的代码利用模板来构造结构体，这一点显然优于用宏构造。因为它不仅可以处理函数指针类型，还能够在表达式中构造结构体，从而让 <code>ALIGNOF</code> 写在表达式当中，这也让它更接近 <code>alignof</code> 运算符的用法。</p> 
<p>除用一些小技巧获取类型对齐字节长度之外，很多编译器还提供了一些扩展方法帮助我们获得类型的对齐字节长度，以MSVC和GCC为例，它们分别可以通过扩展关键字 <code>__alignof</code> 和 <code>__alignof__</code> 来获取数据类型的对齐字节长度：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// MSVC</span>
<span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token function">__alignof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token function">__alignof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// GCC</span>
<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token function">__alignof__</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x4 <span class="token operator">=</span> <span class="token function">__alignof__</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>相对于获取数据对齐的功能而言，设置数据对齐就没那么幸运了，在<code>C++11</code>之前，我们不得不依赖编译器给我们提供的扩展功能来设置数据对齐。幸好很多编译器也提供了这样的功能，还是以MSVC和GCC为例：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// MSVC</span>
<span class="token keyword">short</span> x1<span class="token punctuation">;</span>
<span class="token function">__declspec</span><span class="token punctuation">(</span><span class="token function">align</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">short</span> x2<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x1 = "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">__alignof</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x2 = "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">__alignof</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token comment">// GCC</span>
<span class="token keyword">short</span> x3<span class="token punctuation">;</span>
<span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">short</span> x4<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x3 = "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">__alignof__</span><span class="token punctuation">(</span>x3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x4 = "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">__alignof__</span><span class="token punctuation">(</span>x4<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre> 
<p>上面的代码输出结果如下：</p> 
<pre><code class="prism language-cpp">x1 <span class="token operator">=</span> <span class="token number">2</span>
x2 <span class="token operator">=</span> <span class="token number">8</span>
x3 <span class="token operator">=</span> <span class="token number">2</span>
x4 <span class="token operator">=</span> <span class="token number">8</span>
</code></pre> 
<p><code>__declspec(align(8))</code> 和 <code>__attribute__((aligned(8)))</code> 分别将 <code>x2</code> 和 <code>x4</code> 两个 <code>short</code> 类型的对齐长度从2字节扩展到8字节。</p> 
<p>不同的编译器需要采用不同的扩展功能来控制类型的对齐字节长度，这一点对于程序员来说很不友好。所以C++标准委员在<code>C++11</code>标准中新增了<code>alignof</code> 和 <code>alignas</code> 两个关键字。</p> 
<h3><a id="3__alignof__2339"></a>3. 使用 alignof 运算符</h3> 
<p><code>alignof</code> 运算符和我们前面提到的编译器扩展关键字 <code>__alignof</code>、<code>__alignof__</code> 用法相同，都是获得类型的对齐字节长度，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// *C++标准不支持这种用法</span>
</code></pre> 
<p>请注意上面的第4句代码，<code>alignof</code> 的计算对象并不是一个类型，而是一个变量。但是C++标准规定 <code>alignof</code> 必须是针对类型的。不过GCC扩展了这条规则，<code>alignof</code> 除了能接受一个类型外还能接受一个变量，用GCC编译此段代码是可以编译通过的。阅读了第4章的读者可能会想到，我们只需要结合 <code>decltype</code>，就能够扩展出类似这样的功能：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>但实际情况是，这种做法只有在类型使用默认对齐的时候才是正确的，如果用在下面的情况中会产生错误的结果：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误的返回4，而并非设置的8</span>
</code></pre> 
<p>使用MSVC的读者如果想获得变量的对齐，不妨使用编译器的扩展关键字<code>__alignof</code>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token function">__alignof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回8</span>
</code></pre> 
<p>另外，我们还可以通过 <code>alignof</code> 获得类型 <code>std::max_align_t</code> 的对齐字节长度，这是一个非常重要的值。<code>C++11</code>定义了 <code>std::max_align_t</code>，它是一个平凡的标准布局类型，其对齐字节长度要求至少与每个标量类型一样严格。也就是说，所有的标量类型都适应 <code>std::max_align_t</code> 的对齐字节长度。<code>C++</code>标准还规定，诸如 <code>new</code> 和 <code>malloc</code> 之类的分配函数返回的指针需要适合于任何对象，也就是说内存地址至少与 <code>std::max_align_t</code> 严格对齐。由于 <code>C++</code>标准并没有定义 <code>std::max_align_t</code> 对齐字节长度具体是什么样的，因此不同的平台会有不同的值，通常情况下是8字节和16字节。下面做一个小实验来验证一下刚刚的说法：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> addr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>uintptr_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> addr <span class="token operator">%</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>max_align_t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译运行以上代码，会发现输出的都是<code>0</code>，也就是说即使我们分配的是<code>1</code>字节的内存，内存分配器也会将指针定位到与 <code>std::max_align_t</code> 对齐的地方。如果我们有自定义内存分配器的需要，请务必考虑到这个细节。</p> 
<h3><a id="4__alignas__2382"></a>4. 使用 alignas 说明符</h3> 
<p>接下来看一看 <code>alignas</code> 说明符的用法，该说明符可以接受类型或者常量表达式。特别需要注意的是，该常量表达式计算的结果必须是一个2的幂值，否则是无法通过编译的。具体用法如下（这里采用GCC编译器，因为其 <code>alignof</code> 可以查看变量的对齐字节长度）：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a1<span class="token punctuation">;</span>
	<span class="token keyword">int</span> a2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> a3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">X1</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token keyword">char</span> a1<span class="token punctuation">;</span>
	<span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token keyword">int</span> a2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> a3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> X2
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a1<span class="token punctuation">;</span>
	<span class="token keyword">int</span> a2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> a3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> X3
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">char</span> a1<span class="token punctuation">;</span>
	<span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token keyword">int</span> a2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> a3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> X4
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">char</span> a1<span class="token punctuation">;</span>
	<span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token keyword">int</span> a2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> a3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">COUT_ALIGN</span><span class="token expression"><span class="token punctuation">(</span>s<span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> </span><span class="token string">"alignof("</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">s</span> </span></span><span class="token string">") = "</span> <span class="token expression"><span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl</span></span>
	
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	X x<span class="token punctuation">;</span>
	X1 x1<span class="token punctuation">;</span>
	X2 x2<span class="token punctuation">;</span>
	X3 x3<span class="token punctuation">;</span>
	X4 x4<span class="token punctuation">;</span>
	<span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> X3 x5<span class="token punctuation">;</span>
	<span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> X4 x6<span class="token punctuation">;</span>

	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x4<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x5<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x6<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x5<span class="token punctuation">.</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x6<span class="token punctuation">.</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出结果如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">alignof</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8</span>
<span class="token keyword">alignof</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span>
<span class="token keyword">alignof</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span>
<span class="token keyword">alignof</span><span class="token punctuation">(</span>x3<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span>
<span class="token keyword">alignof</span><span class="token punctuation">(</span>x4<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8</span>
<span class="token keyword">alignof</span><span class="token punctuation">(</span>x5<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">4</span>
<span class="token keyword">alignof</span><span class="token punctuation">(</span>x6<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span>
<span class="token keyword">alignof</span><span class="token punctuation">(</span>x5<span class="token punctuation">.</span>a1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8</span>
<span class="token keyword">alignof</span><span class="token punctuation">(</span>x6<span class="token punctuation">.</span>a1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8</span>
</code></pre> 
<p>从上面的代码可以看出，<code>alignas</code> 的使用非常灵活，例子中它既可以用于结构体，也可以用于结构体的成员变量。如果将 <code>alignas</code> 用于结构体类型，那么该结构体整体就会以 <code>alignas</code> 声明的对齐字节长度进行对齐，比如在例子中，<code>X</code> 的类型对齐字节长度为8字节，而 <code>X2</code> 在使用了 <code>alignas(16)</code> 之后，对齐字节长度修改为了16字节。另外，如果修改结构体成员的对齐字节长度，那么结构体本身的对齐字节长度也会发生变化，因为结构体类型的对齐字节长度总是需要大于或者等于其成员变量类型的对齐字节长度。比如 <code>X1</code> 的成员变量 <code>a1</code> 类型的对齐字节长度修改为了16字节，所有 <code>X1</code> 类型也被修改为16字节对齐。同样的规则也适用于结构体 <code>X3</code>，<code>X3</code> 类型的对齐字节长度被指定为16字节，虽然其成员变量 <code>a1</code> 的类型对齐字节长度被指定为8字节，但是并不能改变 <code>X3</code> 类型的对齐字节长度。<code>X4</code> 就恰恰相反，由于 <code>X4</code> 指定的对齐字节长度为4字节，明显小于其成员变量类型需要的对齐字节长度的字节数，因此这里 <code>X4</code> 的 <code>alignas(4)</code> 会被忽略。最后要说明的是，结构体类型的对齐字节长度，并不能影响声明变量时变量的对齐字节长度，比如 <code>X5</code>、<code>X6</code>。不过在变量声明时指定对齐字节长度，也不影响变量内部成员变量类型的对齐字节长度，比如 <code>x5.a1</code>、<code>x6.a1</code>。上面的代码用结构体作为例子，实际上对于类也是一样的。</p> 
<h3><a id="5__2462"></a>5. 其他关于对齐字节长度的支持</h3> 
<p><code>C++11</code>标准除了提供了关键字<code>alignof</code>和<code>alignas</code>来支持对齐字节长度的控制以外，还提供了<code>std::alignment_of</code>、<code>std::aligned_storage</code>和<code>std::aligned_union</code>类模板型以及<code>std::align</code>函数模板来支持对于对齐字节长度的控制。</p> 
<p>下面简单地介绍一下它们的用法。<code>std::alignment_of</code>和<code>alignof</code>的功能差不多，可以获取类型的对齐字节长度，例如：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>alignment_of<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出4</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">alignment_of</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出4</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>alignment_of<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出8</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">alignment_of</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出8</span>
</code></pre> 
<p><code>std::aligned_storage</code>可以用来分配一块指定对齐字节长度和大小的内存，例如：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>aligned_storage<span class="token operator">&lt;</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type buffer<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 内存大小指定为128字节</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 对齐字节长度指定为16字节</span>
</code></pre> 
<p><code>std::aligned_union</code>接受一个<code>std::size_t</code>作为分配内存的大小，以及不定数量的类型。<code>std::aligned_union</code>会获取这些类型中对齐字节长度最严格的（对齐字节数最大）作为分配内存的对齐字节长度，例如：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>aligned_union<span class="token operator">&lt;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type buffer<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 内存大小指定为64字节</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 对齐字节长度自动选择为 double，8字节对齐</span>
</code></pre> 
<p>最后解释一下<code>std::align</code>函数模板，该函数接受一个指定大小的缓冲区空间的指针和一个对齐字节长度，返回一个该缓冲区中最近的能找到符合指定对齐字节长度的指针。通常来说，我们传入的缓冲区内存大小为预分配的缓冲区大小加上预指定对齐字节长度的字节数。下面会给出一个例子详解这个函数模板的用法，这个例子不仅说明了函数的用法，更重要的是，它证明了在CPU喜爱的对齐字节长度上做计算，CPU的工作效率会更高：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__movsb</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"rep movsb"</span>
                <span class="token operator">:</span> <span class="token string">"=D"</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span>
                  <span class="token string">"=S"</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>
                  <span class="token string">"=c"</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>
                <span class="token operator">:</span> <span class="token string">"0"</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span>
                  <span class="token string">"1"</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>
                  <span class="token string">"2"</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>
                <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> align_size <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> alloc_size <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span>
	<span class="token keyword">constexpr</span> <span class="token keyword">int</span> buff_size <span class="token operator">=</span> align_size <span class="token operator">+</span> alloc_size<span class="token punctuation">;</span>
	<span class="token keyword">char</span> dest<span class="token punctuation">[</span>buff_size<span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> src<span class="token punctuation">[</span>buff_size<span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>dest_ori_ptr <span class="token operator">=</span> dest<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>src_ori_ptr <span class="token operator">=</span> src<span class="token punctuation">;</span>
	size_t dest_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t src_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>dest_ptr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">align</span><span class="token punctuation">(</span>align_size<span class="token punctuation">,</span> alloc_size<span class="token punctuation">,</span> dest_ori_ptr<span class="token punctuation">,</span> dest_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>src_ptr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">align</span><span class="token punctuation">(</span>align_size<span class="token punctuation">,</span> alloc_size<span class="token punctuation">,</span> src_ori_ptr<span class="token punctuation">,</span> src_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>dest_ptr<span class="token punctuation">;</span>
		<span class="token operator">++</span>src_ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
	
	<span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">__movsb</span><span class="token punctuation">(</span>dest_ptr<span class="token punctuation">,</span> src_ptr<span class="token punctuation">,</span> alloc_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> diff <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"elapsed time = "</span> <span class="token operator">&lt;&lt;</span> diff<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码用汇编语言实现了一个<code>memcpy</code>函数以确保复制内存函数都是通过汇编指令<code>movsb</code>完成的。然后我们预先分配了两个<code>10001+32</code>字节大小的内存作为目标缓冲区和源缓冲区。此后通过<code>std::align</code>找到两个缓冲区中按照<code>32</code>字节对齐的指针，该指针指向的内存大小至少为<code>10001</code>字节。最后我们用自己实现的内存复制函数进行内存复制。如果运行的时候不带任何参数，则使用<code>32</code>字节对齐的内存进行复制，否则用<code>1</code>字节对齐的内存进行内存复制，复制动作重复<code>10000000</code>次。在<code>Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz</code>的机器上，两种方法的运行结果很有大差别：</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">.</span><span class="token operator">/</span>aligntest
elapsed time <span class="token operator">=</span> <span class="token number">0.951485</span>
<span class="token punctuation">.</span><span class="token operator">/</span>aligntest <span class="token number">1</span>
elapsed time <span class="token operator">=</span> <span class="token number">1.36937</span>
</code></pre> 
<p>可以看到，32字节对齐的缓冲区复制时间比1字节对齐的缓冲区复制时间整整少了0.4s有余。在性能优化上来说是非常巨大的提升。</p> 
<h3><a id="6_C17new_2547"></a>6. C++17中使用new分配指定对齐字节长度的对象</h3> 
<p>前面曾提到过内存分配器会按照<code>std::max_align_t</code>的对齐字节长度分配对象的内存空间。这一点在<code>C++17</code>标准中发生了改变，<code>new</code>运算符也拥有了根据对齐字节长度分配对象的能力。这个能力是通过让<code>new</code>运算符接受一个<code>std::align_val_t</code>类型的参数来获得分配对象需要的对齐字节长度来实现的：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>align_val_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>align_val_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>编译器会自动从类型对齐字节长度的属性中获取这个参数并且传参，不需要额外的代码介入。例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">union</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> X
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a1<span class="token punctuation">;</span>
	<span class="token keyword">int</span> a2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> a3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	X <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过GCC编译器将其编译为C++11和C++17两个版本，可以看到输出结果的区别：</p> 
<pre><code class="prism language-cpp">g<span class="token operator">++</span> <span class="token operator">-</span>std<span class="token operator">=</span>c<span class="token operator">++</span><span class="token number">11</span> test_new<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o cpp11
<span class="token punctuation">.</span><span class="token operator">/</span>cpp11
x <span class="token operator">=</span> <span class="token number">0x1071620</span>

g<span class="token operator">++</span> <span class="token operator">-</span>std<span class="token operator">=</span>c<span class="token operator">++</span><span class="token number">17</span> test_new<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o cpp17
<span class="token punctuation">.</span><span class="token operator">/</span>cpp17
x <span class="token operator">=</span> <span class="token number">0x1d1700</span>
</code></pre> 
<p>我们发现在使用<code>C++11</code>标准的情况下，<code>new</code>分配的对象指针（<code>0x1071620</code>）并没有按照<code>X</code>指定的对齐字节长度（<code>256</code>字节）对齐，而在使用<code>C++17</code>标准的情况下，<code>new</code>分配的对象指针（<code>0x1d1700</code>）正好为<code>X</code>指定的对齐字节长度。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f813a0fbb4d79faada3e5e0deb425bcf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">两步带你解决IDEA 插件下载安装慢、超时、不成功问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/319984890dfdbdc3290b6e8e8bafcdbb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pycharm下载安装详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>