<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HttpRunner使用中的一些问题记录 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HttpRunner使用中的一些问题记录" />
<meta property="og:description" content="背景：在了解接口自动化框架的过程中，看到有介绍说HttpRunner是一款不错的开源框架。所以，简单试用了一下。虽然有中文使用手册的帮助，但在结合自己项目接口的使用中还是遇到一些问题。在解决这些问题之后，也对这一框架的使用有了更深的了解。
环境：Python3.6 &#43; HttpRunner1.5.13 &#43; har2case 0.1.10
问题：
1. 录制脚本时，保存成 HAR 格式的文件。
1）使用Fiddler4抓包，并接口的请求和响应结果保存为 .har 格式的文件。选中接口，然后点击 Decode。
2）选择菜单栏中，File-》Export Sessions-》Selected Sessions，选择HTTPArchive v1.1类型。
3）保存文件类型如图所示。
2. 文件格式的转换。
上述步骤中保存的.har文件，需要转换成yaml或json文件。在文件所在目录，使用cmd，执行命令: har2case xx.har xx.json
3. 认识JSON文件。引用中文手册中的例子
[ { &#34;config&#34;: { &#34;name&#34;: &#34;testset description&#34;, &#34;variables&#34;: [], &#34;request&#34;: { &#34;base_url&#34;: &#34;&#34;, &#34;headers&#34;: { &#34;User-Agent&#34;: &#34;python-requests/2.18.4&#34; } } } }, { &#34;test&#34;: { &#34;name&#34;: &#34;/api/get-token&#34;, &#34;request&#34;: { &#34;url&#34;: &#34;http://127.0.0.1:5000/api/get-token&#34;, &#34;headers&#34;: { &#34;device_sn&#34;: &#34;FwgRiO7CNA50DSU&#34;, &#34;user_agent&#34;: &#34;iOS/10.3&#34;, &#34;os_platform&#34;: &#34;ios&#34;, &#34;app_version&#34;: &#34;2.8.6&#34;, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c6791b7f1e9914e39e74c7d3cfa20449/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-10T10:42:27+08:00" />
<meta property="article:modified_time" content="2018-10-10T10:42:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HttpRunner使用中的一些问题记录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>背景：</strong>在了解接口自动化框架的过程中，看到有介绍说HttpRunner是一款不错的开源框架。所以，简单试用了一下。虽然有中文使用手册的帮助，但在结合自己项目接口的使用中还是遇到一些问题。在解决这些问题之后，也对这一框架的使用有了更深的了解。</p> 
<p><strong>环境：</strong>Python3.6 + HttpRunner1.5.13 + har2case 0.1.10</p> 
<p><strong>问题：</strong></p> 
<p><u>1. 录制脚本时，保存成 HAR 格式的文件。</u></p> 
<p>1）使用Fiddler4抓包，并接口的请求和响应结果保存为 .har 格式的文件。选中接口，然后点击 Decode。</p> 
<p><img alt="" class="has" height="69" src="https://images2.imgbox.com/84/ca/xABwCkHP_o.png" width="647"></p> 
<p>2）选择菜单栏中，File-》Export Sessions-》Selected Sessions，选择HTTPArchive v1.1类型。</p> 
<p><img alt="" class="has" height="152" src="https://images2.imgbox.com/f3/b1/d12bb24j_o.png" width="390"></p> 
<p>3）保存文件类型如图所示。</p> 
<p><img alt="" class="has" height="62" src="https://images2.imgbox.com/04/57/lJUn8Boe_o.png" width="293"></p> 
<p><u>2. 文件格式的转换</u>。</p> 
<p>上述步骤中保存的.har文件，需要转换成yaml或json文件。在文件所在目录，使用cmd，执行命令: <strong>har2case xx.har xx.json</strong></p> 
<p><u>3. 认识JSON文件。引用中文手册中的例子</u></p> 
<pre class="has"><code class="language-html">[
  {
    "config": {
      "name": "testset description",
      "variables": [],
      "request": {
        "base_url": "",
        "headers": {
          "User-Agent": "python-requests/2.18.4"
        }
      }
    }
  },
  {
    "test": {
      "name": "/api/get-token",
      "request": {
        "url": "http://127.0.0.1:5000/api/get-token",
        "headers": {
          "device_sn": "FwgRiO7CNA50DSU",
          "user_agent": "iOS/10.3",
          "os_platform": "ios",
          "app_version": "2.8.6",
          "Content-Type": "application/json"
        },
        "method": "POST",
        "json": {"sign": "958a05393efef0ac7c0fb80a7eac45e24fd40c27"}
      },
      "validate": [
        {"eq": ["status_code", 200]},
        {"eq": ["headers.Content-Type", "application/json"]},
        {"eq": ["content.success", true]},
        {"eq": ["content.token", "baNLX1zhFYP11Seb"]}
      ]
    }
  }</code></pre> 
<p>]</p> 
<ul><li>test： 即一个用例</li><li>name：在report中显示的名称</li><li>request：包含请求的url，headers，method，body</li><li>validate：期望值，也就是要验证的值。根据这里的key，取出响应中的值与期望做比较。如，{"eq": ["status_code", 200]}。会取出响应中"status_code"的值，与200比较。</li></ul> 
<p><u>4.响应体中有数组，如何提取值。</u></p> 
<p>1）首先，在validate之前，request之后，添加提取响应体的代码格式如："extract": [{"变量名": "变量的取值路径"}]。如，"extract": [{"token": "content.token"}]</p> 
<p>2）项目中接口返回的层级结构是这样的：响应体-》res-》token(列表)。因此这里，需要这样写："extract": [{"token": "content.res.token.0"}]</p> 
<ul><li>content：响应体</li><li>res：响应体第一层</li><li>token：响应体第二层。且为一个列表</li><li>0：表示取该列表的第一元素</li></ul> 
<p><u>5.全局变量。</u>请求中有一些值是每个接口都要用到的，例如，ip，port，headers。因此可以提取出来作为全局变量，放在"config"中。</p> 
<pre class="has"><code class="language-html">{
    "config": {
      "name": "testset description",
      "variables": [],
      "request": {
        "base_url": "",
        "headers": {
          "User-Agent": "python-requests/2.18.4"
        }
      }
    }
 }</code></pre> 
<ul><li>base_url：存放ip,port等信息。</li><li>headers：存放共有的headers信息。</li></ul> 
<p>修改如下：</p> 
<pre class="has"><code class="language-html">{
    "config": {
      "name": "testset description",
      "variables": [],
      "request": {
        "base_url": "http://127.0.0.1:5000/api",
        "headers": {
          "User-Agent": "python-requests/2.18.4",   # 注意这里的 ，
          "Content-Type": "application/json;charset=UTF-8"
        }
      }
    }
 }</code></pre> 
<p>去掉用例中的相同部分。变为："request": { "url": "/get-token"...  , headers中的“Content-Type”去掉。</p> 
<p><u>6.关联变量。</u></p> 
<p>1）登录接口返回的token，在后面其他接口中都需要使用。除了在登录接口中提取外，还需要在其他接口中添加。这里token需要放到其他请求的headers中。因此在其他请求的request中添加如下公式：</p> 
<pre class="has"><code class="language-html">"request": {
        "url": "http://127.0.0.1:5000/api/get-token",
        "headers": {
          "x-auth-token": "$token"   #这里$为引用变量的意思，"token"即在登录接口中extract里定义的变量名
        }</code></pre> 
<p>2）从前面的请求中提取响应体中的值，作为下一个请求的输入。</p> 
<p>      a）提取值的部分与前面提取token相同。例如这里需要提取的变量为："extract":[{"<span style="color:#f33b45;">regionIds</span>": "content.res"}]。这里的res是一个列表，在下一个接口中，只需要该列表中的某一个元素。因此，需要格外增加判断。regionIds后面的接口会引用该变量。</p> 
<p>      b）HttpRunner中，支持“debugtalk.py”这样的热插拔。</p> 
<p>            i. 在用例，即JSON文件同级目录下，新建 debugtalk.py。</p> 
<p>            ii. 根据业务逻辑增加代码。如</p> 
<p>            SECRET_KEY = "DebugTalk"</p> 
<p>            def get_region_id(args):</p> 
<p>                   for i in range(len(args)):</p> 
<p>                        if "myRegion" == args[i]["regionName"]:    # 找到指定的regionName，然后获取其id</p> 
<p>                            regionId = args[i]["id"]</p> 
<p>                            return regionId</p> 
<p>       c）在下一个请求中使用。这里是在uri中引用的regionId。</p> 
<pre class="has"><code class="language-html">"request": {
        "url": "/${get_region_id($regionIds)}" #格式:${fun($var)}。fun为.py中的函数名，var为前一接口提取的变量名
        "headers": {
          "x-auth-token": "$token"
        },</code></pre> 
<p>参考资料：</p> 
<p><a href="http://cn.httprunner.org/quickstart/" rel="nofollow">http://cn.httprunner.org/quickstart/</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab626361a1bae69b3bc3f2b7fb2ef625/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常见的状态码：HTTP Status Code</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e78055d9ad68500539147b357b8d6f17/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在最新Spring官网下载jar包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>