<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言期末复习专项——编程题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言期末复习专项——编程题" />
<meta property="og:description" content="目录
1.题目：有 1、2、3、4 四个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？
变式1：有0-9十个数字，能组成多少个互不相同且无重复数字的五位数？都是多少？
变式2：求这样两个数据：5位数=2*4位数，9个数字各不相同
变式3：对于三个三位数的也可以这么操作！
变式4：n位数，分别求该数各个数位上的数字之和。例如，输入 1234，输出 10
变式5：倒转数位输出（末尾为0的不输出）
变式6： 打印出100～999之间的所有水仙花数
变式7：编写一个函数，判断一个正整数是否为完数（输出从1到1000内的）
2.题目：判断是否为素数，若是，则返回1，否则返回0，若输入1或比1小的数字返回0
3.数组排序
4.二分法查找
5.最大公约数
变式1：最小公倍数
变式2：分解质因数只针对合数
6.猴子吃桃题
变式1：水手分椰子问题
7.实现在数组中查找最大元素和最小元素的下标
变式1：定义有10个元素的一维数组，数组元素的值由平台输入，输入变量x，将数组中所有与x值相等的元素删除，并输出删除后的数组
变式2：插入一个数到一个已排好序的数组中
8.回文问题
变式1：如何判断一个字符串是不是回文字符串？
变式2：倒转字符串输出
9.二维数组
变式1：转置矩阵
变式2：矩阵乘法
10.结构体问题
11.编写程序，生成两个字符串str1和str2，比较两个字符串的大小（不得使用strcmp函数）
11.日期问题
12.编写一函数，由实参传来一个字符串，统计此字符串中字母、数字、空格和其他字符的个数
变式1：输入字符串，如果它是一个大写字母，则把它变成小写字母；如果它是小写字母，则把它变成大写字母；其它字符不变
变式2：编写一个函数，将两个字符串连接起来，不要使用strcat函数
12.阶乘算和
变式1：sinx的Taylor展开式近似计算
13.链表的各种操作
喜欢的可以点个赞赞♥
1.题目：有 1、2、3、4 四个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 程序分析：可填在百位、十位、个位的数字都是 1、2、3、4，组成所有的排列后再去掉不满足条件的排列。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i,j,k; for(i=1; i&lt;5; i&#43;&#43;) for(j=1; j&lt;5; j&#43;&#43;) for(k=1; k&lt;5; k&#43;&#43;) { if(i!=j &amp;&amp; i!=k &amp;&amp; j!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7cac607b8cbdefd066ddf617fd919061/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-20T14:51:35+08:00" />
<meta property="article:modified_time" content="2022-11-20T14:51:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言期末复习专项——编程题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E9%A2%98%E7%9B%AE%EF%BC%9A%E6%9C%89%C2%A01%E3%80%812%E3%80%813%E3%80%814%C2%A0%E5%9B%9B%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%83%BD%E7%BB%84%E6%88%90%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E4%B8%94%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%89%E4%BD%8D%E6%95%B0%EF%BC%9F%E9%83%BD%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%E9%A2%98%E7%9B%AE%EF%BC%9A%E6%9C%89%C2%A01%E3%80%812%E3%80%813%E3%80%814%C2%A0%E5%9B%9B%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%83%BD%E7%BB%84%E6%88%90%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E4%B8%94%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%89%E4%BD%8D%E6%95%B0%EF%BC%9F%E9%83%BD%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F" rel="nofollow">1.题目：有 1、2、3、4 四个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</a></p> 
<p id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%9C%890-9%E5%8D%81%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%83%BD%E7%BB%84%E6%88%90%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E4%B8%94%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%84%E4%BA%94%E4%BD%8D%E6%95%B0%EF%BC%9F%E9%83%BD%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%9C%890-9%E5%8D%81%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%83%BD%E7%BB%84%E6%88%90%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E4%B8%94%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%84%E4%BA%94%E4%BD%8D%E6%95%B0%EF%BC%9F%E9%83%BD%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F" rel="nofollow">变式1：有0-9十个数字，能组成多少个互不相同且无重复数字的五位数？都是多少？</a></p> 
<p id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E6%B1%82%E8%BF%99%E6%A0%B7%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%9A5%E4%BD%8D%E6%95%B0%3D2*4%E4%BD%8D%E6%95%B0%EF%BC%8C9%E4%B8%AA%E6%95%B0%E5%AD%97%E5%90%84%E4%B8%8D%E7%9B%B8%E5%90%8C-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F2%EF%BC%9A%E6%B1%82%E8%BF%99%E6%A0%B7%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%9A5%E4%BD%8D%E6%95%B0%3D2*4%E4%BD%8D%E6%95%B0%EF%BC%8C9%E4%B8%AA%E6%95%B0%E5%AD%97%E5%90%84%E4%B8%8D%E7%9B%B8%E5%90%8C" rel="nofollow">变式2：求这样两个数据：5位数=2*4位数，9个数字各不相同</a></p> 
<p id="%E5%8F%98%E5%BC%8F3%EF%BC%9A%E5%AF%B9%E4%BA%8E%E4%B8%89%E4%B8%AA%E4%B8%89%E4%BD%8D%E6%95%B0%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%81-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F3%EF%BC%9A%E5%AF%B9%E4%BA%8E%E4%B8%89%E4%B8%AA%E4%B8%89%E4%BD%8D%E6%95%B0%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%81" rel="nofollow">变式3：对于三个三位数的也可以这么操作！</a></p> 
<p id="%E5%8F%98%E5%BC%8F4%EF%BC%9An%E4%BD%8D%E6%95%B0%EF%BC%8C%E5%88%86%E5%88%AB%E6%B1%82%E8%AF%A5%E6%95%B0%E5%90%84%E4%B8%AA%E6%95%B0%E4%BD%8D%E4%B8%8A%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8C%E8%BE%93%E5%85%A5%201234%EF%BC%8C%E8%BE%93%E5%87%BA%2010-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F4%EF%BC%9An%E4%BD%8D%E6%95%B0%EF%BC%8C%E5%88%86%E5%88%AB%E6%B1%82%E8%AF%A5%E6%95%B0%E5%90%84%E4%B8%AA%E6%95%B0%E4%BD%8D%E4%B8%8A%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8C%E8%BE%93%E5%85%A5%201234%EF%BC%8C%E8%BE%93%E5%87%BA%2010" rel="nofollow">变式4：n位数，分别求该数各个数位上的数字之和。例如，输入 1234，输出 10</a></p> 
<p id="%E5%8F%98%E5%BC%8F5%EF%BC%9A%E5%80%92%E8%BD%AC%E6%95%B0%E4%BD%8D%E8%BE%93%E5%87%BA%EF%BC%88%E6%9C%AB%E5%B0%BE%E4%B8%BA0%E7%9A%84%E4%B8%8D%E8%BE%93%E5%87%BA%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F5%EF%BC%9A%E5%80%92%E8%BD%AC%E6%95%B0%E4%BD%8D%E8%BE%93%E5%87%BA%EF%BC%88%E6%9C%AB%E5%B0%BE%E4%B8%BA0%E7%9A%84%E4%B8%8D%E8%BE%93%E5%87%BA%EF%BC%89" rel="nofollow">变式5：倒转数位输出（末尾为0的不输出）</a></p> 
<p id="%E5%8F%98%E5%BC%8F6%EF%BC%9A%C2%A0%E6%89%93%E5%8D%B0%E5%87%BA100%EF%BD%9E999%E4%B9%8B%E9%97%B4%E7%9A%84%E6%89%80%E6%9C%89%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F6%EF%BC%9A%C2%A0%E6%89%93%E5%8D%B0%E5%87%BA100%EF%BD%9E999%E4%B9%8B%E9%97%B4%E7%9A%84%E6%89%80%E6%9C%89%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0" rel="nofollow">变式6： 打印出100～999之间的所有水仙花数</a></p> 
<p id="%E5%8F%98%E5%BC%8F7%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E6%95%B0%EF%BC%88%E8%BE%93%E5%87%BA%E4%BB%8E1%E5%88%B01000%E5%86%85%E7%9A%84%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F7%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E6%95%B0%EF%BC%88%E8%BE%93%E5%87%BA%E4%BB%8E1%E5%88%B01000%E5%86%85%E7%9A%84%EF%BC%89" rel="nofollow">变式7：编写一个函数，判断一个正整数是否为完数（输出从1到1000内的）</a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="2.%E9%A2%98%E7%9B%AE%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%B4%A0%E6%95%B0%EF%BC%8C%E8%8B%A5%E6%98%AF%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E1%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E0%EF%BC%8C%E8%8B%A5%E8%BE%93%E5%85%A51%E6%88%96%E6%AF%941%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97%E8%BF%94%E5%9B%9E0-toc" style="margin-left:40px;"><a href="#2.%E9%A2%98%E7%9B%AE%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%B4%A0%E6%95%B0%EF%BC%8C%E8%8B%A5%E6%98%AF%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E1%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E0%EF%BC%8C%E8%8B%A5%E8%BE%93%E5%85%A51%E6%88%96%E6%AF%941%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97%E8%BF%94%E5%9B%9E0" rel="nofollow">2.题目：判断是否为素数，若是，则返回1，否则返回0，若输入1或比1小的数字返回0</a></p> 
<p id="3.%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#3.%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F" rel="nofollow">3.数组排序</a></p> 
<p id="4.%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#4.%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE" rel="nofollow">4.二分法查找</a></p> 
<p id="5.%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0" rel="nofollow">5.最大公约数</a></p> 
<p id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0" rel="nofollow">变式1：最小公倍数</a></p> 
<p id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8F%AA%E9%92%88%E5%AF%B9%E5%90%88%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F2%EF%BC%9A%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8F%AA%E9%92%88%E5%AF%B9%E5%90%88%E6%95%B0" rel="nofollow">变式2：分解质因数只针对合数</a></p> 
<p id="6.%E7%8C%B4%E5%AD%90%E5%90%83%E6%A1%83%E9%A2%98-toc" style="margin-left:40px;"><a href="#6.%E7%8C%B4%E5%AD%90%E5%90%83%E6%A1%83%E9%A2%98" rel="nofollow">6.猴子吃桃题</a></p> 
<p id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%B0%B4%E6%89%8B%E5%88%86%E6%A4%B0%E5%AD%90%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%B0%B4%E6%89%8B%E5%88%86%E6%A4%B0%E5%AD%90%E9%97%AE%E9%A2%98" rel="nofollow">变式1：水手分椰子问题</a></p> 
<p id="7.%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8B%E6%A0%87-toc" style="margin-left:40px;"><a href="#7.%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8B%E6%A0%87" rel="nofollow">7.实现在数组中查找最大元素和最小元素的下标</a></p> 
<p id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%9C%8910%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%E7%94%B1%E5%B9%B3%E5%8F%B0%E8%BE%93%E5%85%A5%EF%BC%8C%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8Fx%EF%BC%8C%E5%B0%86%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E4%B8%8Ex%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%EF%BC%8C%E5%B9%B6%E8%BE%93%E5%87%BA%E5%88%A0%E9%99%A4%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F1%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%9C%8910%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%E7%94%B1%E5%B9%B3%E5%8F%B0%E8%BE%93%E5%85%A5%EF%BC%8C%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8Fx%EF%BC%8C%E5%B0%86%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E4%B8%8Ex%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%EF%BC%8C%E5%B9%B6%E8%BE%93%E5%87%BA%E5%88%A0%E9%99%A4%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84" rel="nofollow">变式1：定义有10个元素的一维数组，数组元素的值由平台输入，输入变量x，将数组中所有与x值相等的元素删除，并输出删除后的数组</a></p> 
<p id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD-toc" style="margin-left:40px;"><a href="#%E5%8F%98%E5%BC%8F2%EF%BC%9A%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD" rel="nofollow">变式2：插入一个数到一个已排好序的数组中</a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="8.%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#8.%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98" rel="nofollow">8.回文问题</a></p> 
<p id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F1%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F" rel="nofollow">变式1：如何判断一个字符串是不是回文字符串？</a></p> 
<p id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E5%80%92%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F2%EF%BC%9A%E5%80%92%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA" rel="nofollow">变式2：倒转字符串输出</a></p> 
<p id="9.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#9.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">9.二维数组</a></p> 
<p id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F1%EF%BC%9A%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5" rel="nofollow">变式1：转置矩阵</a></p> 
<p id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F2%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95" rel="nofollow">变式2：矩阵乘法</a></p> 
<p id="10.%E7%BB%93%E6%9E%84%E4%BD%93%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#10.%E7%BB%93%E6%9E%84%E4%BD%93%E9%97%AE%E9%A2%98" rel="nofollow">10.结构体问题</a></p> 
<p id="11.%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%EF%BC%8C%E7%94%9F%E6%88%90%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2str1%E5%92%8Cstr2%EF%BC%8C%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%88%E4%B8%8D%E5%BE%97%E4%BD%BF%E7%94%A8strcmp%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#11.%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%EF%BC%8C%E7%94%9F%E6%88%90%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2str1%E5%92%8Cstr2%EF%BC%8C%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%88%E4%B8%8D%E5%BE%97%E4%BD%BF%E7%94%A8strcmp%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">11.编写程序，生成两个字符串str1和str2，比较两个字符串的大小（不得使用strcmp函数）</a></p> 
<p id="11.%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#11.%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98" rel="nofollow">11.日期问题</a></p> 
<p id="12.%E7%BC%96%E5%86%99%E4%B8%80%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%B1%E5%AE%9E%E5%8F%82%E4%BC%A0%E6%9D%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%BB%9F%E8%AE%A1%E6%AD%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E6%AF%8D%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E7%A9%BA%E6%A0%BC%E5%92%8C%E5%85%B6%E4%BB%96%E5%AD%97%E7%AC%A6%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#12.%E7%BC%96%E5%86%99%E4%B8%80%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%B1%E5%AE%9E%E5%8F%82%E4%BC%A0%E6%9D%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%BB%9F%E8%AE%A1%E6%AD%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E6%AF%8D%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E7%A9%BA%E6%A0%BC%E5%92%8C%E5%85%B6%E4%BB%96%E5%AD%97%E7%AC%A6%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">12.编写一函数，由实参传来一个字符串，统计此字符串中字母、数字、空格和其他字符的个数</a></p> 
<p id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AE%83%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%8C%E5%88%99%E6%8A%8A%E5%AE%83%E5%8F%98%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%AE%83%E6%98%AF%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%8C%E5%88%99%E6%8A%8A%E5%AE%83%E5%8F%98%E6%88%90%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%9B%E5%85%B6%E5%AE%83%E5%AD%97%E7%AC%A6%E4%B8%8D%E5%8F%98-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F1%EF%BC%9A%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AE%83%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%8C%E5%88%99%E6%8A%8A%E5%AE%83%E5%8F%98%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%AE%83%E6%98%AF%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%8C%E5%88%99%E6%8A%8A%E5%AE%83%E5%8F%98%E6%88%90%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%9B%E5%85%B6%E5%AE%83%E5%AD%97%E7%AC%A6%E4%B8%8D%E5%8F%98" rel="nofollow">变式1：输入字符串，如果它是一个大写字母，则把它变成小写字母；如果它是小写字母，则把它变成大写字母；其它字符不变</a></p> 
<p id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8strcat%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F2%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8strcat%E5%87%BD%E6%95%B0" rel="nofollow">变式2：编写一个函数，将两个字符串连接起来，不要使用strcat函数</a></p> 
<p id="12.%E9%98%B6%E4%B9%98%E7%AE%97%E5%92%8C-toc" style="margin-left:40px;"><a href="#12.%E9%98%B6%E4%B9%98%E7%AE%97%E5%92%8C" rel="nofollow">12.阶乘算和</a></p> 
<p id="%E5%8F%98%E5%BC%8F1%EF%BC%9Asinx%E7%9A%84Taylor%E5%B1%95%E5%BC%80%E5%BC%8F%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BC%8F1%EF%BC%9Asinx%E7%9A%84Taylor%E5%B1%95%E5%BC%80%E5%BC%8F%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97" rel="nofollow">变式1：sinx的Taylor展开式近似计算</a></p> 
<p id="13.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#13.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C" rel="nofollow">13.链表的各种操作</a></p> 
<hr id="hr-toc"> 
<p>喜欢的可以点个赞赞♥</p> 
<h3 id="1.%E9%A2%98%E7%9B%AE%EF%BC%9A%E6%9C%89%C2%A01%E3%80%812%E3%80%813%E3%80%814%C2%A0%E5%9B%9B%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%83%BD%E7%BB%84%E6%88%90%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E4%B8%94%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%89%E4%BD%8D%E6%95%B0%EF%BC%9F%E9%83%BD%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F">1.<strong>题目：</strong>有 1、2、3、4 四个数字，能组成多少个<strong>互不相同且无重复数字</strong>的三位数？都是多少？</h3> 
<p><strong>程序分析：</strong>可填在百位、十位、个位的数字都是 1、2、3、4，组成所有的排列后<strong>再去掉不满足条件的排列</strong>。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int i,j,k;
    for(i=1; i&lt;5; i++)
        for(j=1; j&lt;5; j++)
            for(k=1; k&lt;5; k++)
            {
                if(i!=j &amp;&amp; i!=k &amp;&amp; j!=k) printf("%d%d%d\n",i,j,k);
            }
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%9C%890-9%E5%8D%81%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%83%BD%E7%BB%84%E6%88%90%E5%A4%9A%E5%B0%91%E4%B8%AA%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E4%B8%94%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%84%E4%BA%94%E4%BD%8D%E6%95%B0%EF%BC%9F%E9%83%BD%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F">变式1：有0-9十个数字，能组成多少个互不相同且无重复数字的五位数？都是多少？</h4> 
<p><strong>程序分析：</strong></p> 
<p><strong>思路一：</strong> 特殊元素优先处理——0不能再首位</p> 
<p>组成所有的排列后<strong>再去掉不满足条件的排列（但是五位数要写很多条件表达式）</strong></p> 
<p><strong>怎么去判断一个数字在这个数中只出现了一次？？？</strong></p> 
<p><u>可以用一个count[10]数组进行统计</u></p> 
<p><u>用%取余运算和/整除运算来得到各个位数的值 然后count[ret]++</u></p> 
<p><u>这样就不需要用一堆的a,b,c,d,e,f来存储各个数位上的数了 ✌</u></p> 
<p>记得初始化为0</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int i,j;
    int ret;
    for(i=1000; i&lt;10000; i++)
    {
        int count[10]={0};
        int flag = 1;
        ret = i;
        for(j=0; j&lt;5; j++)
        {
            count[ret%10]++;
            ret /= 10;
        }
        for(j=0; j&lt;10; j++)
        {
            if(count[j]&gt;1)
            {
                flag = 0;
                break;
            }
        }
        if(flag) printf("%d\n",i);
    }
    return 0;
}</code></pre> 
<p>值得注意的是：定义数组count[10] = {0} 和 标志flag = 1 应该在循环内定义</p> 
<p>否则无法达到<strong>刷新</strong>的目的</p> 
<h4 id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E6%B1%82%E8%BF%99%E6%A0%B7%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%9A5%E4%BD%8D%E6%95%B0%3D2*4%E4%BD%8D%E6%95%B0%EF%BC%8C9%E4%B8%AA%E6%95%B0%E5%AD%97%E5%90%84%E4%B8%8D%E7%9B%B8%E5%90%8C">变式2：求这样两个数据：5位数=2*4位数，9个数字各不相同</h4> 
<p>思路分析：9个数字各不相同，一个四位数字一个五位数字</p> 
<p>可以先把所有数字不同的四位数字找出来，再判断四位和五位的数字是否有重复的</p> 
<p>（也可以想着从0-9中抽取几个数字来判断是否为两倍，比较难实现）</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int Judge(int i,int n)
{
    int j;
    int count[10] = {0};
    for(j=0; j&lt;n; j++)
    {
        count[i%10]++;
        i /= 10;
    }
    for(j=0; j&lt;10; j++)
    {
        if(count[j]&gt;1)
        {
            return 0;

        }
    }
    return 1;
}

int main(void)
{
    int i;
    int temp;
    int num = 0;
    for(i=5000; i&lt;10000; i++)
    {
        if(Judge(i,5))
        {
            temp = i*2*10000+i;
            if(Judge(temp,9))
            {
                num++;
                printf("%d = 2*%d\n",i*2,i);
            }
        }
    }
    printf("\n有%d种可能结果\n",num);
    return 0;
}
</code></pre> 
<p><strong>链接两个数，更方便计算最后是不是有重复的数字</strong></p> 
<h4 id="%E5%8F%98%E5%BC%8F3%EF%BC%9A%E5%AF%B9%E4%BA%8E%E4%B8%89%E4%B8%AA%E4%B8%89%E4%BD%8D%E6%95%B0%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%81"><strong>变式3：对于三个三位数的也可以这么操作！</strong></h4> 
<p><strong>int temp = i*3*1000000 + i*2*1000 + i ;</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int Judge(int i,int n)
{
    int j;
    int count[10] = {0};
    for(j=0; j&lt;n; j++)
    {
        count[i%10]++;
        i /= 10;
    }
    for(j=0; j&lt;10; j++)
    {
        if(count[j]&gt;1)
        {
            return 0;
        }
    }
    return 1;
}

int main(void)
{
    int i;
    int temp;
    int num = 0;
    for(i=100; i&lt;=329; i++)
    {
        if(Judge(i,3) &amp;&amp; Judge(i*2,3) &amp;&amp; Judge(i*3,3))
        {
            temp = i*3*1000000+i*2*1000+i;
            if(Judge(temp,9))
            {
                num++;
                printf("(%d,%d,%d)\n",i,i*2,i*3);
            }
        }
    }
    printf("\n有%d种可能结果\n",num);
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F4%EF%BC%9An%E4%BD%8D%E6%95%B0%EF%BC%8C%E5%88%86%E5%88%AB%E6%B1%82%E8%AF%A5%E6%95%B0%E5%90%84%E4%B8%AA%E6%95%B0%E4%BD%8D%E4%B8%8A%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8C%E8%BE%93%E5%85%A5%201234%EF%BC%8C%E8%BE%93%E5%87%BA%2010">变式4：n位数，分别求该数各个数位上的数字之和。例如，输入 1234，输出 10</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int sum=0;
    int num;
    scanf("%d",&amp;num);
    while(num&gt;0)
    {
        sum+=num%10;
        num/=10;
    }
    printf("%d",sum);
    return 0;
}


</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F5%EF%BC%9A%E5%80%92%E8%BD%AC%E6%95%B0%E4%BD%8D%E8%BE%93%E5%87%BA%EF%BC%88%E6%9C%AB%E5%B0%BE%E4%B8%BA0%E7%9A%84%E4%B8%8D%E8%BE%93%E5%87%BA%EF%BC%89">变式5：倒转数位输出（末尾为0的不输出）</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int n;
    scanf("%d",&amp;n);
    int a[10] = {0};
    int i = 0;
    while(n&gt;0)
    {
        a[i++] = n%10;
        n /= 10;
    }
    int num = 0;
    int temp = 1;
    for(int j = i-1;j&gt;=0;j--)
    {
        num += temp*a[j];
        temp *= 10;
    }
    printf("%d",num);
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F6%EF%BC%9A%C2%A0%E6%89%93%E5%8D%B0%E5%87%BA100%EF%BD%9E999%E4%B9%8B%E9%97%B4%E7%9A%84%E6%89%80%E6%9C%89%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0">变式6： 打印出100～999之间的所有水仙花数</h4> 
<p>分析：水仙花数是指一个n位数( n≥3 )，它的每个位上的数字的n次幂之和等于它本身</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
int main()
{
    int i;
    int sum;
    int temp;
    for(i=100;i&lt;1000;i++)
    {
        sum=0;
        temp=i;
        while(temp&gt;0)
        {
            sum+=(int)pow(temp%10,3);
            temp/=10;
        }
        if(sum==i) printf("%d\n",i);
    }
    return 0;
}
</code></pre> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
int main()
{
    int i;
    int sum;
    int temp;
    for(i=1000;i&lt;10000;i++)
    {
        sum=0;
        temp=i;
        while(temp&gt;0)
        {
            sum+=(int)pow(temp%10,4);
            temp/=10;
        }
        if(sum==i) printf("%d\n",i);
    }
    return 0;
}

1634   8208   9474
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F7%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E6%95%B0%EF%BC%88%E8%BE%93%E5%87%BA%E4%BB%8E1%E5%88%B01000%E5%86%85%E7%9A%84%EF%BC%89">变式7：编写一个函数，判断一个正整数是否为完数（输出从1到1000内的）</h4> 
<p>如果一个数的除它本身以外的所有因数之和等于它本身，则它就是完数</p> 
<p>（和分解质因式不同28的真因子有1,2,4,7,14）</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int Judge(int n)
{
    int temp=n;
    int sum=0;
    int i;
    for(i=1;i&lt;n;i++)
    {
        if(n%i==0)
        {
            sum+=i;
        }
    }
    if(sum==temp) return 1;
    else return 0;
}

int main()
{
    int i;
    for(i=1;i&lt;10000;i++)
    {
        if(Judge(i)) printf("%d\n",i);
    }
    return 0;
}


6    28    496    8128</code></pre> 
<h3></h3> 
<h3 id="2.%E9%A2%98%E7%9B%AE%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%B4%A0%E6%95%B0%EF%BC%8C%E8%8B%A5%E6%98%AF%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E1%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E0%EF%BC%8C%E8%8B%A5%E8%BE%93%E5%85%A51%E6%88%96%E6%AF%941%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97%E8%BF%94%E5%9B%9E0">2.题目：判断是否为素数，若是，则返回1，否则返回0，若输入1或比1小的数字返回0</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
int Judge(int n)
{
    if(n&lt;=1) return -1;
    int i;
    for(i=2;i&lt;sqrt(n)+1;i++)
    {
        if(n%i==0) return 0;
    }
    return 1;
}

int main(void)
{
    int n;
    scanf("%d",&amp;n);
    if(Judge(n)) printf("这是一个素数\n");
    else printf("这不是一个素数\n");
    return 0;
}
</code></pre> 
<p>for (i = 2; i &lt; sqrt(a)+1; i++)</p> 
<p>因数都是成对出现的，比如100，其可以分为1和100，2和50，4和25，由此可见其中一个必然小于等于100的开方，另一个则大于等于100的开方</p> 
<h3 id="3.%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">3.<strong>数组排序</strong></h3> 
<p><strong>期末考试的排序方法常常有三种：交换排序、选择排序、冒泡排序</strong></p> 
<pre><code class="language-cpp">void Choose_Sort(int *a,int n)//   交换法排序
{
    int i,j;
    for(i=0 ; i&lt;n-1 ; i++)   // 只用派n-1次填空题坑点！！！
        for (j=i+1 ; j&lt;n ; j++)  
        {
            if (a[i] &gt; a[j])
            {
                int temp;
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
}
</code></pre> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void Choose_Sort(int *arr,int n) // 选择法排序
{
    int i,j;
    int temp;
    int max;
    for(i=0; i&lt;n-1; i++)  //只用比较n-1次
    {
        max = i;
        for(j=i+1; j&lt;n; j++) 
        {
            if(arr[max]&lt;arr[j]) max=j;  // 记录的是较大的元素的位置
        }
        if(max!=i)
        {
            temp = arr[max];
            arr[max] = arr[i];
            arr[i] = temp;
        }
    }
}

int main(void)
{
    int n;
    scanf("%d",&amp;n);
    int a[n];
    for(int i=0;i&lt;n;i++)
    {
        scanf("%d",&amp;a[i]);
    }
    Choose_Sort(a,n);
    for(int i=0;i&lt;n;i++)  printf("%d ",a[i]);
    return 0;
}
</code></pre> 
<p>这是冒泡排序（从小到大），顾名思义就是每次让较大的数想气泡一样浮上去，对于为什么第一个for语句只需比n-1次，大家想想，现在排5个数，四个较大数浮上去了，最后一个还用比吗？同样第二语句为什么只需比n-1-i次也是同样的道理</p> 
<pre><code class="language-cpp">void Bubble_Sort(int* a, int n) //冒泡排序
{
	int i, j;
    for (i = 0; i &lt; n-1; i++)  //此处只需比n-1次
        for (j = 0; j &lt; n-i-1; j++)   //每次比好后，只需比n-1-i次,后面的就不用再管了
        {                              //每次都是从第一开始比较，像气泡从底部浮出
            if (a[j+1] &lt; a[j])
            {
                int temp;
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
}
</code></pre> 
<h3 id="4.%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE">4.二分法查找</h3> 
<p>二分查找，分治法里面的一种，有叫折中查找。</p> 
<p>但二分查找必须有个前提，就是对于查找对象，必须是已经排好序的。一般期末考试常考的是对数组的排序。</p> 
<p>这里还特别针对有重复数字的数组进行了处理</p> 
<p>key &lt;= arr[mid]   end   =   mid; </p> 
<p>有效确保了面对已经找到了的元素，再去找前面有没有位置更靠前的元素</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int Find_Num(int arr[],int n,int key)
{
    int start=0;
    int end=n;
    int mid;
    while(start &lt; end)
    {
        mid =(start+end)/2;
        if(key &lt;= arr[mid]) end = mid;
        else  start = mid+1;
    }
    if(arr[end]==key) return end+1;
    return 0;
}


int main()
{
    int ret;
    int a[10]={1,4,4,4,4,4,7,8,9,10};
    int key;
    scanf("%d",&amp;key);
    ret = Find_Num(a,10,key);
    if(ret) printf("为第%d位数",ret);
    else printf("没有找到");
    return 0;
}
</code></pre> 
<h3 id="5.%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">5.最大公约数</h3> 
<p>对于最大公约数，大致思路有两种，直接循环、采用辗转相除法。</p> 
<p>这里直接讲第二种，又名欧几里得算法。</p> 
<p>内容就是：两个整数的最大公约数等于，大的除以小的余数，循环或递归，直至整除余0后的整数</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int GCD (int a, int b) // 最大公约数
{
    if (a%b == 0)
        return b;
    else
        return GCD (b, a % b);
}


int main()
{
    printf("%d",GCD(18,729));
    return 0;
}

//  a%b 的结果肯定比b要小 


int gcd(int a, int b)
{
    int temp;
    while ((a % b) != 0)
    {
        temp = a % b;
        a = b;
        b = temp;
    }
    return b;
}

</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">变式1：最小公倍数</h4> 
<p>其实就等于  a  *  b  /  最大公约数</p> 
<pre><code class="language-cpp">int GCD (int a, int b) // 最大公约数
{
    if (a%b == 0)
        return b;
    else
        return GCD (b, a % b);
}

int main()
{
    int a=18;
    int b=7;
    printf("%d\n",GCD(a,b));
    printf("%d\n",a*b/GCD(a,b));
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%8F%AA%E9%92%88%E5%AF%B9%E5%90%88%E6%95%B0">变式2：<strong>分解质因数只针对合数</strong></h4> 
<p><strong>（分解质因数也称分解素因数）求一个数分解质因数，要从最小的质数除起，一直除到结果为质数为止。分解质因数的算式叫短除法，和除法的性质相似，还可以用来求多个数的公因式</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void Func(int n)
{
    if(n&lt;=1 || n!=(int)n) exit(0);
    int i;
    printf("%d = ",n);
    for(i=2;i&lt;n;i++)
    {
        if(n%i==0)
        {
            printf("%d * ",i);
            n /= i;
            i--; // 这里i--是为了看看n中是否还有为i的因子
        }
    }
    printf("%d",i); // 为了补齐一个因子
}

int main()
{
    int n;
    scanf("%d",&amp;n);
    Func(n);
    return 0;
}
</code></pre> 
<h3 id="6.%E7%8C%B4%E5%AD%90%E5%90%83%E6%A1%83%E9%A2%98">6.<strong>猴子吃桃题</strong></h3> 
<p><br> 猴子吃桃问题，猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第 10 天早上想再吃时，见只剩下一个桃子。求第一天共摘多少桃子？</p> 
<p>思路：找出递推关系！（前一天和后一天的关系）</p> 
<p>自底向上地去寻求答案（特别注意只吃了九次）</p> 
<pre><code class="language-cpp">int main()
{
    int i, count = 1;
    for (i = 1; i &lt; 10; i++)
    {
        count = (count + 1) * 2;
    }
    printf("%d\n", count);
    return 0;
}

</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E6%B0%B4%E6%89%8B%E5%88%86%E6%A4%B0%E5%AD%90%E9%97%AE%E9%A2%98">变式1：水手分椰子问题</h4> 
<p>五个水手来到一个岛上，采了一堆椰子后，因为疲劳都睡着了。一段时间后，第一个水手醒来，悄悄地将椰子等分成五份，多出一个椰子，便给了旁边的猴子，然后自己藏起一份，再将剩下的椰子重新合在一起，继续睡觉。不久，第二名水手醒来，同样将椰子了等分成五份，恰好也多出 一个，也给了猴子。然而自己也藏起一份，再将剩下的椰子重新合在一起。以后每个水手都如此分了一次并都藏起一份，也恰好都把多出的一个给了猴子。第二天，五个水手醒来，发现椰子少了许多，心照不喧，便把剩下的椰子分成五份，恰好又多出一个，给了猴子。</p> 
<p>请问水手最初<strong>最少</strong>摘了多少个椰子？</p> 
<p>找最少还是递推问题：采用自底向上方式</p> 
<p>关键点每次去掉一个椰子后都可以均匀分成五份（即可以整除5），然后剩下4/5<br>  </p> 
<pre><code class="language-cpp">1.暴力解法
#include &lt;stdio.h&gt;
int main(){
    int n,x,j,k,l,m;
    for(n=5;;n++){
        j=4*(n-1)/5;
        k=4*(j-1)/5;
        l=4*(k-1)/5;
        m=4*(l-1)/5;
        if(n%5==1&amp;&amp;j%5==1&amp;&amp;k%5==1&amp;&amp;l%5==1&amp;&amp;m%5==1){
            printf("这堆椰子至少数量：%d个n",n);
            printf("分别见到椰子的数量：%d %d %d %d\n",j,k,l,m);
            break;
        }
    }
    return 0;
}


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;



int main()
{
    int count=0;
    int num=1;
    float temp=num;
    while(count&lt;5)
    {
        temp = temp*5/4.0+1;
        count++;
        if(temp != (int)temp)
        {
            count = 0;
            num++;
            temp = num;
        }
    }
    printf("%.f",temp);
    return 0;
}
</code></pre> 
<h3 id="7.%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8B%E6%A0%87">7.<strong>实现在数组中查找最大元素和最小元素的下标</strong></h3> 
<p></p> 
<pre><code class="language-cpp">void find(int* a,int n,int* max,int* min)
{
    int i;
    *max = *min = 0;
    for (i = 1; i &lt; n; i++)
    {
        if (a[i] &gt; a[*max])
            *max = i;
        else if (a[i] &lt; a[*min])
            *min = i;
    }
}

</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%9C%8910%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%E7%94%B1%E5%B9%B3%E5%8F%B0%E8%BE%93%E5%85%A5%EF%BC%8C%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8Fx%EF%BC%8C%E5%B0%86%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E4%B8%8Ex%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%EF%BC%8C%E5%B9%B6%E8%BE%93%E5%87%BA%E5%88%A0%E9%99%A4%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84">变式1：定义有10个元素的一维数组，数组元素的值由平台输入，输入变量x，将数组中所有与x值相等的元素删除，并输出删除后的数组</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main()
{
    srand(time(NULL));
    int a[10];
    for(int i=0; i&lt;10; i++)
    {
        a[i]=rand()%10+1;
    }
    for(int i=0; i&lt;10; i++)
    {
        printf("%-5d",a[i]);
    }
    int key = rand()%10+1;
    printf("\n\n%d\n\n",key);
    
    //法一
    
    for(int i=0; i&lt;10; i++)
    {
        if(a[i]!=key) printf("%-5d",a[i]);
    }
    printf("\n");
    
    //法二
    
    int length = 10;
    for(int i=0; i&lt;length; i++)
    {
        if(a[i]==key)
        {
            for(int j=i; j&lt;length-1; j++)
            {
                a[j]=a[j+1];
            }
            length--;
        }
    }
    for(int i=0; i&lt;length; i++)
    {
        printf("%-5d",a[i]);
    }
   
    return 0;
}</code></pre> 
<h3 id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD">变式2：插入一个数到一个已排好序的数组中</h3> 
<pre><code class="language-cpp">1</code></pre> 
<h3></h3> 
<h3 id="8.%E5%9B%9E%E6%96%87%E9%97%AE%E9%A2%98"><strong>8.回文问题</strong></h3> 
<p><br> 回文数是指正读和反读都一样的正整数。例如 3773 是回文数。求出 [1000 ， 9999] 之间的回文数</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int i;
    for(i=1000; i&lt;=9999; i++)
    {
        if((i/1000)==(i%10) &amp;&amp; (i/10%10)==(i/100%10))
            printf("%d\n",i);
    }
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F">变式1：如何判断一个字符串是不是回文字符串？</h4> 
<p>找两个指针：一个在最前，一个再最后（不是‘\0’）然后一个向左移动，一个向右移动</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char str[20];
    gets(str);
    char *p=str;
    char *q=str;
    while(*q++);
    q-=2;
    int flag = 1;
    while(p &lt; q)
    {
        if(*p++ != *q--)
        {
            flag = 0;
            break;
        }
    }
    if(flag)
        printf("这是一个回文字符串\n");
    else
        printf("这不是一个回文字符串\n");
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E5%80%92%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA">变式2：倒转字符串输出</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char str[20];
    char *p = gets(str);
    while(*p++);
    p -= 2;
    while(p&gt;=str)
    {
        putchar(*p--);
    }
    return 0;
}
</code></pre> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char str1[20];
    char *p = gets(str1);
    while(*p++);
    p -= 2;
    char str2[20];
    char *q = str2;
    while(p &gt;= str1)
    {
        *q++ = *p--;
    }
    *q = '\0';
    puts(str2);
    return 0;
}
</code></pre> 
<p></p> 
<h3 id="9.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><strong>9.二维数组</strong></h3> 
<p><br> 一个 14*14 方阵 A(i,j) ，其每个元素的值为该元素<strong>下标的平方和</strong>，求出该矩阵所有对角线元素的累加和 ( 注： i ，j 从 1 到 14) <br>  </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int main()
{
    int a[15][15];
    int i, j, sum = 0;
    for (i = 1; i &lt; 15; i++)
        for (j = 1; j &lt; 15; j++)
            {
                a[i][j] = i * i + j * j;
            }
    for (i = 1; i &lt; 15; i++)
        sum = sum + a[i][i];
    printf("%d", sum);
    return 0;
}


</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5">变式1：转置矩阵</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main()
{
    srand(time(NULL));
    int m,n;
    scanf("%d%d",&amp;m,&amp;n);
    int a[m][n];
    int i,j;
    for (i=0; i&lt;m; i++)
        for (j=0; j&lt;n; j++)
        {
            a[i][j] = rand()%5+1;
        }
    for (i=0; i&lt;m; i++)
    {
        for (j=0; j&lt;n; j++)
        {
            printf("%d\t",a[i][j]);
        }
        printf("\n\n");
    }
    printf("\n\n\n");
    for (i=0; i&lt;n; i++)
    {
        for (j=0; j&lt;m; j++)
        {
            printf("%d\t",a[j][i]);
        }
        printf("\n\n");
    }
    return 0;
}

</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95">变式2：矩阵乘法</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main()
{
    srand(time(NULL));
    int m,n;
    scanf("%d%d",&amp;m,&amp;n);
    int a[m][n];
    int b[n][m];
    int ret[m][m];
    int i,j;

    for (i=0; i&lt;m; i++)
        for (j=0; j&lt;n; j++)
        {
            a[i][j] = rand()%5+1;
            b[j][i] = rand()%5+1;

        }

    printf("\n\n\n");

    for (i=0; i&lt;m; i++)
    {
        for (j=0; j&lt;n; j++)
        {
            printf("%d\t",a[i][j]);
        }
        printf("\n\n");
    }

    printf("\n\n\n");

    for (i=0; i&lt;n; i++)
    {
        for (j=0; j&lt;m; j++)
        {
            printf("%d\t",b[i][j]);
        }
        printf("\n\n");
    }

    printf("\n\n\n");

    int k;
    for (i=0; i&lt;m; i++)
    {
        for (j=0; j&lt;m; j++)
        {
            ret[i][j]=0;
            for(k=0; k&lt;n; k++)
            {
                ret[i][j] += a[i][k] * b[k][j];
            }
        }
    }

    for (i=0; i&lt;m; i++)
    {
        for (j=0; j&lt;m; j++)
        {
            printf("%d\t",ret[i][j]);
        }
        printf("\n\n");
    }

    return 0;
}


</code></pre> 
<h3 id="10.%E7%BB%93%E6%9E%84%E4%BD%93%E9%97%AE%E9%A2%98"><strong>10.结构体问题</strong></h3> 
<p><br> 有 10 个学生，每个学生的数据包括学号、姓名、 6门课程的成绩，从键盘输入 5 个学生数据，要求输出 10 个学生6门课程总成绩，以及每门课的均分，以及每个学生未达到平均分的课程数和每门课没有达到平均分的人数</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

typedef struct stu
{
    char ID[10];
    char name[15];
    int course[6];
} Stu;


int main()
{
    srand(time(NULL));
    int i,j;
    Stu stu[10];
    for(i=0; i&lt;10; i++)
    {
        for(j=0; j&lt;6; j++)
        {
            stu[i].course[j]=rand()%30+71;
        }
    }

    int sum_stu[10]= {0};
    float aver_course[6]= {0};

    for(i=0; i&lt;10; i++)
    {
        for(j=0; j&lt;6; j++)
        {
            sum_stu[i]+=stu[i].course[j];
        }
        printf("第%d个学生的总分是%d\n\n",i+1,sum_stu[i]);
    }

    for(i=0; i&lt;6; i++)
    {
        for(j=0; j&lt;10; j++)
        {
            aver_course[i]+=stu[j].course[i];
        }
        aver_course[i]/=10;
        printf("第%d门课程的平均分是%.2f\n\n",i+1,aver_course[i]);
    }

    for(i=0; i&lt;10; i++)
    {
        int count = 0;
        for(j=0; j&lt;6; j++)
        {
            if(stu[i].course[j]&lt;aver_course[j]) count++;
        }
        printf("第%d个学生的未达到平均分的课程数是%d\n\n",i+1,count);
    }

    for(i=0; i&lt;6; i++)
    {
        int count = 0;
        for(j=0; j&lt;10; j++)
        {
            if(stu[j].course[i]&lt;aver_course[i]) count++;
        }
        printf("第%d门课程的未达到平均分的人数是%d\n\n",i+1,count);
    }

    return 0;
}
</code></pre> 
<p></p> 
<h3 id="11.%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%EF%BC%8C%E7%94%9F%E6%88%90%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2str1%E5%92%8Cstr2%EF%BC%8C%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%88%E4%B8%8D%E5%BE%97%E4%BD%BF%E7%94%A8strcmp%E5%87%BD%E6%95%B0%EF%BC%89">11.编写程序，生成两个字符串str1和str2，比较两个字符串的大小（不得使用strcmp函数）</h3> 
<p>输入 字符串 abc ABC<br> 输出 abc 大于 ABC</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char str1[20];
    char str2[20];
    gets(str1);
    gets(str2);
    char *p=str1;
    char *q=str2;
    int flag = 0;
    while(*p || *q)
    {
        if(*p &gt; *q)
        {
            flag = 1;
            break;
        }
        else if(*p &lt; *q)
        {
            flag = -1;
            break;
        }
        else
        {
            p++;
            q++;
        }
    }
    if(flag==1)
    {
        printf("%s 大于 %s",str1,str2);
    }
    else if(flag==-1)
    {
        printf("%s 小于 %s",str1,str2);
    }
    else
        printf("%s 等于 %s",str1,str2);
    return 0;
}

</code></pre> 
<h3 id="11.%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98">11.日期问题</h3> 
<p>给出年、月、日，计算该日是该年的第几天</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int main()
{
    int num[12]={31,28,31,30,31,30,31,31,30,31,30,31};
    int sum=0;
    int year,month,date;
    scanf("%d%d%d",&amp;year,&amp;month,&amp;date);
    num[1]=((year%4==0 &amp;&amp; year%100!=0) || (year%400==0)) ? 29 : 28;
    int i=0;
    for(i=0;i&lt;month-1;i++) sum+=num[i];
    sum+=date;
    printf("%d",sum);
    return 0;
}
</code></pre> 
<p>变式：输入年份和天数，输出这是今年的第几月第几天</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int main()
{
    int num[12]={31,28,31,30,31,30,31,31,30,31,30,31};
    int year,day;
    scanf("%d%d",&amp;year,&amp;day);
    num[1]=((year%4==0 &amp;&amp; year%100!=0) || (year%400==0)) ? 29 : 28;
    int i=0;
    for(i=0;day&gt;num[i];i++) day-=num[i];
    printf("第%d月第%d日\n",i+1,day);
    return 0;
}
</code></pre> 
<h3 id="12.%E7%BC%96%E5%86%99%E4%B8%80%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%B1%E5%AE%9E%E5%8F%82%E4%BC%A0%E6%9D%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%BB%9F%E8%AE%A1%E6%AD%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E6%AF%8D%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E7%A9%BA%E6%A0%BC%E5%92%8C%E5%85%B6%E4%BB%96%E5%AD%97%E7%AC%A6%E7%9A%84%E4%B8%AA%E6%95%B0">12.编写一函数，由实参传来一个字符串，统计此字符串中字母、数字、空格和其他字符的个数</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void Func(char* p)
{
    int num=0;
    int space=0;
    int ch=0;
    int other=0;
    while(*p)
    {
        if(*p&gt;='0'&amp;&amp;*p&lt;='9') num++;
        else if((*p&gt;='a'&amp;&amp;*p&lt;='z')||(*p&gt;='A'&amp;&amp;*p&lt;='Z')) ch++;
        else if(*p==' ') space++;
        else other++;
        p++;
    }
    printf("数字：%d\n字母：%d\n空格：%d\n其他字符：%d",num,ch,space,other);
}

int main()
{
    char str[50];
    gets(str);
    Func(str);
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F1%EF%BC%9A%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AE%83%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%8C%E5%88%99%E6%8A%8A%E5%AE%83%E5%8F%98%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%AE%83%E6%98%AF%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%8C%E5%88%99%E6%8A%8A%E5%AE%83%E5%8F%98%E6%88%90%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%EF%BC%9B%E5%85%B6%E5%AE%83%E5%AD%97%E7%AC%A6%E4%B8%8D%E5%8F%98">变式1：输入字符串，如果它是一个大写字母，则把它变成小写字母；如果它是小写字母，则把它变成大写字母；其它字符不变</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char str[50];
    gets(str);
    char *p=str;
    while(*p)
    {
        if(*p&gt;='a'&amp;&amp;*p&lt;='z') *p-=32;
        else if(*p&gt;='A'&amp;&amp;*p&lt;='Z') *p+=32;
        p++;
    }
    puts(str);
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F2%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8strcat%E5%87%BD%E6%95%B0">变式2：编写一个函数，将两个字符串连接起来，不要使用strcat函数</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char str1[30];
    char str2[30];
    char *p=str1;
    char *q=str2;
    gets(str1);
    gets(str2);
    while(*p++);
    p-=1;
    while(*q)
    {
        *p++ = *q++;
    }
    *p=*q;      // 切记加上‘\0’!!!
    puts(str1);
    return 0;
}
</code></pre> 
<h3 id="12.%E9%98%B6%E4%B9%98%E7%AE%97%E5%92%8C">12.阶乘算和</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int temp = 1;
    int sum = 0;
    int i;
    int n;
    scanf("%d",&amp;n);
    for(i=1;i&lt;=n;i++)
    {
        temp *= i;
        sum += temp;
    }
    printf("%d",sum);
    return 0;
}
</code></pre> 
<h4 id="%E5%8F%98%E5%BC%8F1%EF%BC%9Asinx%E7%9A%84Taylor%E5%B1%95%E5%BC%80%E5%BC%8F%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97">变式1：sinx的Taylor展开式近似计算</h4> 
<p></p> 
<h3 id="13.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C">13.链表的各种操作</h3> 
<p>初始化链表（链表只要有一个头节点和长度作为数据性质就好了）</p> 
<p>（其他的操作都是对链表中的节点进行的！！！）</p> 
<p>创造节点，插入节点，删除节点（包含了寻找节点）</p> 
<p>遍历并打印链表</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
typedef struct s
{
    int data;
    struct s* next;
} Node;

typedef struct ss
{
    Node head;
    int length;
} LinkList;


LinkList* Init_LinkList(void)
{
    LinkList* p=NULL;
    if((p=malloc(sizeof(LinkList)))==NULL)
    {
        printf("ERORR!\n");
        return NULL;
    }
    p-&gt;head.data = 0;
    p-&gt;head.next = NULL;
    p-&gt;length = 0;
    return p;
}

int Insert_Node1(LinkList* p,int n)
{
    Node* q;
    if((q=malloc(sizeof(Node)))==NULL)
    {
        printf("ERORR!\n");
        return 0;
    }
    q-&gt;data = n;
    q-&gt;next = NULL;
    if(p-&gt;head.next==NULL) p-&gt;head.next = q;
    else
    {
        Node* pre = p-&gt;head.next;
        p-&gt;head.next = q;
        q-&gt;next = pre;
    }
    p-&gt;length++;
    return 1;
}

int Insert_Node2(LinkList* p,int n)
{
    Node* q;

    if((q=malloc(sizeof(Node)))==NULL)
    {
        printf("ERORR!\n");
        return 0;
    }
    q-&gt;data = n;
    q-&gt;next = NULL;
    if(p-&gt;head.next==NULL) p-&gt;head.next = q;
    else
    {
        Node* pre = p-&gt;head.next;
        while(pre-&gt;next!=NULL) pre=pre-&gt;next;
        pre-&gt;next = q;
    }
    p-&gt;length++;
    return 1;
}

int Delete_Node(LinkList* p,int n)
{
    if(p-&gt;length==0) return 0;
    if(p-&gt;length==1)
    {
        free(p-&gt;head.next);
        p-&gt;head.next = NULL;
        p-&gt;length--;
        return 1;
    }
    Node* pre = p-&gt;head.next;
    for(int i=0; i&lt;n-2; i++)
    {
        pre = pre-&gt;next;
    }
    Node* temp = pre-&gt;next;
    pre-&gt;next = temp-&gt;next;
    free(temp);
    p-&gt;length--;
    return 1;
}

void Print(LinkList* p)
{
    printf("LinkList(%d) = ",p-&gt;length);
    if(p-&gt;head.next==NULL) return;
    Node* pre = p-&gt;head.next;
    while(pre-&gt;next!=NULL)
    {
        printf("%d -&gt; ",pre-&gt;data);
        pre = pre-&gt;next;
    }
    printf("%d",pre-&gt;data);
}

int main()
{
    int i=0;
    srand(time(NULL));
    LinkList* p=Init_LinkList();
    while(i&lt;20)
    {
        int num=rand()%3;
        int n=rand()%10+1;
        int m=0;
        if(p-&gt;length!=0) m=rand()%p-&gt;length+1;
        switch(num)
        {
        case 0:
            if(Insert_Node1(p,n)) printf("\n\n第%d次：头插法插入%d\n\n",i+1,n);
            else printf("插入失败\n");
            Print(p);
            break;
        case 1:
            if(Insert_Node2(p,n)) printf("\n\n第%d次：尾插法插入%d\n\n",i+1,n);
            else printf("插入失败\n");
            Print(p);
            break;
        case 2:
            if(Delete_Node(p,m)) printf("\n\n第%d次：删除第%d个元素\n\n",i+1,m);
            else printf("删除失败\n");
            Print(p);
            break;
        }
        i++;
    }
    return 0;
}</code></pre> 
<p>删除操作要先有pre临时指针保存当前节点的地址，再进行将p后移一位，最后再删除节点</p> 
<p></p> 
<p>如果要通过查找相同的数据的节点</p> 
<p>要用两个节点指针，一个pre指向上一个节点，一个p指向当前节点</p> 
<p>while（p→data!=n &amp;&amp; p→next!=NULL）</p> 
<p>｛pre=p ；p=p→next; ｝</p> 
<p>再去比较是不是相等的（因为跳出循环有两个原因！）</p> 
<p>然后pre→next = p→next</p> 
<p>free（p）</p> 
<p>排序</p> 
<p>用简单地插入排序就好了</p> 
<p>只是交换两个元素的位置变成了用一个临时指针变量了</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e484323ff7782c32f3c481b7e179871/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vmware虚拟机黑屏问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d63cf8eee1b95edd195959e1347a3c73/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">运算符大全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>