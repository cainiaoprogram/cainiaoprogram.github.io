<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rust学习笔记-常见的编程概念-函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Rust学习笔记-常见的编程概念-函数" />
<meta property="og:description" content="Rust学习笔记 常见的编程概念 函数 Rust 代码中的函数和变量名使用 snake case 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序：
fn main() { println!(&#34;Main function!&#34;); another_function(); } fn another_function() { println!(&#34;Another function!&#34;); } 在 Rust 中通过输入 fn 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。
可以使用函数名后跟圆括号来调用我们定义过的任意函数。因为程序中已定义 another_function 函数，所以可以在 main 函数中调用它。注意，源码中 another_function 定义在 main 函数 之后；也可以定义在之前。Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。
让我们新建一个叫做 functions 的二进制项目来进一步探索函数。将上面的 another_function 例子写入 src/main.rs 中并运行。你应该会看到如下输出：
参数 我们可以定义为拥有 参数（parameters）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（arguments），但是在日常交流中，人们倾向于不区分使用 parameter 和 argument 来表示函数定义中的变量或调用函数时传入的具体值。
fn main() { another_function(5); } fn another_function(x: u32) { println!(&#34;The value of x is {x}&#34;); } 运行结果:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/01a1649350a4e4173da9960cf4781954/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-10T19:57:59+08:00" />
<meta property="article:modified_time" content="2024-01-10T19:57:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust学习笔记-常见的编程概念-函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Rust_0"></a>Rust学习笔记</h2> 
<h3><a id="_1"></a>常见的编程概念</h3> 
<h4><a id="httpskaiserygithubiotrplzhcnch0303howfunctionsworkhtml_2"></a><a href="https://kaisery.github.io/trpl-zh-cn/ch03-03-how-functions-work.html#%E5%87%BD%E6%95%B0" rel="nofollow">函数</a></h4> 
<p><strong>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格</strong>。在 snake case 中，<strong>所有字母都是小写并使用下划线分隔单词</strong>。这是一个包含函数定义示例的程序：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Main function!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">another_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">another_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Another function!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>在 Rust 中通过输入 <code>fn</code> 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。</strong></p> 
<p>可以使用函数名后跟圆括号来调用我们定义过的任意函数。因为程序中已定义 <code>another_function</code> 函数，所以可以在 <code>main</code> 函数中调用它。注意，源码中 <code>another_function</code> 定义在 <code>main</code> 函数 <strong>之后</strong>；也可以定义在之前。Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。</p> 
<p>让我们新建一个叫做 <em>functions</em> 的二进制项目来进一步探索函数。将上面的 <code>another_function</code> 例子写入 <em>src/main.rs</em> 中并运行。你应该会看到如下输出：</p> 
<p><img src="https://images2.imgbox.com/0d/ca/yhqX4MTS_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="httpskaiserygithubiotrplzhcnch0303howfunctionsworkhtml_27"></a><a href="https://kaisery.github.io/trpl-zh-cn/ch03-03-how-functions-work.html#%E5%8F%82%E6%95%B0" rel="nofollow">参数</a></h5> 
<p>我们可以定义为拥有 <strong>参数</strong>（<em>parameters</em>）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（<em>arguments</em>），但是在日常交流中，人们倾向于不区分使用 <em>parameter</em> 和 <em>argument</em> 来表示函数定义中的变量或调用函数时传入的具体值。</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">another_function</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">another_function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is {x}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果:</p> 
<p><img src="https://images2.imgbox.com/6c/8d/R9kLwmnU_o.png" alt="在这里插入图片描述"></p> 
<p><code>another_function</code> 的声明中有一个命名为 <code>x</code> 的参数。<code>x</code> 的类型被指定为 <code>i32</code>。当我们将 <code>5</code> 传给 <code>another_function</code> 时，<code>println!</code> 宏会把 <code>5</code> 放在格式字符串中包含 <code>x</code> 的那对花括号的位置。</p> 
<p><strong>在函数签名中，必须 声明每个参数的类型</strong>。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。而且，在知道函数需要什么类型后，编译器就能够给出更有用的错误消息。</p> 
<p><strong>当定义多个参数时，使用逗号分隔</strong>，像这样：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">print_labeled_measurement</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token char">'h'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">print_labeled_measurement</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> unit_label<span class="token punctuation">:</span> <span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The measurement is {value}{unit_label}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：</p> 
<p><img src="https://images2.imgbox.com/bb/d8/jiB9ZXMv_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="httpskaiserygithubiotrplzhcnch0303howfunctionsworkhtml_67"></a><a href="https://kaisery.github.io/trpl-zh-cn/ch03-03-how-functions-work.html#%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">语句和表达式</a></h5> 
<p>**函数体由一系列的语句和一个可选的结尾表达式构成。**目前为止，我们提到的函数还不包含结尾表达式，不过你已经见过作为语句一部分的表达式。因为 <strong>Rust 是一门基于表达式（expression-based）的语言</strong>，这是一个需要理解的（不同于其他语言）重要区别。其他语言并没有这样的区别，所以让我们看看语句与表达式有什么区别以及这些区别是如何影响函数体的。</p> 
<p><strong>语句</strong>（<em>Statements</em>）是<strong>执行一些操作但不返回值的指令</strong>。 <strong>表达式</strong>（<em>Expressions</em>）<strong>计算并产生一个值</strong>。让我们看一些例子。</p> 
<p>实际上，我们已经使用过语句和表达式。使用 <code>let</code> 关键字创建变量并绑定一个值是一个语句。在列表 3-1 中，<code>let y = 6;</code> 是一个语句。</p> 
<p><strong>函数定义也是语句</strong>，上面整个例子本身就是一个语句。</p> 
<p><strong>语句不返回值</strong>。因此，<strong>不能把 <code>let</code> 语句赋值给另一个变量</strong>，比如下面的例子尝试做的，会产生一个错误：</p> 
<p>文件名：src/main.rs</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当运行这个程序时，会得到如下错误：</p> 
<p><img src="https://images2.imgbox.com/cf/54/O7ypUktE_o.png" alt="在这里插入图片描述"></p> 
<p><strong><code>let y = 6</code> 语句并不返回值</strong>，所以没有可以绑定到 <code>x</code> 上的值。这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 <code>x = y = 6</code>，这样 <code>x</code> 和 <code>y</code> 的值都是 <code>6</code>；<strong>Rust 中不能这样写</strong>。</p> 
<p><strong>表达式会计算出一个值，并且你将编写的大部分 Rust 代码是由表达式组成的</strong>。考虑一个数学运算，比如 <code>5 + 6</code>，这是一个表达式并计算出值 <code>11</code>。<strong>表达式可以是语句的一部分</strong>：在示例 3-1 中，<strong>语句 <code>let y = 6;</code> 中的 <code>6</code> 是一个表达式，它计算出的值是 <code>6</code></strong>。<strong>函数调用是一个表达式</strong>。<strong>宏调用是一个表达式</strong>。<strong>用大括号创建的一个新的块作用域也是一个表达式</strong>，例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
        x <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of y is {y}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/fe/9d/gTm0yTFm_o.png" alt="在这里插入图片描述"></p> 
<p>这个表达式：(花括号后面没有分号)</p> 
<pre><code class="prism language-rust"><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
    x <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>是一个代码块，它的值是 <code>7</code>。这个值作为 <code>let</code> 语句的一部分被绑定到 <code>y</code> 上。<strong>注意 <code>x+1</code> 这一行在结尾没有分号</strong>，与你见过的大部分代码行不同。<strong>表达式的结尾没有分号</strong>。如果<strong>在表达式的结尾加上分号，它就变成了语句</strong>，而<strong>语句不会返回值</strong>。在接下来探索具有返回值的函数和表达式时要谨记这一点。</p> 
<h5><a id="httpskaiserygithubiotrplzhcnch0303howfunctionsworkhtml_120"></a><a href="https://kaisery.github.io/trpl-zh-cn/ch03-03-how-functions-work.html#%E5%85%B7%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0" rel="nofollow">具有返回值的函数</a></h5> 
<p><strong>函数可以向调用它的代码返回值</strong>。我们并<strong>不对返回值命名</strong>，但<strong>要在箭头（<code>-&gt;</code>）后声明它的类型</strong>。在 Rust 中，<strong>函数的返回值等同于函数体最后一个表达式（不需要分号）的值</strong>。使<strong>用 <code>return</code> 关键字和指定值，可从函数中提前返回</strong>；但大部分函数隐式的返回最后的表达式。这是一个有返回值的函数的例子：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">five</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{<!-- --></span>
    <span class="token number">5</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">five</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of y is {y}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在 <code>five</code> 函数中没有函数调用、宏、甚至没有 <code>let</code> 语句 —— 只有数字 <code>5</code>。这在 Rust 中是一个完全有效的函数。注意，也<strong>指定了函数返回值的类型，就是 <code>-&gt; i32</code></strong>。尝试运行代码；输出应该看起来像这样：</p> 
<p><img src="https://images2.imgbox.com/50/3f/tEeiJtjm_o.png" alt="在这里插入图片描述"></p> 
<p><code>five</code> 函数的返回值是 <code>5</code>，所以返回值类型是 <code>i32</code>。让我们仔细检查一下这段代码。有两个重要的部分：首先，<code>let y = five();</code> 这一行表明我们使用函数的返回值初始化一个变量。因为 <code>five</code> 函数返回 <code>5</code>，这一行与如下代码相同：</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre> 
<p>其次，<code>five</code> 函数没有参数并定义了返回值类型，不过函数体只有单单一个 <code>5</code> 也没有分号，因为这是一个表达式，我们想要返回它的值。</p> 
<p>让我们看看另一个例子：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{<!-- --></span>
    x<span class="token operator">+</span><span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">plus_one</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of y is {y}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行代码会打印出 <code>The value of y is: 6</code>。但如果在包含 <code>x + 1</code> 的行尾加上一个分号，把它从表达式变成语句，我们将看到一个错误。</p> 
<p><img src="https://images2.imgbox.com/27/19/3Ecqb5Wj_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{<!-- --></span>
    x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">plus_one</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of y is {y}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8e/7c/zuRxclop_o.png" alt="在这里插入图片描述"></p> 
<p>主要的错误信息，“mismatched types”（类型不匹配），揭示了代码的核心问题。函数 <code>plus_one</code> 的定义说明它要返回一个 <code>i32</code> 类型的值，不过语句并不会返回值，使用单位类型 <code>()</code> 表示不返回值。因为不返回值与函数定义相矛盾，从而出现一个错误。在输出中，Rust 提供了一条信息，可能有助于纠正这个错误：它建议删除分号，这会修复这个错误。</p> 
<blockquote> 
 <p>创作不易，喜欢的话加个关注点个赞，❤谢谢谢谢❤</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/26818321ddbb13dfc3900867e6b30717/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Rust学习笔记-常见的编程概念-变量和数据类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b78f91d47c661738631fb2ce4c253e48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">软件测试|Python Selenium 库安装使用指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>