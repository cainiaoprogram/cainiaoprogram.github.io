<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代码精简10倍，责任链模式yyds - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="代码精简10倍，责任链模式yyds" />
<meta property="og:description" content="全新前后端微商城项目，手把手教学！ 全新前后端微商城项目，手把手教学！ 全新前后端微商城项目，手把手教学！ 文章来源：https://blog.csdn.net/q1472750149/article/details/121886327 目录
什么是责任链
使用场景
结语
前言
最近，我让团队内一位成员写了一个导入功能。他使用了责任链模式，代码堆的非常多，bug 也多，没有达到我预期的效果。
实际上，针对导入功能，我认为模版方法更合适！为此，隔壁团队也拿出我们的案例，进行了集体 code review。
学好设计模式，且不要为了练习，强行使用！让原本 100 行就能实现的功能，写了 3000 行！对错暂且不论，我们先一起看看责任链设计模式吧！
什么是责任链
责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。
使用场景
责任链的使用场景还是比较多的：
多条件流程判断：权限控制
ERP 系统流程审批：总经理、人事经理、项目经理
Java 过滤器的底层实现 Filter
如果不使用该设计模式，那么当需求有所改变时，就会使得代码臃肿或者难以维护，例如下面的例子。
反例 假设现在有一个闯关游戏，进入下一关的条件是上一关的分数要高于 xx：
游戏一共 3 个关卡
进入第二关需要第一关的游戏得分大于等于 80
进入第三关需要第二关的游戏得分大于等于 90
那么代码可以这样写：
//第一关 public class FirstPassHandler { public int handler(){ System.out.println(&#34;第一关--&gt;FirstPassHandler&#34;); return 80; } } //第二关 public class SecondPassHandler { public int handler(){ System.out.println(&#34;第二关--&gt;SecondPassHandler&#34;); return 90; } } //第三关 public class ThirdPassHandler { public int handler(){ System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c03a949d0e9328cd322566985aa772ff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-10T14:00:28+08:00" />
<meta property="article:modified_time" content="2024-01-10T14:00:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代码精简10倍，责任链模式yyds</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <pre class="has"><code class="language-go">全新前后端微商城项目，手把手教学！
全新前后端微商城项目，手把手教学！
全新前后端微商城项目，手把手教学！
文章来源：https://blog.csdn.net/q1472750149/article/details/121886327</code></pre> 
 <p><strong>目录</strong></p> 
 <ul><li><p>什么是责任链</p></li><li><p>使用场景</p></li><li><p>结语</p></li></ul> 
 <p><img src="https://images2.imgbox.com/5f/a3/PBhHg7eR_o.gif" alt="73b797b381f9eaea71717d113b8249b8.gif"></p> 
 <p>前言</p> 
 <p>最近，我让团队内一位成员写了一个导入功能。他使用了责任链模式，代码堆的非常多，bug 也多，没有达到我预期的效果。</p> 
 <p>实际上，针对导入功能，我认为模版方法更合适！为此，隔壁团队也拿出我们的案例，进行了集体 code review。</p> 
 <p>学好设计模式，且不要为了练习，强行使用！让原本 100 行就能实现的功能，写了 3000 行！对错暂且不论，我们先一起看看责任链设计模式吧！</p> 
 <h3><br></h3> 
 <blockquote> 
  <blockquote> 
   <p><strong>什么是责任链</strong></p> 
  </blockquote> 
 </blockquote> 
 <p>责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/c4/f7/o6slBOG4_o.png" alt="cbd4c01987f2b97e950e502e2a86d5ce.png"></p> 
 <h3><br></h3> 
 <blockquote> 
  <blockquote> 
   <p><strong>使用场景</strong></p> 
  </blockquote> 
 </blockquote> 
 <p>责任链的使用场景还是比较多的：</p> 
 <ul><li><p>多条件流程判断：权限控制</p></li><li><p>ERP 系统流程审批：总经理、人事经理、项目经理</p></li><li><p>Java 过滤器的底层实现 Filter</p></li></ul> 
 <p>如果不使用该设计模式，那么当需求有所改变时，就会使得代码臃肿或者难以维护，例如下面的例子。</p> 
 <h4>反例</h4> 
 <p>假设现在有一个闯关游戏，进入下一关的条件是上一关的分数要高于 xx：</p> 
 <ul><li><p>游戏一共 3 个关卡</p></li><li><p>进入第二关需要第一关的游戏得分大于等于 80</p></li><li><p>进入第三关需要第二关的游戏得分大于等于 90</p></li></ul> 
 <p>那么代码可以这样写：</p> 
 <pre class="has"><code class="language-go">//第一关
public class FirstPassHandler {
    public int handler(){
        System.out.println("第一关--&gt;FirstPassHandler");
        return 80;
    }
}

//第二关
public class SecondPassHandler {
    public int handler(){
        System.out.println("第二关--&gt;SecondPassHandler");
        return 90;
    }
}


//第三关
public class ThirdPassHandler {
    public int handler(){
        System.out.println("第三关--&gt;ThirdPassHandler，这是最后一关啦");
        return 95;
    }
}


//客户端
public class HandlerClient {
    public static void main(String[] args) {

        FirstPassHandler firstPassHandler = new FirstPassHandler();//第一关
        SecondPassHandler secondPassHandler = new SecondPassHandler();//第二关
        ThirdPassHandler thirdPassHandler = new ThirdPassHandler();//第三关

        int firstScore = firstPassHandler.handler();
        //第一关的分数大于等于80则进入第二关
        if(firstScore &gt;= 80){
            int secondScore = secondPassHandler.handler();
            //第二关的分数大于等于90则进入第二关
            if(secondScore &gt;= 90){
                thirdPassHandler.handler();
            }
        }
    }
}</code></pre> 
 <p>那么如果这个游戏有 100 关，我们的代码很可能就会写成这个样子：</p> 
 <pre class="has"><code class="language-go">if(第1关通过){
    // 第2关 游戏
    if(第2关通过){
        // 第3关 游戏
        if(第3关通过){
           // 第4关 游戏
            if(第4关通过){
                // 第5关 游戏
                if(第5关通过){
                    // 第6关 游戏
                    if(第6关通过){
                        //...
                    }
                }
            } 
        }
    }
}</code></pre> 
 <p>这种代码不仅冗余，并且当我们要将某两关进行调整时会对代码非常大的改动，这种操作的风险是很高的，因此，该写法非常糟糕。</p> 
 <h4>初步改造</h4> 
 <p>如何解决这个问题，我们可以通过链表将每一关连接起来，形成责任链的方式，第一关通过后是第二关，第二关通过后是第三关....</p> 
 <p>这样客户端就不需要进行多重 if 的判断了：</p> 
 <pre class="has"><code class="language-go">public class FirstPassHandler {
    /**
     * 第一关的下一关是 第二关
     */
    private SecondPassHandler secondPassHandler;

    public void setSecondPassHandler(SecondPassHandler secondPassHandler) {
        this.secondPassHandler = secondPassHandler;
    }

    //本关卡游戏得分
    private int play(){
        return 80;
    }

    public int handler(){
        System.out.println("第一关--&gt;FirstPassHandler");
        if(play() &gt;= 80){
            //分数&gt;=80 并且存在下一关才进入下一关
            if(this.secondPassHandler != null){
                return this.secondPassHandler.handler();
            }
        }

        return 80;
    }
}

public class SecondPassHandler {

    /**
     * 第二关的下一关是 第三关
     */
    private ThirdPassHandler thirdPassHandler;

    public void setThirdPassHandler(ThirdPassHandler thirdPassHandler) {
        this.thirdPassHandler = thirdPassHandler;
    }

    //本关卡游戏得分
    private int play(){
        return 90;
    }

    public int handler(){
        System.out.println("第二关--&gt;SecondPassHandler");

        if(play() &gt;= 90){
            //分数&gt;=90 并且存在下一关才进入下一关
            if(this.thirdPassHandler != null){
                return this.thirdPassHandler.handler();
            }
        }

        return 90;
    }
}

public class ThirdPassHandler {

    //本关卡游戏得分
    private int play(){
        return 95;
    }

    /**
     * 这是最后一关，因此没有下一关
     */
    public int handler(){
        System.out.println("第三关--&gt;ThirdPassHandler，这是最后一关啦");
        return play();
    }
}

public class HandlerClient {
    public static void main(String[] args) {

        FirstPassHandler firstPassHandler = new FirstPassHandler();//第一关
        SecondPassHandler secondPassHandler = new SecondPassHandler();//第二关
        ThirdPassHandler thirdPassHandler = new ThirdPassHandler();//第三关

        firstPassHandler.setSecondPassHandler(secondPassHandler);//第一关的下一关是第二关
        secondPassHandler.setThirdPassHandler(thirdPassHandler);//第二关的下一关是第三关

        //说明：因为第三关是最后一关，因此没有下一关
        //开始调用第一关 每一个关卡是否进入下一关卡 在每个关卡中判断
        firstPassHandler.handler();

    }
}</code></pre> 
 <h4>缺点</h4> 
 <p>现有模式的缺点：</p> 
 <ul><li><p>每个关卡中都有下一关的成员变量并且是不一样的，形成链很不方便</p></li><li><p>代码的扩展性非常不好</p></li></ul> 
 <h4>责任链改造</h4> 
 <p>既然每个关卡中都有下一关的成员变量并且是不一样的，那么我们可以在关卡上抽象出一个父类或者接口，然后每个具体的关卡去继承或者实现。</p> 
 <p>有了思路，我们先来简单介绍一下责任链设计模式的基本组成：</p> 
 <ul><li><p><strong>抽象处理者（Handler）角色：</strong> 定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</p></li><li><p><strong>具体处理者（Concrete Handler）角色：</strong> 实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</p></li><li><p><strong>客户类（Client）角色：</strong> 创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p></li></ul> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/28/e8/ZsfJJZ2K_o.png" alt="d57d63407f95a1034ff916319efb9ea5.png"></p> 
 <pre class="has"><code class="language-go">public abstract class AbstractHandler {

    /**
     * 下一关用当前抽象类来接收
     */
    protected AbstractHandler next;

    public void setNext(AbstractHandler next) {
        this.next = next;
    }

    public abstract int handler();
}

public class FirstPassHandler extends AbstractHandler{

    private int play(){
        return 80;
    }

    @Override
    public int handler(){
        System.out.println("第一关--&gt;FirstPassHandler");
        int score = play();
        if(score &gt;= 80){
            //分数&gt;=80 并且存在下一关才进入下一关
            if(this.next != null){
                return this.next.handler();
            }
        }
        return score;
    }
}

public class SecondPassHandler extends AbstractHandler{

    private int play(){
        return 90;
    }

    public int handler(){
        System.out.println("第二关--&gt;SecondPassHandler");

        int score = play();
        if(score &gt;= 90){
            //分数&gt;=90 并且存在下一关才进入下一关
            if(this.next != null){
                return this.next.handler();
            }
        }

        return score;
    }
}

public class ThirdPassHandler extends AbstractHandler{

    private int play(){
        return 95;
    }

    public int handler(){
        System.out.println("第三关--&gt;ThirdPassHandler");
        int score = play();
        if(score &gt;= 95){
            //分数&gt;=95 并且存在下一关才进入下一关
            if(this.next != null){
                return this.next.handler();
            }
        }
        return score;
    }
}

public class HandlerClient {
    public static void main(String[] args) {

        FirstPassHandler firstPassHandler = new FirstPassHandler();//第一关
        SecondPassHandler secondPassHandler = new SecondPassHandler();//第二关
        ThirdPassHandler thirdPassHandler = new ThirdPassHandler();//第三关

        // 和上面没有更改的客户端代码相比，只有这里的set方法发生变化，其他都是一样的
        firstPassHandler.setNext(secondPassHandler);//第一关的下一关是第二关
        secondPassHandler.setNext(thirdPassHandler);//第二关的下一关是第三关

        //说明：因为第三关是最后一关，因此没有下一关

        //从第一个关卡开始
        firstPassHandler.handler();

    }
}</code></pre> 
 <h4>责任链工厂改造</h4> 
 <p>对于上面的请求链，我们也可以把这个关系维护到配置文件中或者一个枚举中。我将使用枚举来教会大家怎么动态的配置请求链并且将每个请求者形成一条调用链。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/8c/b7/t6Zrxa7Y_o.png" alt="e2074204a62d41d9dc0d165e0037a7ca.png"></p> 
 <pre class="has"><code class="language-go">public enum GatewayEnum {
    // handlerId, 拦截者名称，全限定类名，preHandlerId，nextHandlerId
    API_HANDLER(new GatewayEntity(1, "api接口限流", "cn.dgut.design.chain_of_responsibility.GateWay.impl.ApiLimitGatewayHandler", null, 2)),
    BLACKLIST_HANDLER(new GatewayEntity(2, "黑名单拦截", "cn.dgut.design.chain_of_responsibility.GateWay.impl.BlacklistGatewayHandler", 1, 3)),
    SESSION_HANDLER(new GatewayEntity(3, "用户会话拦截", "cn.dgut.design.chain_of_responsibility.GateWay.impl.SessionGatewayHandler", 2, null)),
    ;

    GatewayEntity gatewayEntity;

    public GatewayEntity getGatewayEntity() {
        return gatewayEntity;
    }

    GatewayEnum(GatewayEntity gatewayEntity) {
        this.gatewayEntity = gatewayEntity;
    }
}

public class GatewayEntity {

    private String name;

    private String conference;

    private Integer handlerId;

    private Integer preHandlerId;

    private Integer nextHandlerId;
}


public interface GatewayDao {

    /**
     * 根据 handlerId 获取配置项
     * @param handlerId
     * @return
     */
    GatewayEntity getGatewayEntity(Integer handlerId);

    /**
     * 获取第一个处理者
     * @return
     */
    GatewayEntity getFirstGatewayEntity();
}

public class GatewayImpl implements GatewayDao {

    /**
     * 初始化，将枚举中配置的handler初始化到map中，方便获取
     */
    private static Map&lt;Integer, GatewayEntity&gt; gatewayEntityMap = new HashMap&lt;&gt;();

    static {
        GatewayEnum[] values = GatewayEnum.values();
        for (GatewayEnum value : values) {
            GatewayEntity gatewayEntity = value.getGatewayEntity();
            gatewayEntityMap.put(gatewayEntity.getHandlerId(), gatewayEntity);
        }
    }

    @Override
    public GatewayEntity getGatewayEntity(Integer handlerId) {
        return gatewayEntityMap.get(handlerId);
    }

    @Override
    public GatewayEntity getFirstGatewayEntity() {
        for (Map.Entry&lt;Integer, GatewayEntity&gt; entry : gatewayEntityMap.entrySet()) {
            GatewayEntity value = entry.getValue();
            //  没有上一个handler的就是第一个
            if (value.getPreHandlerId() == null) {
                return value;
            }
        }
        return null;
    }
}

public class GatewayHandlerEnumFactory {

    private static GatewayDao gatewayDao = new GatewayImpl();

    // 提供静态方法，获取第一个handler
    public static GatewayHandler getFirstGatewayHandler() {

        GatewayEntity firstGatewayEntity = gatewayDao.getFirstGatewayEntity();
        GatewayHandler firstGatewayHandler = newGatewayHandler(firstGatewayEntity);
        if (firstGatewayHandler == null) {
            return null;
        }

        GatewayEntity tempGatewayEntity = firstGatewayEntity;
        Integer nextHandlerId = null;
        GatewayHandler tempGatewayHandler = firstGatewayHandler;
        // 迭代遍历所有handler，以及将它们链接起来
        while ((nextHandlerId = tempGatewayEntity.getNextHandlerId()) != null) {
            GatewayEntity gatewayEntity = gatewayDao.getGatewayEntity(nextHandlerId);
            GatewayHandler gatewayHandler = newGatewayHandler(gatewayEntity);
            tempGatewayHandler.setNext(gatewayHandler);
            tempGatewayHandler = gatewayHandler;
            tempGatewayEntity = gatewayEntity;
        }
    // 返回第一个handler
        return firstGatewayHandler;
    }

    /**
     * 反射实体化具体的处理者
     * @param firstGatewayEntity
     * @return
     */
    private static GatewayHandler newGatewayHandler(GatewayEntity firstGatewayEntity) {
        // 获取全限定类名
        String className = firstGatewayEntity.getConference(); 
        try {
            // 根据全限定类名，加载并初始化该类，即会初始化该类的静态段
            Class&lt;?&gt; clazz = Class.forName(className);
            return (GatewayHandler) clazz.newInstance();
        } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
            e.printStackTrace();
        }
        return null;
    }


}

public class GetewayClient {
    public static void main(String[] args) {
        GetewayHandler firstGetewayHandler = GetewayHandlerEnumFactory.getFirstGetewayHandler();
        firstGetewayHandler.service();
    }
}</code></pre> 
 <h3><br></h3> 
 <blockquote> 
  <blockquote> 
   <p><strong>结语</strong></p> 
  </blockquote> 
 </blockquote> 
 <p>设计模式有很多，责任链只是其中的一种，我觉得很有意思，非常值得一学。设计模式确实是一门艺术，仍需努力呀！</p> 
 <hr> 
 <p><strong>推荐全新学习项目</strong></p> 
 <p>全新<a href="" rel="nofollow"><strong>基于</strong><strong>springboot+vue+vant的前后端分离的微商城项目</strong></a>，包括手机端微商城项目和后台管理系统，整个电商购物流程已经能流畅支持，涵盖商品浏览、搜索、商品评论、商品规格选择、加入购物车、立即购买、下单、订单支付、后台发货、退货等。功能强大，主流技术栈，非常值得学习。</p> 
 <p>线上演示：https://www.markerhub.com/vueshop</p> 
 <p><img src="https://images2.imgbox.com/40/8b/p72wyRk0_o.jpg" alt="d59c7e55b7d4016b94182593a423cda3.jpeg"></p> 
 <p>从文档到视频、接口调试、学习看板等方面，让项目学习更加容易，内容更加沉淀。全套<a href="" rel="nofollow"><strong>视频教程</strong></a><strong>约35小时</strong>，<strong>共222期</strong>，讲解非常详细细腻。下面详细为大家介绍：</p> 
 <h5>架构与业务</h5> 
 <p>使用主流的技术架构，真正手把手教你从0到1如何搭建项目手脚架、项目架构分析、建表逻辑、业务分析、实现等。涵盖SpringBoot、Mybatis Plus、Jwt、Redis、Lombok、Hutool、Shiro、Elasticsearch、RabbitMq、Docker、Jenkins等技术。</p> 
 <p>vueshop微商城的整个购物流程已经完善，各个模块的业务都是已经实现，涵盖商品模块、搜索模块、购物车模块、订单模块、退款模块、后台权限模块、业务数据管理模块等</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/45/62/ztc3zzTF_o.png" alt="a1c3cb1549d0fa5c748a8a3c238d296a.png"></p> 
 <p>更多详情请查看：</p> 
 <p><a href="" rel="nofollow"><strong>手把手教学，从0开发前后端微商城项目，主流Java技术一网打尽！</strong></a><br></p> 
 <p><a href="" rel="nofollow"><strong>手把手教学，从0开发前后端微商城项目，主流Java技术一网打尽！</strong></a><br></p> 
 <p><a href="" rel="nofollow"><strong>手把手教学，从0开发前后端微商城项目，主流Java技术一网打尽！</strong></a></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd5c05098ebb716862dd34d7c786dea6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在Ubuntu中查看内存使用情况？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58ce21dcc986ac5e3d9ae0fdd2afc863/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络安全（黑客）—2024自学</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>