<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ZMQ简介 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ZMQ简介" />
<meta property="og:description" content="一、ZeroMQ的背景介绍
官方： “ZMQ(以下ZeroMQ简称ZMQ)是一个简单好用的传输层，像框架一样的一个socket library，他使得Socket编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分，之后进入Linux内核”。现在还未看到它们的成功。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD套接字之上的一 层封装。ZMQ让编写高性能网络应用程序极为简单和有趣。”
与其他消息中间件相比，ZMQ并不像是一个传统意义上的消息队列服务器，事实上，它也根本不是一个服务器，它更像是一个底层的网络通讯库，在Socket API之上做了一层封装，将网络通讯、进程通讯和线程通讯抽象为统一的API接口。
二、ZMQ是什么
阅读了ZMQ的Guide文档后，我的理解是，这是个类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），而ZMQ却是可以N：M 的关系，人们对BSD套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等，而ZMQ屏蔽了这些细节，让你的网络编程更为简单。ZMQ用于node与node间的通信，node可以是主机或者是进程。
三、三种模型
a) 应答模式：
使用REQ-REP套接字发送和接受消息是需要遵循一定规律的。客户端首先使用zmq_send()发送消息，再用zmq_recv()接收，如此循环。如果打乱了这个顺序（如连续发送两次）则会报错。类似地，服务端必须先进行接收，后进行发送。
b) 订阅发布模式
PUB-SUB套接字组合是异步的。客户端在一个循环体中使用recv ()接收消息，如果向SUB套接字发送消息则会报错；类似地，服务端可以不断地使用send ()发送消息，但不能再PUB套接字上使用recv ()。
关于PUB-SUB套接字，还有一点需要注意：你无法得知SUB是何时开始接收消息的。就算你先打开了SUB套接字，后打开PUB发送消息，这时SUB还是会丢失一些消息的，因为建立连接是需要一些时间的。很少，但并不是零。解决此问题需要在PUB端加入sleep。
c) 基于分布式处理（管道模式）
这篇博客对ZMQ有一个初步的介绍，下篇博客介绍如何通过JAVA来调用ZMQ实现消息处理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8b6545754219e523b81d93bc4727cac9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-07-28T22:10:49+08:00" />
<meta property="article:modified_time" content="2014-07-28T22:10:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ZMQ简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-family:Microsoft YaHei;font-size:14px;">一、ZeroMQ的背景介绍</span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">官方： “ZMQ(以下ZeroMQ简称ZMQ)是一个简单好用的传输层，像框架一样的一个socket library，他使得Socket编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分，之后进入Linux内核”。现在还未看到它们的成功。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD套接字之上的一 层封装。ZMQ让编写高性能网络应用程序极为简单和有趣。”</span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">与其他消息中间件相比，ZMQ并不像是一个传统意义上的消息队列服务器，事实上，它也根本不是一个服务器，它更像是一个底层的网络通讯库，在Socket API之上做了一层封装，将网络通讯、进程通讯和线程通讯抽象为统一的API接口。</span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">二、ZMQ是什么</span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">阅读了ZMQ的Guide文档后，我的理解是，这是个类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），而ZMQ却是可以N：M 的关系，人们对BSD套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等，而ZMQ屏蔽了这些细节，让你的网络编程更为简单。ZMQ用于node与node间的通信，node可以是主机或者是进程。</span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">三、三种模型</span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">a)    应答模式：</span></p> 
<p style="text-align: center;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img src="https://images2.imgbox.com/2c/9b/XNpiIOS7_o.png" alt=""><br></span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">使用REQ-REP套接字发送和接受消息是需要遵循一定规律的。客户端首先使用zmq_send()发送消息，再用zmq_recv()接收，如此循环。<span style="color:red;">如果打乱了这个顺序（如连续发送两次）则会报错</span>。类似地，服务端必须先进行接收，后进行发送。</span></p> 
<p align="center"></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">b)    订阅发布模式</span></p> 
<p style="text-align: center;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img src="https://images2.imgbox.com/77/fc/5zscQh7W_o.png" alt=""><br></span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">PUB-SUB套接字组合是异步的。客户端在一个循环体中使用recv ()接收消息，如果向SUB套接字发送消息则会报错；类似地，服务端可以不断地使用send ()发送消息，但不能再PUB套接字上使用recv ()。</span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">关于PUB-SUB套接字，<span style="color:red;">还有一点需要注意：你无法得知SUB</span>是何时开始接收消息的。就算你先打开了SUB套接字，后打开PUB发送消息，这时SUB还是会丢失一些消息的，因为建立连接是需要一些时间的。很少，但并不是零。解决此问题需要在PUB端加入sleep。</span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;"> </span></p> 
<p align="center"></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">c)     基于分布式处理（管道模式）</span></p> 
<p align="center"></p> 
<p style="text-align: center;"><span style="font-family:Microsoft YaHei;font-size:14px;"> <img src="https://images2.imgbox.com/07/ed/FsRRIuV6_o.png" alt=""></span></p> 
<p><span style="font-family:Microsoft YaHei;font-size:14px;">这篇博客对ZMQ有一个初步的介绍，下篇博客介绍如何通过JAVA来调用ZMQ实现消息处理。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d2eb0d5148e545d6fb86a7ee27e1756/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JVM实用参数（八）GC日志</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d940052591c991133fc5c39f4099cc39/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java调用ZMQ</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>