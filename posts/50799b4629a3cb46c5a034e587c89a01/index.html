<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Android基础篇】SQLite数据库的增删改查基本操作 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Android基础篇】SQLite数据库的增删改查基本操作" />
<meta property="og:description" content="一、概述 SQLite是Android系统的核心数据存储服务之一，它是一个轻型的嵌入式数据库，占用非常少的资源却能提供很好很快的数据存取服务，许多大型的需要数据存储的Android项目都有用到SQLite（也可以用于桌面应用程序）。
下面介绍一下SQLite的创建数据库、表的操作，以及基本的增删改查操作。
二、基本操作API简介 在Android中，SQLiteDatabase类提供了SQLite的底层API，但在使用SQLite数据库时，我们往往不会直接操作SQLiteDatabase这个类，而是自己创建一个继承自SQLitOpenHelper的子类来实现数据库操作。这样做的目的一是为了以后如果数据库升级不至于要改动太多代码，已实现封装；二则是为了我们使用更方便。
1、创建数据库和表 SQLiteOpenHelper是一个抽象类，在这个类里有两个抽象方法，OnCreate和OnUpgrade，前者用于第一次创建数据库，后者用于数据库升级，创建类DBServices如下：
public class DBServices extends SQLiteOpenHelper{ final static int version = 1; final static String dbName = &#34;plan&#34;; public DBServices(Context context){ super(context,dbName,null,version); } @Override public void onCreate(SQLiteDatabase db) { // TODO Auto-generated method stub //创建今日计划表 String create_today_plan_sql = &#34;CREATE TABLE [_today_plan] (&#34; &#43; &#34;[_Date] varchar(10) not null,&#34; &#43; &#34;[Item] varchar(200),&#34; &#43; &#34;[Check] varchar(5) )&#34;; db.execSQL(create_today_plan_sql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { // TODO Auto-generated method stub } } 示例里定义两个变量，一个是数据库的版本号，一个是数据库名。当Android应用运行时，SQLiteOpenHelper会先检查是否已经存在数据库，如果不存在，就创建数据库，然后打开数据库，最后调用OnCreate方法，所以我们需要再OnCreate中创建表（视图等）；如果数据库已存在，而版本号比上次创建的数据库版本号高，就调用OnUpgrade，用于升级。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/50799b4629a3cb46c5a034e587c89a01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-03-31T02:30:40+08:00" />
<meta property="article:modified_time" content="2015-03-31T02:30:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Android基础篇】SQLite数据库的增删改查基本操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="一概述">一、概述</h3> 
<p>SQLite是Android系统的核心数据存储服务之一，它是一个轻型的嵌入式数据库，占用非常少的资源却能提供很好很快的数据存取服务，许多大型的需要数据存储的Android项目都有用到SQLite（也可以用于桌面应用程序）。</p> 
<p>下面介绍一下SQLite的创建数据库、表的操作，以及基本的增删改查操作。</p> 
<h3 id="二基本操作api简介">二、基本操作API简介</h3> 
<p>在Android中，SQLiteDatabase类提供了SQLite的底层API，但在使用SQLite数据库时，我们往往不会直接操作SQLiteDatabase这个类，而是自己创建一个继承自SQLitOpenHelper的子类来实现数据库操作。这样做的目的一是为了以后如果数据库升级不至于要改动太多代码，已实现封装；二则是为了我们使用更方便。</p> 
<h4 id="1创建数据库和表">1、创建数据库和表</h4> 
<p>SQLiteOpenHelper是一个抽象类，在这个类里有两个抽象方法，OnCreate和OnUpgrade，前者用于第一次创建数据库，后者用于数据库升级，创建类DBServices如下：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBServices</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span>{<!-- --></span>

    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> version = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String dbName = <span class="hljs-string">"plan"</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-title">DBServices</span>(Context context){
        <span class="hljs-keyword">super</span>(context,dbName,<span class="hljs-keyword">null</span>,version);
    }
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(SQLiteDatabase db) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        <span class="hljs-comment">//创建今日计划表</span>
        String create_today_plan_sql = <span class="hljs-string">"CREATE TABLE [_today_plan] ("</span>
                + <span class="hljs-string">"[_Date] varchar(10) not null,"</span> 
                + <span class="hljs-string">"[Item] varchar(200),"</span>
                + <span class="hljs-string">"[Check] varchar(5) )"</span>;
        db.execSQL(create_today_plan_sql);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span>(SQLiteDatabase db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>

    }
}</code></pre> 
<p>示例里定义两个变量，一个是数据库的版本号，一个是数据库名。当Android应用运行时，SQLiteOpenHelper会先检查是否已经存在数据库，如果不存在，就创建数据库，然后打开数据库，最后调用OnCreate方法，所以我们需要再OnCreate中创建表（视图等）；如果数据库已存在，而版本号比上次创建的数据库版本号高，就调用OnUpgrade，用于升级。</p> 
<h4 id="2数据的增insert">2、数据的增——insert</h4> 
<p>在创建了数据库和表之后，我们就可以给数据库和表添加数据了。 <br> 添加数据的操作和其他数据库一样，也是使用insert，只是SQLite的insert是函数，而且使用起来非常方便，下面是方法（属于上面的DBServices类，附录里有完整代码）：</p> 
<pre class="prettyprint"><code class=" hljs sql">public void <span class="hljs-operator"><span class="hljs-keyword">insert</span>(String <span class="hljs-keyword">table</span>, String nullColumnHack, ContentValues <span class="hljs-keyword">values</span>){

        SQLiteDatabase db = this.getWritableDatabase();</span>
        db.<span class="hljs-operator"><span class="hljs-keyword">insert</span>(<span class="hljs-keyword">table</span>, nullColumnHack, <span class="hljs-keyword">values</span>);</span>
    }</code></pre> 
<blockquote> 
 <p>参数说明： <br> table：表名，直接使用字符串指定； <br> nullColumnHack：指定null值的列，SQLite里不允许空行，使用这个参数可以指定一个列的值为null，当存入行为空时，这个列的值就被指定为null； <br> values：使用类似map键值对映射的数据结构ContentValues来指定插入的数据</p> 
</blockquote> 
<p>添加数据示例：</p> 
<pre class="prettyprint"><code class=" hljs javascript">            <span class="hljs-built_in">String</span>[] args = {
                    today,
                    content,
                    <span class="hljs-built_in">Boolean</span>.toString(checked)
            };
            <span class="hljs-built_in">String</span>[] column = {
                    <span class="hljs-string">"[_Date]"</span>,
                    <span class="hljs-string">"[Item]"</span>,
                    <span class="hljs-string">"[Check]"</span>
            };
            <span class="hljs-comment">//数据库中添加数据</span>
            ContentValues c = <span class="hljs-keyword">new</span> ContentValues();
            <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;args.length;i++){
                c.put(column[i], args[i]);
            }
            dbServices.insert(<span class="hljs-string">"_today_plan"</span>, <span class="hljs-literal">null</span>, c);</code></pre> 
<h4 id="3数据的删delete">3、数据的删——delete</h4> 
<p>删除和添加一样，也是通过传入参数调用方法来实现，方法：</p> 
<pre class="prettyprint"><code class=" hljs javascript">public <span class="hljs-keyword">void</span> <span class="hljs-keyword">delete</span>(<span class="hljs-built_in">String</span> table , <span class="hljs-built_in">String</span> whereClause , <span class="hljs-built_in">String</span>[] whereArgs){
        SQLiteDatabase db = <span class="hljs-keyword">this</span>.getWritableDatabase();
        db.delete(table, whereClause, whereArgs);
        Log.d(<span class="hljs-string">"Delete"</span>,whereClause);
    }</code></pre> 
<blockquote> 
 <p>参数说明： <br> table：表名； <br> whereClause：可选，指定删除条件，相当于SQL语句WHERE语句之后的类容，可通过？来指定参数； <br> whereArgs：当whereClause指定了？参数，这个字符串数组里就是？所代表的参数，个数应与？数一致；</p> 
</blockquote> 
<p>删除数据示例：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> args[] ={
    today,
        content,
        <span class="hljs-built_in">Boolean</span>.toString(checked)
};
dbServices.delete(<span class="hljs-string">"_today_plan"</span>, <span class="hljs-string">"[_Date]=? and [Item]=? and [Check]=?"</span>
,args);</code></pre> 
<h4 id="4数据的修改update">4、数据的修改——update</h4> 
<p>修改与添加、删除相差不多，下面是update方法：</p> 
<pre class="prettyprint"><code class=" hljs sql">public void <span class="hljs-operator"><span class="hljs-keyword">update</span>(String <span class="hljs-keyword">table</span>, ContentValues <span class="hljs-keyword">values</span>,
        String whereClause, String[] whereArgs){
        SQLiteDatabase db = this.getWritableDatabase();</span>
        db.<span class="hljs-operator"><span class="hljs-keyword">update</span>(<span class="hljs-keyword">table</span>, <span class="hljs-keyword">values</span>, whereClause, whereArgs);</span>
    }</code></pre> 
<blockquote> 
 <p>参数说明： <br> table：表名； <br> values：同上，是需要修改的列和值的映射集合； <br> whereClause：修改的行所需符合的条件； <br> whereArgs：指定条件里的参数；</p> 
</blockquote> 
<p>修改数据示例：</p> 
<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> args[] ={
    today,
        content,
        <span class="hljs-built_in">Boolean</span>.toString(!m)
};
ContentValues c = <span class="hljs-keyword">new</span> ContentValues();
c.put(<span class="hljs-string">"[Check]"</span>, <span class="hljs-built_in">Boolean</span>.toString(m));
dbServices.update(<span class="hljs-string">"_today_plan"</span>, c,<span class="hljs-string">"[_Date]=? and [StartTime]=? and [Item]=? and [Check]=?"</span>
,args);</code></pre> 
<h4 id="5数据的查询read">5、数据的查询——read</h4> 
<p>在这里就和前面有所不同了，读取数据所用的方法是直接执行查询语句，获取游标，然后通过游标来遍历数据库，方法如下：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> Cursor <span class="hljs-title">read</span>(String sql ,String[] args){
        SQLiteDatabase db = <span class="hljs-keyword">this</span>.getReadableDatabase();
        Cursor cursor = db.rawQuery(sql, args);
        Log.d(<span class="hljs-string">"Database"</span>,cursor.getColumnName(<span class="hljs-number">0</span>));
        <span class="hljs-keyword">return</span> cursor;
    }</code></pre> 
<blockquote> 
 <p>方法说明： <br> 请注意：在这里db获取的是只读的数据库（getReadableDatabase），而在上述三种操作里都是使用的可写数据库（getWritableDatabase）；至于游标的用法此处就不再赘述，只需看一下API的名字就能掌握基本用法，但最后一定要记得将游标关闭（close）！</p> 
</blockquote> 
<h3 id="三附录">三、附录</h3> 
<p>附录了DBServices类，仅作参考</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> com.plan;

<span class="hljs-keyword">import</span> android.content.ContentValues;
<span class="hljs-keyword">import</span> android.content.Context;
<span class="hljs-keyword">import</span> android.database.Cursor;
<span class="hljs-keyword">import</span> android.database.sqlite.SQLiteDatabase;
<span class="hljs-keyword">import</span> android.database.sqlite.SQLiteOpenHelper;
<span class="hljs-keyword">import</span> android.util.Log;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBServices</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span>{<!-- --></span>

    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> version = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String dbName = <span class="hljs-string">"plan"</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-title">DBServices</span>(Context context){
        <span class="hljs-keyword">super</span>(context,dbName,<span class="hljs-keyword">null</span>,version);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(SQLiteDatabase db) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        <span class="hljs-comment">//创建今日计划表</span>
        String create_today_plan_sql = <span class="hljs-string">"CREATE TABLE [_today_plan] ("</span>
                + <span class="hljs-string">"[_Date] varchar(10) not null,"</span> 
                + <span class="hljs-string">"[Item] varchar(200),"</span>
                + <span class="hljs-string">"[Check] varchar(5) )"</span>;
        db.execSQL(create_today_plan_sql);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span>(SQLiteDatabase db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>

    }

    <span class="hljs-keyword">public</span> Cursor <span class="hljs-title">read</span>(String sql ,String[] args){
        SQLiteDatabase db = <span class="hljs-keyword">this</span>.getReadableDatabase();
        Cursor cursor = db.rawQuery(sql, args);
        Log.d(<span class="hljs-string">"Database"</span>,cursor.getColumnName(<span class="hljs-number">0</span>));
        <span class="hljs-keyword">return</span> cursor;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span>(String table, String nullColumnHack, ContentValues values){

        SQLiteDatabase db = <span class="hljs-keyword">this</span>.getWritableDatabase();
        db.insert(table, nullColumnHack, values);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span>(String table , String whereClause , String[] whereArgs){
        SQLiteDatabase db = <span class="hljs-keyword">this</span>.getWritableDatabase();
        db.delete(table, whereClause, whereArgs);
        Log.d(<span class="hljs-string">"Delete"</span>,whereClause);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(String table, ContentValues values,
        String whereClause, String[] whereArgs){
        SQLiteDatabase db = <span class="hljs-keyword">this</span>.getWritableDatabase();
        db.update(table, values, whereClause, whereArgs);
    }

}
</code></pre> 
<p>有关SQLite的高级特性，如索引、视图以及触发器等，大家可以去看看SQlite的官方文档。</p> 
<p>上述类在手机重启时，数据库会重新创建，原因是数据库没有关闭（但因为要提供游标，所以控制起来会比较困难），所以这里提出一个解决办法，就是数据库的操作（建表、增、删、改）均使用事务方式，示例如下：</p> 
<pre class="prettyprint"><code class=" hljs cs">db.beginTransaction();          <span class="hljs-comment">//事务开始</span>

<span class="hljs-comment">//建表、增、删、改、查</span>

db.setTransactionSuccessful();      <span class="hljs-comment">//事务成功</span>
db.endTransaction();                <span class="hljs-comment">//提交事务</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c5ca74ec2f63b406028d1807858a5252/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">孙楠失算的决赛秀</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61e6386576ef4df00baa33d195856785/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MODIS数据介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>