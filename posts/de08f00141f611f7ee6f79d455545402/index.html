<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux内存管理第四章 -- 进程地址空间（Process Address Space） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux内存管理第四章 -- 进程地址空间（Process Address Space）" />
<meta property="og:description" content="文章目录 Linux内存管理第四章 -- 进程地址空间（Process Address Space）Linear Address SpaceManaging the Address SpaceProcess Address Space DescriptorAllocating a DescriptorInitialising a DescriptorDestroying a Descriptor Memory RegionsMemory Region OperationsFile/Device backed memory regions Page FaultingHandling a Page FaultDemand AllocationHandling anonymous pagesHandling file/device backed pages Demand PagingCopy On Write (COW) Pages Copying To/From Userspace Linux内存管理第四章 – 进程地址空间（Process Address Space） Linear Address Space 从user的观点来看，地址空间是一块平坦的线性地址空间，但可以预见的是从kernel的观点来看，地址空间却大有不同。虚拟地址空间被分割成两部分，userspace部分随着进程上下文的切换而改变但kernel space的部分始终保持不变。虚拟地址空间被切割的位置有宏PAGE_OFFSET决定，在x86上PAGE_OFFSET = 0xC0000000。即用户进程可用的虚拟地址空间是3GB，而另外1GB始终有kernel使用。kernel space的线性虚拟地址的概略图如下：
从PAGE_OFFSET开始的8MB(两个PGD所映射的内存空间)预留起来用于加载Linux内核镜像。对于UMA来说，在kernel image后有很短的间隔之后存放的是全局变量mem_map的地址。而mem_map的地址通常是16MB的位置从而避免使用ZONE_DMA，但也不是总是如此。而NUMA架构下，虚拟mem_map的部分内容将分散在该区域，其具体的位置有各架构决定。例如在X86下，硬件架构指定每个node的lmem_map的地址在数组node_remap_start_vaddr中，然后将node_remap_start_vaddr中的第一个地址赋值给mem_map。
Managing the Address Space 每个进程的进程描述符struct task_struct中的struct mm_struct用来管理用户虚拟地址空间。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/de08f00141f611f7ee6f79d455545402/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-13T10:18:14+08:00" />
<meta property="article:modified_time" content="2020-02-13T10:18:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux内存管理第四章 -- 进程地址空间（Process Address Space）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Linux__Process_Address_Space_1" rel="nofollow">Linux内存管理第四章 -- 进程地址空间（Process Address Space）</a></li><li><ul><li><a href="#Linear_Address_Space_2" rel="nofollow">Linear Address Space</a></li><li><a href="#Managing_the_Address_Space_6" rel="nofollow">Managing the Address Space</a></li><li><a href="#Process_Address_Space_Descriptor_12" rel="nofollow">Process Address Space Descriptor</a></li><li><ul><li><a href="#Allocating_a_Descriptor_82" rel="nofollow">Allocating a Descriptor</a></li><li><a href="#Initialising_a_Descriptor_86" rel="nofollow">Initialising a Descriptor</a></li><li><a href="#Destroying_a_Descriptor_104" rel="nofollow">Destroying a Descriptor</a></li></ul> 
   </li><li><a href="#Memory_Regions_121" rel="nofollow">Memory Regions</a></li><li><ul><li><a href="#Memory_Region_Operations_176" rel="nofollow">Memory Region Operations</a></li><li><a href="#FileDevice_backed_memory_regions_206" rel="nofollow">File/Device backed memory regions</a></li></ul> 
   </li><li><a href="#Page_Faulting_277" rel="nofollow">Page Faulting</a></li><li><ul><li><a href="#Handling_a_Page_Fault_305" rel="nofollow">Handling a Page Fault</a></li><li><a href="#Demand_Allocation_314" rel="nofollow">Demand Allocation</a></li><li><ul><li><a href="#Handling_anonymous_pages_316" rel="nofollow">Handling anonymous pages</a></li><li><a href="#Handling_filedevice_backed_pages_322" rel="nofollow">Handling file/device backed pages</a></li></ul> 
    </li><li><a href="#Demand_Paging_326" rel="nofollow">Demand Paging</a></li><li><a href="#Copy_On_Write_COW_Pages_330" rel="nofollow">Copy On Write (COW) Pages</a></li></ul> 
   </li><li><a href="#Copying_ToFrom_Userspace_334" rel="nofollow">Copying To/From Userspace</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Linux__Process_Address_Space_1"></a>Linux内存管理第四章 – 进程地址空间（Process Address Space）</h2> 
<h3><a id="Linear_Address_Space_2"></a>Linear Address Space</h3> 
<p>从user的观点来看，地址空间是一块平坦的线性地址空间，但可以预见的是从kernel的观点来看，地址空间却大有不同。虚拟地址空间被分割成两部分，userspace部分随着进程上下文的切换而改变但kernel space的部分始终保持不变。虚拟地址空间被切割的位置有宏PAGE_OFFSET决定，在x86上PAGE_OFFSET = 0xC0000000。即用户进程可用的虚拟地址空间是3GB，而另外1GB始终有kernel使用。kernel space的线性虚拟地址的概略图如下：<br> <img src="https://images2.imgbox.com/34/31/fL8Bjl0b_o.png" alt="111111"><br> 从PAGE_OFFSET开始的8MB(两个PGD所映射的内存空间)预留起来用于加载Linux内核镜像。对于UMA来说，在kernel image后有很短的间隔之后存放的是全局变量mem_map的地址。而mem_map的地址通常是16MB的位置从而避免使用ZONE_DMA，但也不是总是如此。而NUMA架构下，虚拟mem_map的部分内容将分散在该区域，其具体的位置有各架构决定。例如在X86下，硬件架构指定每个node的lmem_map的地址在数组node_remap_start_vaddr中，然后将node_remap_start_vaddr中的第一个地址赋值给mem_map。</p> 
<h3><a id="Managing_the_Address_Space_6"></a>Managing the Address Space</h3> 
<p>每个进程的进程描述符struct task_struct中的struct mm_struct用来管理用户虚拟地址空间。<br> 每个地址空间有一系列页对齐的区域组成，这些区域不会重叠该区域代表一组地址，其中的page是相互关联的，这些区域用struct vm_area_struct来描述，一个region可能表示一个进程的堆供malloc()使用，也可能代表一个映射的文件如动态链接库。region中page仍然需要分配，设置active/resident/page out状态。<br> 如果一个region代表一个映射文件，则它的vm_file字段将会被设置。通过遍历vm_file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping,该region相关的address_space将被找到。address_space拥有磁盘上基于page操作所需要的所有信息。<br> 以下是这些structures的关系：<br> <img src="https://images2.imgbox.com/b6/be/zDcmnikj_o.png" alt="mmpa"></p> 
<h3><a id="Process_Address_Space_Descriptor_12"></a>Process Address Space Descriptor</h3> 
<p>一个进程的地址空间由struct mm_struct描述，这也就是说每个进程中只有一个mm_struct其它在用户线程中共享。<br> 一个内核线程并不需要一个唯一的mm_struct,因为内核新城永远不会触发用户地址空间的缺页异常或者访问用户地址空间。但是有一个例外，当page fault发生在vmalloc虚拟地址段内，缺页异常的代码认为这是一个特殊的case，并使用master page table中的信息去更新当前进程的page table。由于内核线程并不需要mm_struct,所以内核线程的task_struct-&gt;mm字段总是NULL。</p> 
<ul><li>lazy TLB<br> 因为刷新TLB缓存代价非常昂贵，所以一种lazy TLB的技术被使用来避免不会访问用户地址空间的进程进行不必要的TLB刷新。因为内核地址空间的总是可见的。当调用switch_mm()会导致TLB刷新，但是它可以通过借用前一个task使用过的mm_struct,并把它放在task_struct-&gt;active_mm中来避免刷新TLB。这种技术极大提高了上下文切换的时间。<br> 当要进入lazy TLB时，需要调用enter_lazy_tlb()来保证mm_struct不会再不同的处理器间共享。第二次需要使用lazy TLB的时候是当进程退出时等待其父进程的捕获会调用start_lazy_tlb().</li></ul> 
<p>mm_struct中有两种引用计数：mm_user和mm_count分别来表示两种类型的使用者。</p> 
<ul><li>mm_user是指正在访问mm_struct中用户地址空间的进程数，如：page table和文件映射。用户空间的线程和swap_out()会增加mm_user的计数来保证mm_struct不会被提前销毁，当mm_user变成0之后，exit_mmap()会删除所有的映射和销毁所有的page table，然后再讲mm_count值减一。</li><li>mm_count是指“匿名使用者”的引用计数。其初始化值为1。一个匿名使用者是指该使用者并不关心mm_struct用户地址空间的部分而仅仅是借用mm_struct.匿名使用者如使用lazy TLB的内核线程。当mm_count变成了0，该mm_struct才可以被安全地销毁。</li></ul> 
<p>使用两种引用计数的原因是当用户空间的映射全部被销毁后，匿名使用者仍然需要mm_struct的情况。没有一个位置可以延时销毁page tables。<br> struct mm_struct的定义如下，下面来看看重点字段的含义：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> mm_struct <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span> mmap<span class="token punctuation">;</span>		<span class="token comment">/* list of VMAs */</span>
	<span class="token keyword">struct</span> rb_root mm_rb<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span> mmap_cache<span class="token punctuation">;</span>	<span class="token comment">/* last find_vma result */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_unmapped_area<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>filp<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> 
	                                     <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> pgoff<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>unmap_area<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span>area<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmap_base<span class="token punctuation">;</span>		<span class="token comment">/* base of mmap area */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> free_area_cache<span class="token punctuation">;</span>		<span class="token comment">/* first hole */</span>
	pgd_t <span class="token operator">*</span> pgd<span class="token punctuation">;</span>
	atomic_t mm_users<span class="token punctuation">;</span>			<span class="token comment">/* How many users with user space? */</span>
	atomic_t mm_count<span class="token punctuation">;</span>			<span class="token comment">/* How many references to "struct mm_struct" (users count as 1) */</span>
	<span class="token keyword">int</span> map_count<span class="token punctuation">;</span>				<span class="token comment">/* number of VMAs */</span>
	<span class="token keyword">struct</span> rw_semaphore mmap_sem<span class="token punctuation">;</span>
	spinlock_t page_table_lock<span class="token punctuation">;</span>		<span class="token comment">/* Protects task page tables and mm-&gt;rss */</span>
	<span class="token keyword">struct</span> list_head mmlist<span class="token punctuation">;</span> <span class="token comment">/* List of all active mm's.  These are globally strung
						      * together off init_mm.mmlist, and are protected by mmlist_lock */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> rss<span class="token punctuation">,</span> total_vm<span class="token punctuation">,</span> locked_vm<span class="token punctuation">,</span> shared_vm<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> exec_vm<span class="token punctuation">,</span> stack_vm<span class="token punctuation">,</span> reserved_vm<span class="token punctuation">,</span> def_flags<span class="token punctuation">;</span>

	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> saved_auxv<span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* for /proc/PID/auxv */</span>
	<span class="token keyword">unsigned</span> dumpable<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>
	cpumask_t cpu_vm_mask<span class="token punctuation">;</span>
	<span class="token comment">/* Architecture-specific MM context */</span>
	mm_context_t context<span class="token punctuation">;</span>
	<span class="token comment">/* Token based thrashing protection. */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> swap_token_time<span class="token punctuation">;</span>
	<span class="token keyword">char</span> recent_pagein<span class="token punctuation">;</span>
	<span class="token comment">/* coredumping support */</span>
	<span class="token keyword">int</span> core_waiters<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> completion <span class="token operator">*</span>core_startup_done<span class="token punctuation">,</span> core_done<span class="token punctuation">;</span>
	<span class="token comment">/* aio bits */</span>
	rwlock_t		ioctx_list_lock<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> kioctx		<span class="token operator">*</span>ioctx_list<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> kioctx		default_kioctx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>mmap:用户地址空间中所有VMA的链表表头</li><li>mm_rb:VMA结构形成的红黑树的跟节点，用于快速查找。</li><li>mmap_cache：调用find_vma()后找到的VMA会放置在该字段，其目的是假想该VMA会快被再次使用。</li><li>pgd：当前进程的PGD</li><li>mm_count，mm_user:详细解释见上小节。</li><li>mmlist：mm_struct通过此字段连接在一起。</li><li>start_code, end_code：当前进程的代码段的起始地址和结束地址</li><li>start_data, end_data：当前进程的数据段的起始地址和结束地址</li><li>start_brk, brk：当前进程堆的起始地址和结束地址</li><li>start_stack：当前进程栈的起始地址</li><li>arg_start, arg_end：当前进程命令行参数的起始地址和结束地址</li><li>env_start, env_end：当前进程环境变量的起始地址和结束地址</li><li>rss：Resident Set Size是指当前进程中存在的page的个数，不包括global zero page。</li><li>total_vm:当前进程所有VMA region所占用的总内存空间大小</li><li>locked_vm:resident page中被lock的个数</li><li>swap_address:当一个进程被全部被换出时，pageout守护进程用来记录上一个被换出的地址</li></ul> 
<h4><a id="Allocating_a_Descriptor_82"></a>Allocating a Descriptor</h4> 
<p>有两个函数用来分配一个mm_struct.</p> 
<ul><li>allocate_mm()该宏函数用来从slab allocator中分配一个mm_struct</li><li>mm_alloc()从slab中分配mm_struct后再调用mm_init(）将其初始化</li></ul> 
<h4><a id="Initialising_a_Descriptor_86"></a>Initialising a Descriptor</h4> 
<p>系统中最初始的mm_struct 叫init_mm，它使用宏INIT_MM()来静态地初始化：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> mm_struct init_mm <span class="token operator">=</span> <span class="token function">INIT_MM</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">define</span> INIT_MM(name) \
{			 					\
	.mm_rb		= RB_ROOT,				\
	.pgd		= swapper_pg_dir, 			\
	.mm_users	= ATOMIC_INIT(2), 			\
	.mm_count	= ATOMIC_INIT(1), 			\
	.mmap_sem	= __RWSEM_INITIALIZER(name.mmap_sem),	\
	.page_table_lock =  SPIN_LOCK_UNLOCKED, 		\
	.mmlist		= LIST_HEAD_INIT(name.mmlist),		\
	.cpu_vm_mask	= CPU_MASK_ALL,				\
	.default_kioctx = INIT_KIOCTX(name.default_kioctx, name),	\
}</span>
</code></pre> 
<p>当初始的mm_struct初始化完成后，新的mm_struct会以它们的父mm_struct为模板而被创建。copy_mm()就是用来复制mm_struct,然后条用mm_init（）来初始化进程特殊的字段。</p> 
<h4><a id="Destroying_a_Descriptor_104"></a>Destroying a Descriptor</h4> 
<p>使用atomic_inc(&amp;mm-&gt;mm_users)来增加mm_struct用户空间的引用计数，相对应的使用mmput()来减少引用计数。如果mm_users的引用计数到达0，exit_mmap()会销毁所有被映射的VMA regions和销毁page tables因此此时已经没有用户空间的使用者了。<br> 此时再来使用mmdrop()来讲mm_count减一，因为所有用户空间的使用者被当成是mm_count中的一个计数。当mm_count变为0后，便可销毁mm_struct 了。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">mmput</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>mm<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">atomic_dec_and_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mm_users<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mmlist_lock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mmlist<span class="token punctuation">)</span><span class="token punctuation">;</span>
		mmlist_nr<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mmlist_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit_aio</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit_mmap</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">put_swap_token</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">mmdrop</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Memory_Regions_121"></a>Memory Regions</h3> 
<p>进程地址空间中全部的地址很少被使用，只有很少的regions被使用。Linux用struct vm_area_struct来描述一个VMA。下面来看看VMA的结构和重要字段的含义：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> vm_area_struct <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> mm_struct <span class="token operator">*</span> vm_mm<span class="token punctuation">;</span>	<span class="token comment">/* The address space we belong to. */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_start<span class="token punctuation">;</span>		<span class="token comment">/* Our start address within vm_mm. */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_end<span class="token punctuation">;</span>		<span class="token comment">/* The first byte after our end address within vm_mm. */</span>
	<span class="token comment">/* linked list of VM areas per task, sorted by address */</span>
	<span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span>vm_next<span class="token punctuation">;</span>
	pgprot_t vm_page_prot<span class="token punctuation">;</span>		<span class="token comment">/* Access permissions of this VMA. */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_flags<span class="token punctuation">;</span>		<span class="token comment">/* Flags, listed below. */</span>
	<span class="token keyword">struct</span> rb_node vm_rb<span class="token punctuation">;</span>
	<span class="token comment">/*
	 * For areas with an address space and backing store,
	 * linkage into the address_space-&gt;i_mmap prio tree, or
	 * linkage to the list of like vmas hanging off its node, or
	 * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.
	 */</span>
	<span class="token keyword">union</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">struct</span> list_head list<span class="token punctuation">;</span>
			<span class="token keyword">void</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>	<span class="token comment">/* aligns with prio_tree_node parent */</span>
			<span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span>head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> vm_set<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> prio_tree_node prio_tree_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> shared<span class="token punctuation">;</span>
	<span class="token comment">/*
	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
	 * list, after a COW of one of the file pages.  A MAP_SHARED vma
	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack
	 * or brk vma (with NULL file) can only be in an anon_vma list.
	 */</span>
	<span class="token keyword">struct</span> list_head anon_vma_node<span class="token punctuation">;</span>	<span class="token comment">/* Serialized by anon_vma-&gt;lock */</span>
	<span class="token keyword">struct</span> anon_vma <span class="token operator">*</span>anon_vma<span class="token punctuation">;</span>	<span class="token comment">/* Serialized by page_table_lock */</span>
	<span class="token comment">/* Function pointers to deal with this struct. */</span>
	<span class="token keyword">struct</span> vm_operations_struct <span class="token operator">*</span> vm_ops<span class="token punctuation">;</span>
	<span class="token comment">/* Information about our backing store: */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_pgoff<span class="token punctuation">;</span>		<span class="token comment">/* Offset (within vm_file) in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */</span>
	<span class="token keyword">struct</span> file <span class="token operator">*</span> vm_file<span class="token punctuation">;</span>		<span class="token comment">/* File we map to (can be NULL). */</span>
	<span class="token keyword">void</span> <span class="token operator">*</span> vm_private_data<span class="token punctuation">;</span>		<span class="token comment">/* was vm_pte (shared mem) */</span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> CONFIG_NUMA</span>
	<span class="token keyword">struct</span> mempolicy <span class="token operator">*</span>vm_policy<span class="token punctuation">;</span>	<span class="token comment">/* NUMA policy for the VMA */</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>vm_mm:当前VMA所属的mm_struct</li><li>vm_start,vm_end:当前VMA的起始和结束地址</li><li>vm_next：地址空间中所有的VMA按照地址大小排序通过此字段单向连接起来</li><li>vm_page_prot:VMA中所有PTE的保护标志位</li><li>vm_flags:一组标志位用来保护和控制VMA的属性</li><li>vm_rb:所有VMA构成的红黑树，用于快速查找</li><li>vm_next_share,vm_ppre_share:基于文件映射的共享VMA使用此字段连接在一起</li><li>vm_ops:此字段包含的函数指针有：open(),close(),nopage()。它们用作与磁盘同步信息。</li><li>vm_pgoff:当一个文件有内存映射时，该字段表示该region中的内容在整个文件中的偏移</li><li>vm_file:此字段指向一个内存映射的struct file结构</li></ul> 
<h4><a id="Memory_Region_Operations_176"></a>Memory Region Operations</h4> 
<p>我们来看下vm_operations_struct的定义：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> vm_operations_struct <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>close<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">struct</span> page <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>nopage<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span> area<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> unused<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中open()和close()每次在region被创建和被删除时被调用。这两个函数只有被很少的设备和一个文件系统以及SystemV使用。其中SystemV共享内存使用open()回调函数来增加VMA的个数。<br> 其中最主要的回调函数是nopage()。当page fault产生是do_no_page()会调用nopage()这个回调函数，该函数的目的是从page cache中拿到page或者分配一个新的page然后返回地址。<br> 大多数的内存映射的文件对应的vma会注册一个vm_opetaionts_struct叫做generic_file_vm_ops,它注册了一个nopage()回调：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> vm_operations_struct generic_file_vm_ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span>nopage		<span class="token operator">=</span> filemap_nopage<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>populate	<span class="token operator">=</span> filemap_populate<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们来看看share memory VMA的operation：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> vm_operations_struct shm_vm_ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span>open	<span class="token operator">=</span> shm_open<span class="token punctuation">,</span>	<span class="token comment">/* callback for a new vm-area open */</span>
	<span class="token punctuation">.</span>close	<span class="token operator">=</span> shm_close<span class="token punctuation">,</span>	<span class="token comment">/* callback for when the vm-area is released */</span>
	<span class="token punctuation">.</span>nopage	<span class="token operator">=</span> shmem_nopage<span class="token punctuation">,</span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> CONFIG_NUMA</span>
	<span class="token punctuation">.</span>set_policy <span class="token operator">=</span> shmem_set_policy<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>get_policy <span class="token operator">=</span> shmem_get_policy<span class="token punctuation">,</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="FileDevice_backed_memory_regions_206"></a>File/Device backed memory regions</h4> 
<p>如果一个VMA对应了一个文件映射，那么通过vm_file字段会找到一个对应的address_space的结构，该结构包含文件系统相关的信息如需要回写到磁盘的脏页。<br> 首先来看下address_space的定义：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> address_space <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> inode		<span class="token operator">*</span>host<span class="token punctuation">;</span>		<span class="token comment">/* owner: inode, block_device */</span>
	<span class="token keyword">struct</span> radix_tree_root	page_tree<span class="token punctuation">;</span>	<span class="token comment">/* radix tree of all pages */</span>
	spinlock_t		tree_lock<span class="token punctuation">;</span>	<span class="token comment">/* and spinlock protecting it */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span>		i_mmap_writable<span class="token punctuation">;</span><span class="token comment">/* count VM_SHARED mappings */</span>
	<span class="token keyword">struct</span> prio_tree_root	i_mmap<span class="token punctuation">;</span>		<span class="token comment">/* tree of private and shared mappings */</span>
	<span class="token keyword">struct</span> list_head	i_mmap_nonlinear<span class="token punctuation">;</span><span class="token comment">/*list VM_NONLINEAR mappings */</span>
	spinlock_t		i_mmap_lock<span class="token punctuation">;</span>	<span class="token comment">/* protect tree, count, list */</span>
	atomic_t		truncate_count<span class="token punctuation">;</span>	<span class="token comment">/* Cover race condition with truncate */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span>		nrpages<span class="token punctuation">;</span>	<span class="token comment">/* number of total pages */</span>
	pgoff_t			writeback_index<span class="token punctuation">;</span><span class="token comment">/* writeback starts here */</span>
	<span class="token keyword">struct</span> address_space_operations <span class="token operator">*</span>a_ops<span class="token punctuation">;</span>	<span class="token comment">/* methods */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span>		flags<span class="token punctuation">;</span>		<span class="token comment">/* error bits/gfp mask */</span>
	<span class="token keyword">struct</span> backing_dev_info <span class="token operator">*</span>backing_dev_info<span class="token punctuation">;</span> <span class="token comment">/* device readahead, etc */</span>
	spinlock_t		private_lock<span class="token punctuation">;</span>	<span class="token comment">/* for use by the address_space */</span>
	<span class="token keyword">struct</span> list_head	private_list<span class="token punctuation">;</span>	<span class="token comment">/* ditto */</span>
	<span class="token keyword">struct</span> address_space	<span class="token operator">*</span>assoc_mapping<span class="token punctuation">;</span>	<span class="token comment">/* ditto */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> address_space_operations <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>writepage<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> page <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">struct</span> writeback_control <span class="token operator">*</span>wbc<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>readpage<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_page<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* Write back some dirty pages from this mapping. */</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>writepages<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> address_space <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> writeback_control <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* Set a page dirty */</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>set_page_dirty<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> page <span class="token operator">*</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>readpages<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>filp<span class="token punctuation">,</span> <span class="token keyword">struct</span> address_space <span class="token operator">*</span>mapping<span class="token punctuation">,</span>
			<span class="token keyword">struct</span> list_head <span class="token operator">*</span>pages<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> nr_pages<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * ext3 requires that a successful prepare_write() call be followed
	 * by a commit_write() call - they must be balanced
	 */</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>prepare_write<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>commit_write<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* Unfortunately this kludge is needed for FIBMAP. Don't use it */</span>
	sector_t <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> address_space <span class="token operator">*</span><span class="token punctuation">,</span> sector_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>invalidatepage<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>releasepage<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> page <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>direct_IO<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> kiocb <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> iovec <span class="token operator">*</span>iov<span class="token punctuation">,</span>
			loff_t offset<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_segs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>writepage：写一个page到磁盘，每个page所对应的文件偏移可以在struct page中找到。</li><li>readpage：从磁盘中读取一个page</li><li>sync_page:将脏页同步到磁盘</li><li>prepare_write:将用户空间的数据copy到要回写磁盘的一个page之前，调用这个函数。</li><li>commit_write:从用户空间copy数据后，该函数用于提交信息到磁盘</li><li>bmap:操作raw IO</li><li>flushpage：保证在释放一个page前没有pending的IO</li><li>releasepage：在释放一个page前，尝试刷新一个page对应的所有buff</li><li>direct_IO：This function is used when performing direct IO to an inode</li><li>direct_fileIO：Used to perform direct IO with a struct file<br> 我们来看看共享内存文件系统的address_space operations:</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> address_space_operations shmem_aops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span>writepage	<span class="token operator">=</span> shmem_writepage<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>set_page_dirty	<span class="token operator">=</span> __set_page_dirty_nobuffers<span class="token punctuation">,</span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> CONFIG_TMPFS</span>
	<span class="token punctuation">.</span>prepare_write	<span class="token operator">=</span> shmem_prepare_write<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>commit_write	<span class="token operator">=</span> simple_commit_write<span class="token punctuation">,</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="Page_Faulting_277"></a>Page Faulting</h3> 
<p>进程线性地址空间中的页不一定要驻留在内存中。例如，进程中的内存分配内核不会立即满足分配对应的物理内存而是将线性地址使用vm_area_struct预留。还比如被交换到磁盘上的page。<br> Linux和其他大多数操作系统一样，拥有按需获取内存的策略，具体的做法是处理不再内存中的page。这就说明仅当硬件触发缺页异常操作系统捕获异常后并分配页，然互才会从磁盘上读取page到内存中。在Linux中，当一个page从交换区置换到主内存中，其后面的多个page页会被同时读入到swap_cache中。<br> 当前主要有两种类型的page fault：major fault 和minor fault。</p> 
<ul><li>major fault是指当执行数据从不得不从磁盘中读取的这种昂贵操作时发生的缺页异常</li><li>minor fault是指除了major fault的缺页异常都是minor fault.</li></ul> 
<p>Linux中处理以下异常的方式：</p> 
<table><thead><tr><th align="left">Exception</th><th align="left">Type</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">vma region合法但page没有分配</td><td align="left">Minor</td><td align="left">从物理地址分配器中分配一个页框</td></tr><tr><td align="left">vma region不合法但在可扩展region的边上如stack</td><td align="left">Minor</td><td align="left">扩展该region并且分配page</td></tr><tr><td align="left">page被换出但在swap缓存中</td><td align="left">Minor</td><td align="left">在进程页表中重新创建page并且丢弃对swap缓存的引用</td></tr><tr><td align="left">page被换出到磁盘介质上了</td><td align="left">Major</td><td align="left">使用PTE中的信息从磁盘上读回page</td></tr><tr><td align="left">写只读页</td><td align="left">Minor</td><td align="left">如果该page是一个COW页，则copy一份并置为可写映射到进程当前地址空间，如果是非法写，则发送SIG_SEGV</td></tr><tr><td align="left">region不合法或者进程没有访问权限</td><td align="left">Error</td><td align="left">发送SIG_SEGV</td></tr><tr><td align="left">缺页异常发生在内核地址空间</td><td align="left">Minor</td><td align="left">如果发生缺页异常的地址是在vmalloc地址空间，那么当前进程的页表将会被主内核页表swapper_pg_dir中的内容更新，这是内核唯一合法的缺页异常</td></tr><tr><td align="left">缺页异常发生在用户地址空间但当前处于内核模式</td><td align="left">Error</td><td align="left">如果缺页异常发生，这就意味着内核系统并没有从用户空间拷贝并且引发缺页异常，这是内核的一个bug</td></tr></tbody></table> 
<p>每种架构都会注册自己的处理缺页异常的函数。虽然这个函数的名称是任意的，但通常的选择是do_page_fault(),其调用草图如下：<br> <img src="https://images2.imgbox.com/f7/09/CGw7hyK1_o.png" alt="1ssds"><br> 该函数中提供了丰富的信息，如发生缺页异常的地址，是简单的地找到不到page还是访问权限的问题，或者是读或者写错误，再或者该地址是用户空间还是内核空间。该函数的作用是要决定当前发生的是哪种错误并如何处理。其流程如下：<br> <img src="https://images2.imgbox.com/d9/c1/qCkdsYhq_o.png" alt="flow"><br> handle_mm_fault()函数来处理用户空间的缺页异常如：COW page，swapped out page等。其返回值的含义：</p> 
<ul><li>1，minor fault</li><li>2，major fault</li><li>0，错误</li><li>other, 则会触发out of memory处理函数</li></ul> 
<h4><a id="Handling_a_Page_Fault_305"></a>Handling a Page Fault</h4> 
<p>一旦缺页处理函数决定当前缺页异常是一个合法的缺页异常，handle_mm_fault()将会被执行。<br> 如下图所示handle_mm_fault()中会根据PTE的属性来选择调用另外三个函数。首先第一步的决定是通过检查PTE是否存在（pte_present()）或者是否已分配(pte_none())。</p> 
<ul><li>Demand Allocation：如果PTE没有被分配及pte_none()返回True，do_no_page() &amp; do_file_page()将被调用来处理Demand Allocation。</li><li>Demend Paging：如果是一个被交换到磁盘中的page，则调用do_swap_page()处理Demend Paging</li><li>COW page：如果是一个写保护的page，且要发生写的动作，则调用do_wp_page()来处理COW page.一个COW page是指被多个进程共享的page直到一个写事件发生然后就copy这个page到写进程的地址空间。一个COW page能够被识别是因为即使PTE有写保护，VMA也会被标记为可写。如果不是一个COW page，因为有写入，该page将会标记为dirty。</li><li>最后如果一个page被读且存在但仍然发生错误，是因为有些架构没有三级页表。在这种case中，就直接新建PTE，然后标记为young。</li></ul> 
<p><img src="https://images2.imgbox.com/f7/5b/eZwVwlqk_o.png" alt="mmp"></p> 
<h4><a id="Demand_Allocation_314"></a>Demand Allocation</h4> 
<p>当一个进程在最开始的时候来访问一个page，系统将会通过do_no_page()函数来分配页并将数据填充到page中。如果当前vma-&gt;vm_ops为NULL，则是匿名page，如果不为NULL，则是file/device backed page。下面分别来看这两种情况：</p> 
<h5><a id="Handling_anonymous_pages_316"></a>Handling anonymous pages</h5> 
<p>当vm_area_struct-&gt;vm_ops字段为空或者没有提供nopage()函数，则调用do_anonymous_page()来处理这次匿名访问。在这种case下只有两种情况first read和first write</p> 
<ul><li>first read：因为是第一次读所以是没有数据的，因此只要把全局的empty_zero_page映射到该地址对应的PTE上，并且该PTE注上写保护。因此当写事件发生时，因为写保护所以会再次发生page fault。在x86中全局empty_zero_page 是在mem_init()中定义的。</li><li>first write：如果是第一次写，则会调用alloc_page()来分配一个空闲的page然后调用clear_user_highpage()将其填0。假设page被成功分配，则mm_struct中rss（Resident Set Size）字段将会加上一。在某些架构下当一个page插入到进程的用户地址空间中时会调用flush_page_to_ram()来保证缓存的相干性。然后将该page插入到LRU list中一边后续内存回收代码可以回收这个page。<br> <img src="https://images2.imgbox.com/00/61/6ogfYMuA_o.png" alt="nopage"></li></ul> 
<h5><a id="Handling_filedevice_backed_pages_322"></a>Handling file/device backed pages</h5> 
<p>如果一个地址有映射一个file或者device，vm_operation_struct中的vm_ops必须提供nopage()函数。nopage()函数负责分配一个page并从磁盘中读出一个page的数据到该内存中。<br> 当返回page之后，首先检查page分配过程中是否出错，再来检查是否有early COW break发生。如果此次的page fault是以此写操作并且VMA的flag中并未设置VM_SHARED,此时即表明一个early COW break发生了。early COW break是在减少该page的引用计数之前，分配一个新page并复制数据。（不太理解…）<br> 然后再检查该PTE是否存在，如果不存在生成PTE并映射到page table中。</p> 
<h4><a id="Demand_Paging_326"></a>Demand Paging</h4> 
<p>当一个page被交换到磁盘中时，do_swap_page()函数负责将该page再读回来。通过PTE中的信息就可以找到该page在swap_cache中的位置。因为一个page可能在多个进程中被共享，所以他们不可能立即被换出到磁盘上，而是把他们放置在swap cache中。<br> 因为有了swap cache的存在，因此当一个page fault发生的时候，该page可能存在于swap cache中。如果确实如此，则增加该page的引用计数然后把它放置到进程的page table中，然后注册一个minor page fault。<br> 如果该page在磁盘上，则调用read_swap_cache_async（）将数据读回，然后再将该page重新放置在进程的page table中。</p> 
<h4><a id="Copy_On_Write_COW_Pages_330"></a>Copy On Write (COW) Pages</h4> 
<p>当fork一个进程的时候，子进程会全部复制父进程的地址空间。但这是一种非常昂贵的操作，因此COW计数被用上了。<br> 在fork的过程中，两个进程的PTE全部标记为只读，因此当有一个写动作发生时，提供会产生一个page fault。Linux之所以能识别COW page是因为尽管PTE是写保护但是其对应的VMA region是可以写的。然后调用do_wp_page()函数来赋值一个page然后将其填充到写进程的地址空间中。使用COW进行fork的时候，page table需要拷贝，而对应的数据不用拷贝。<br> <img src="https://images2.imgbox.com/49/94/XTDu2nQ0_o.png" alt="cow"></p> 
<h3><a id="Copying_ToFrom_Userspace_334"></a>Copying To/From Userspace</h3> 
<p>在进程地址空间中直接访问物理内存时不安全的因为没有办法快速检查地址对应的page是否存在。当进程访问不合法的地址时，Linux依赖MMU上报异常然后通过page fault处理函数来处理异常。在x86 case下，当遇到一个完全无法使用的地址时，有提供一个汇编函数__copy_usr()来追踪异常。当调用search_exception_table()函数时就可以找到对应修复代码的位置。Linux提供了一些宏函函数供内核态程序安全地从用户空间拷贝数据或者拷贝数据到用户空间，常见的有：</p> 
<pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>；
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>；
</code></pre> 
<p>在编译阶段，链接器会在内核代码段__ex_table中创建exception_table,__ex_table段的起始地址为__start___ex_table,结束地址为__stop___ex_table.。exception table中的每一项对应一个结构struct exception_table_entry</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> exception_table_entry <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> insn<span class="token punctuation">,</span> fixup<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>当遇到真正非法的地址，page fault handler会通过search_exception_table()来查找该地址是否有对应的修复代码，如果有就执行修复代码。</p> 
<p>其核心步骤分为三步：</p> 
<ul><li>first：汇编函数负责从用户空间拷贝实际需要size的数据，如果page不存在，page fault将会发生，如果地址合法，则page fault函数会自动处理好</li><li>second：修复代码</li><li>third：通过_ex_table的映射关系，找到修复代码，执行修复代码</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5e97526a9631593d21ee616209b38352/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通过HTTPS使用HttpClient信任所有证书</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b26ce0d08f89cdceb2802aba669acaeb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Homebrew  添加阿里镜像和恢复</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>