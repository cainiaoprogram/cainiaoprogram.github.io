<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android简单适配9.0~12.0 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android简单适配9.0~12.0" />
<meta property="og:description" content="适配6.0~8.0的可以看下这个： 适配Android6.0到8.0详细过程——小白教程 注意：10.0到12.0的都是些网上看到的资料，我就适配到10.0的文件存储，如有不对的，可以留言，我会查阅修改，谢谢0.0
Android 9.0适配： 限制明文传输：
当 SDK 版本大于 API 28 时，默认限制了 HTTP 请求，并出现相关日志
java.net.UnknownServiceException: CLEARTEXT communication to xxx not permitted by network security policy 该问题有两种解决方案：
1、在 AndroidManifest.xml 中 Application 节点添加如下代码
&lt;application android:usesCleartextTraffic=&#34;true&#34;&gt; 2、在 res 目录新建 xml 目录，已建的跳过，在xml目录新建一个network_security_config.xml文件，然后在AndroidManifest.xml 中 Application 添加如下节点代码。
android:networkSecurityConfig=&#34;@xml/network_security_config&#34; network_security_config.xml：
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&#34;true&#34; /&gt; &lt;/network-security-config&gt; 启动Activity：
在9.0 中，不能直接非 Activity 环境中（比如Service，Application）启动 Activity，否则会崩溃报错，
这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标志FLAG_ACTIVITY_NEW_TASK，
Intent intent = new Intent(this, TestActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 适配刘海屏：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ce9d886c35fd2c473523766aff8aa687/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-18T17:55:41+08:00" />
<meta property="article:modified_time" content="2021-11-18T17:55:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android简单适配9.0~12.0</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>适配6.0~8.0的可以看下这个：</h4> 
<h4><a class="link-info" href="https://blog.csdn.net/qq_38306233/article/details/83785911?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163728482616780255269748%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=163728482616780255269748&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-83785911.pc_v2_rank_blog_default&amp;utm_term=6.0&amp;spm=1018.2226.3001.4450" title="适配Android6.0到8.0详细过程——小白教程">适配Android6.0到8.0详细过程——小白教程</a></h4> 
<p><strong>注意：</strong>10.0到12.0的都是些网上看到的资料，我就适配到10.0的文件存储，如有不对的，可以留言，我会查阅修改，谢谢0.0</p> 
<h4>Android 9.0适配：</h4> 
<p>限制明文传输：</p> 
<p>当 SDK 版本大于 API 28 时，默认限制了 HTTP 请求，并出现相关日志</p> 
<pre><code class="language-java">java.net.UnknownServiceException: CLEARTEXT communication to xxx not permitted 
by network security policy</code></pre> 
<p><br> 该问题有两种解决方案：<br> 1、在 AndroidManifest.xml 中 Application 节点添加如下代码</p> 
<pre><code class="language-java">&lt;application android:usesCleartextTraffic="true"&gt;</code></pre> 
<p><br> 2、在 res 目录新建 xml 目录，已建的跳过，在xml目录新建一个network_security_config.xml文件，然后在AndroidManifest.xml 中 Application 添加如下节点代码。</p> 
<pre><code class="language-java">
android:networkSecurityConfig="@xml/network_security_config"</code></pre> 
<p>network_security_config.xml：</p> 
<pre><code class="language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;network-security-config&gt;
    &lt;base-config cleartextTrafficPermitted="true" /&gt;
&lt;/network-security-config&gt;
</code></pre> 
<p>启动Activity：</p> 
<p>在9.0 中，不能直接非 Activity 环境中（比如Service，Application）启动 Activity，否则会崩溃报错，<br> 这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标志FLAG_ACTIVITY_NEW_TASK，</p> 
<pre><code class="language-java">Intent intent = new Intent(this, TestActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);</code></pre> 
<p>适配刘海屏：</p> 
<p>使用开源库NotchAdapter，github地址：<a class="link-info" href="https://github.com/JereChen11/NotchAdapter" title="NotchAdapter">NotchAdapter</a></p> 
<p>当我们需要以<strong>全屏及沉浸</strong>的模式显示我们的页面时，就需要适配刘海屏。</p> 
<p>1、添加依赖：</p> 
<pre><code class="language-java">  //适配刘海屏的adapter
    implementation 'cn.jerechen:notchAdapter:1.0.3'</code></pre> 
<p> 2、在需要适配刘海的Activity中：</p> 
<div> 
 <pre><code class="language-java">//添加  @RequiresApi(api = Build.VERSION_CODES.P) 注解 表示在9.0以上起效
            
            btn_keep_out = findViewById(R.id.btn_keep_out);
            INotchScreen notchScreen = NotchManager.INSTANCE.getNotchScreen();
            if (notchScreen!=null){   //notchScreen不为空代表是刘海屏
                boolean isContainNotch = notchScreen.isContainNotch(this);
                Log.e("MainActivity", "portrait activity isContainNotch : "+isContainNotch);
                notchScreen.getNotchInfo(this, new INotchScreen.NotchInfoCallback() {
                    @Override
                    public void getNotchRect(Rect rect) {
                        Log.e("MainActivity", "Rect Bottom : "+rect.bottom);
                        //将被刘海挡住的 btn_keep_out 向下移动一个 刘海高度 距离
                        RelativeLayout.LayoutParams lp  =
                                (RelativeLayout.LayoutParams) btn_keep_out.getLayoutParams();
                        //在原有的 topMargin 基础上再加上 刘海屏的高度
                        lp.topMargin += rect.bottom;
                        btn_keep_out.setLayoutParams(lp);
                    }
                });
            }</code></pre> 
</div> 
<h4>效果如下：</h4> 
<p>正常无刘海屏：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b6/6f/shwfMEC4_o.jpg" width="1200">​</p> 
<p></p> 
<p>9.0手机模拟有刘海屏：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/1d/87/SSW0dny2_o.jpg" width="1200">​</p> 
<p></p> 
<h4></h4> 
<h4>Android 10.0适配：</h4> 
<p>1、Scoped Storage（分区存储）<br> 在Android 10上即使你拥有了储存空间的读写权限，也无法保证可以正常的进行文件的读写操作。<br> 适配<br> 最简单粗暴的方法就是在AndroidManifest.xml中添加android:requestLegacyExternalStorage="true"来请求使用旧的存储模式。</p> 
<div> 
 <pre><code class="language-java">&lt;application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        android:extractNativeLibs="true"
        android:usesCleartextTraffic="true"
        android:requestLegacyExternalStorage="true"&gt;</code></pre> 
</div> 
<p><br> 2、权限变化<br> 1）在后台运行时访问设备位置信息需要权限（不建议）<br> Android 10 引入了 ACCESS_BACKGROUND_LOCATION 权限（危险权限）。</p> 
<div> 
 <pre><code class="language-java">&lt;uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION"/&gt;</code></pre> 
</div> 
<p>该权限允许应用程序在后台访问位置。如果请求此权限，则还必须请求ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION权限。只请求此权限无效果。</p> 
<p>官方推荐使用前台服务来实现，在前台服务中获取位置信息。</p> 
<p>首先在清单中对应的service中添加 android:foregroundServiceType="location"：    </p> 
<div> 
 <pre><code class="language-java">&lt;service
    android:name="MyNavigationService"
    android:foregroundServiceType="location" ... &gt;
    ...
&lt;/service&gt;</code></pre> 
</div> 
<p>启动前台服务前检查是否具有前台的访问权限：</p> 
<div> 
 <pre><code class="language-java">    boolean permissionApproved = ActivityCompat.checkSelfPermission(this, 
        Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED;

    if (permissionApproved) {
       // 启动前台服务
    } else {
       // 请求前台访问位置权限
    }</code></pre> 
</div> 
<p><br> 如此一来就可以在Service中获取位置信息。</p> 
<p><br> 2）一些电话、蓝牙和WLAN的API需要精确位置权限</p> 
<p>3、后台启动 Activity 的限制（不太需要管，问题不大）<br> 简单解释就是应用处于后台时，无法启动Activity。    这一限制导致最明显的问题就是点击推送信息时，有些应用无法进行正常的跳转（具体的实现问题导致）。所以针对这类问题，可以采取PendingIntent的方式，发送通知时使用setContentIntent方法。</p> 
<p><br> 对于全屏 intent，注意设置最高优先级和添加USE_FULL_SCREEN_INTENT权限，这是一个普通权限。比如微信来语音或者视频通话时，弹出的接听页面就是使用这一功能。</p> 
<div> 
 <pre><code class="language-java"> &lt;uses-permission android:name="android.permission.USE_FULL_SCREEN_INTENT"/&gt;</code></pre> 
</div> 
<p><br> 4、深色主题<br> 适配方法有两种：<br> 1）手动适配（资源替换）（建议使用，可以基本达到预想效果。）</p> 
<p>将Application和Activity的主题修改为集成自Theme.AppCompat.DayNight或者Theme.MaterialComponents.DayNight，就可以对于大部分的控件得到较好的深色模式支持。</p> 
<pre><code class="language-java">  &lt;application
       ...
        android:theme="@style/AppTheme"
        ...
        &gt;</code></pre> 
<div> 
 <pre><code class="language-java">  &lt;!-- Base application theme. --&gt;
    &lt;!--&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;--&gt;
    &lt;style name="AppTheme" parent="Theme.AppCompat.DayNight.NoActionBar"&gt;
        &lt;!-- Customize your theme here. --&gt;
        &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
        &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
        &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;/style&gt;</code></pre> 
</div> 
<ul><li>颜色：新建<code>values-night</code>文件夹，里面是深色模式下的<code>colors.xml</code>文件<img alt="" height="94" src="https://images2.imgbox.com/8e/9a/hNbzblky_o.png" width="472">​</li></ul> 
<p>例如：</p> 
<div> 
 <pre><code class="language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;color name="colorPrimary"&gt;#303030&lt;/color&gt;
    &lt;color name="colorPrimaryDark"&gt;#232323&lt;/color&gt;
    &lt;color name="colorAccent"&gt;#008577&lt;/color&gt;
&lt;/resources&gt;
</code></pre> 
</div> 
<ul><li>图片：新建<code>drawable-night-xxhdpi</code>图片文件夹</li></ul> 
<p>按照ui设计给的深色模式图放进这个文件夹，系统就会在识别到深色模式后加载这个文件夹的资源了。</p> 
<p>关键工具类NightModeUtil：</p> 
<pre><code class="language-java">public class NightModeUtil {

    /**
     * 当前系统是否是深色模式
     */
    public static boolean isNightMode(Context context) {
        int uiMode = context.getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;
        return uiMode == Configuration.UI_MODE_NIGHT_YES;
    }

    /**
     * 获取是否跟随系统，默认true
     */
    public static boolean getSystemMode() {
        return SPUtils.getBoolean(Constants.KEY_MODE_SYSTEM, true);
    }

    public static void setSystemMode(boolean nightMode) {
        SPUtils.putBoolean(Constants.KEY_MODE_SYSTEM, nightMode);
    }

    /**
     * 获取是否设置深色模式，默认false
     */
    public static boolean getNightMode() {
        return SPUtils.getBoolean(Constants.KEY_MODE_NIGHT, false);
    }

    public static void setNightMode(boolean nightMode) {
        SPUtils.putBoolean(Constants.KEY_MODE_NIGHT, nightMode);
    }

    public static void initNightMode() {
        initNightMode(getSystemMode(), getNightMode());
    }

    /**
     * 初始化App深色模式
     *
     * @param systemMode 是否是跟随系统
     * @param nightMode  是否是深色模式
     */
    public static void initNightMode(boolean systemMode, boolean nightMode) {
        if (systemMode) {
            AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM);
        } else {
            if (nightMode) {
                AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);
            } else {
                AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);
            }
        }
    }

    /**
     * 重启App
     */
    public static void restartApp(Activity activity) {
        final Intent intent = App.getInstance().getPackageManager().getLaunchIntentForPackage(App.getInstance().getPackageName());
        if (intent != null) {
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
            activity.startActivity(intent);
            android.os.Process.killProcess(android.os.Process.myPid());
        }
    }
}
</code></pre> 
<h4>在Application里初始化</h4> 
<pre><code>NightModeUtil.initNightMode();</code></pre> 
<h4>切换状态后重启App</h4> 
<pre><code class="language-java">//两个参数分别是 是否跟随系统，是否选择深色模式
NightModeUtil.initNightMode(dayNightSwitch.isChecked, ctvCheckNight.isChecked);
NightModeUtil.restartApp(activity);</code></pre> 
<p>WebView的深色模式设置<br> 引入implementation 'androidx.webkit:webkit:1.2.0'后可轻易的实现WebView的深色模式，不过有兼容问题，这和WebView的版本有关，WebView版本独立于Android版本。(亲测在系统6.0和7.1上无效。)</p> 
<p>在有WebView的Activity的onCarete里加上如下代码：</p> 
<p> </p> 
<pre><code class="language-java">WebSettings webSetting = webView.getSettings();
// 检查是否支持暗模式
if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK)) {
    boolean isAppDarkMode;
    if (NightModeUtil.getSystemMode()) {
        // 是否是跟随系统
        isAppDarkMode = NightModeUtil.isNightMode(this);
    } else {
        isAppDarkMode = NightModeUtil.getNightMode();
    }
    if (isAppDarkMode) {
        WebSettingsCompat.setForceDark(webSetting, WebSettingsCompat.FORCE_DARK_ON);
    } else {
        WebSettingsCompat.setForceDark(webSetting, WebSettingsCompat.FORCE_DARK_OFF);
    }
}
</code></pre> 
<p>这就是跟随系统深色模式做的配置了。</p> 
<p><strong>效果图如下：</strong><img alt="" height="1200" src="https://images2.imgbox.com/02/c1/isSL4jzI_o.jpg" width="1200"></p> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f9/15/5DgSyY0Y_o.jpg" width="1200"></p> 
<p></p> 
<p>2）自动适配（Force Dark）（不建议使用，效果差。）<br> 应用必须选择启用 Force Dark，方法是在其主题背景中设置 android:forceDarkAllowed="true"。<br> 监听深色主题是否开启<br> 首先在清单文件中给对应的Activity配置 android:configChanges="uiMode"：</p> 
<div> 
 <pre><code class="language-java">&lt;activity
    android:name=".MyActivity"
    android:configChanges="uiMode" /&gt;</code></pre> 
</div> 
<p><br> 这样在onConfigurationChanged方法中就可以获取：        </p> 
<div> 
 <pre><code class="language-java">@Override
public void onConfigurationChanged(@NonNull Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    int currentNightMode = newConfig.uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;
    switch (currentNightMode) {
        case Configuration.UI_MODE_NIGHT_NO:
            // 关闭
            break;
        case Configuration.UI_MODE_NIGHT_YES:
            // 开启
            break;
        default:
            break;    
    }
}
</code></pre> 
</div> 
<p><br> 判断深色主题是否开启</p> 
<p>其实和上面onConfigurationChanged方法同理：</p> 
<div> 
 <pre><code class="language-java">public static boolean isNightMode(Context context) {
    int currentNightMode = context.getResources().getConfiguration().uiMode &amp; 
        Configuration.UI_MODE_NIGHT_MASK;
    return currentNightMode == Configuration.UI_MODE_NIGHT_YES;
}</code></pre> 
</div> 
<p><br> 5、标识符和数据<br> 对不可重置的设备标识符实施了限制<br> 从 Android 10 开始，应用必须具有 READ_PRIVILEGED_PHONE_STATE 特许权限才能正常使用以上这些方法。<br>  </p> 
<h4></h4> 
<h4>Android 11 适配：</h4> 
<p><br> 1、分区存储<br> Android 10之前，外部存储区的内容主要以两种形式存在，一种是由应用的包名命名，归属于特定应用目录下的内容，另一种是存储在公共存储区域的内容。</p> 
<p>在Android 10 中，Google首次引入了分区存储，将公共区域划分成了不同的集合，并且在媒体文件和其他文档之间建立了清楚的分割。经过划分之后应用不可以随意访问外部存储区中的文件，而只能访问媒体文件。如果想访问包含更多细节数据的其他文档，应用专门向用户申请有关文档的访问权限。</p> 
<p>分区存储是需要以 Android 10 为目标平台的，系统默认强制执行。</p> 
<p>如果在 AndroidManifest 的application中添加了 requestLegacyExternalStorage=true 标志，就可以不受此限制。</p> 
<p>但是当 target API 更新为 30 后，系统会忽略该配置。</p> 
<p>如果有数据需要迁移，可以在 AndroidManifest 中将 preserveLegacyExternalStorage 属性设为 true ，当用户升级到以 Android 11 为目标平台时，这个配置就会生效。具体而言，这个配置在用户重新安装该应用前都是有效的。<br> 针对以 Android 11 为目标平台的应用 (targetSdkVersion = 30) ，WRITEEXTENRNALSTORAGE 和 WRITEMEDIASTORAGE 不再提供其他任何访问权限 。</p> 
<p>某些应用的核心功能可能需要访问大量的文件，例如文件管理操作、备份和恢复操作等等，此时就需要申请 MANAGEEXTERNALSTORAGE 权限。我们可以通过使用 ACTIONMANAGEALLFILESACCESS_PERMISSION intent 操作将用户引导至一个系统设置页面，让用户为应用授予所有文件的管理权限。</p> 
<p>2、应用包可见性<br> 在 Android 11 之前，我们可以通过 PackageManager.getInstalledPackages(0) 获取其他所有应用的包名等信息。<br> Android 11 为了增加安全性，更好地保护用户的隐私，对应用包的可见性做出了一些改动。</p> 
<p>当 targetSdkVersion 为 30 时，如果我们用getPackageInfo(“another.app”,0) 获取其他应用包信息时 ，会出现 NameNotFoundException 的异常。</p> 
<p>我们可以在 AndroidMainfest 中添加 &lt;queries style="margin: 0px; padding: 0px;"&gt;来适配特定的使用场景：(该配置相当于是添加应用白名单)&lt;/queries&gt;</p> 
<p><br> 3、权限变化<br> 在 Android 11 中，系统为用户的私人数据提供了更多可供选择的授权方式，应用也加大了后台对位置的访问权限限制。</p> 
<p>对应摄像头、位置信息和麦克风这几个数据类型，用户可以授予一次性的临时访问权限。</p> 
<p>只要是在Android 11 上，该限制都会生效，如下 ：<br> 仅使用期间，仅限这一次等。</p> 
<p>这个一次性权限的生效周期指的是：</p> 
<p>应用 Activity 可见期间<br> 应用转为后台后的短时间内<br> 前台服务存活期间<br> 当用户撤销单次授权后，应用进程退出，再次打开之后需要对应用进行重新授权期间</p> 
<p><br> 4、位置权限<br> 在Android10 之前，我们通过ACCESSCOARRSELOCATION 或 ACCESSFINELOCATION(精确位置) 配置即可申请前后台位置权限。</p> 
<p>Android 11将位置权限分为前台和后台两种权限。前文说的主要是前台权限，授权方式没有变化。应用想要申请后台权限，除了需要在清单文件中额外添加 ACCESSBACKGROUNDLOCATION 权限外，还需要应用主动引导用户到指定页面授权。</p> 
<p>5、新功能<br> 增加应用退出原因功能<br> 在Android 11之前，我们想要了解应用退出的原因以及状态，都比较费劲。现 Android 11 引入了 方法：ActivityManager.getHistoricalProcessExitReasons() ，<br> 可以让我们清楚地了解到应用退出的原因。</p> 
<p>6、可变刷新率<br> 应用和游戏现在可以为其窗口设置首选帧率。大多数 Android 设备以 60Hz 的刷新率更新屏幕，但是某些设备支持多种刷新率，例如 90Hz 和 60Hz，并可在运行时切换。在这些设备上，系统会基于首选帧率来为应用选择最佳刷新率。</p> 
<p></p> 
<h4>Android12适配：</h4> 
<p>targetSdkVersion 31的应用在Android 12上安装时可能会存在两种安装不上的情况。</p> 
<div> 
 <pre><code class="language-java">adb: failed to install xxx.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: 
Scanning Failed.: No signature found in package of version 2 or newer for
 package com.tomes.sharefile]
</code></pre> 
</div> 
<p>解决：<br>  targetSdkVersion 30的应用必须使用v2及以上签名<br>  </p> 
<div> 
 <pre><code class="language-java">adb: failed to install xxx.apk: Failure [INSTALL_PARSE_FAILED_MANIFEST_MALFORMED: Failed 
parse during installPackageLI: /data/app/vmdl2054463318.tmp/base.apk (at Binary XML file 
line #49): com.tomes.ShareOpenTestActivity: Targeting S+ (version 10000 and above) requires
 that an explicit value for android:exported be defined when intent filters are present]
</code></pre> 
</div> 
<p>我们知道，当我们的应用以Android 12为目标，使用的activity，service，broadcast receiver含有intent-filter，则必须显示声明android:exported属性，如果没有声明，则我们的应用不能安装在Android 12上</p> 
<p>解决方法：<br> 声明android:exported属性即可解决。</p> 
<p>如我上面的错误，只需要对ShareOpenTestActivity增加android:exported属性申明就好</p> 
<div> 
 <pre><code class="language-java">&lt;activity android:name=".ShareOpenTestActivity" android:exported="true"&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.intent.action.SEND"/&gt;
                &lt;category android:name="android.intent.category.DEFAULT" /&gt;
                &lt;data android:mimeType="text/*" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
</code></pre> 
</div> 
<p>总结：<br> targetSdkVersion为31【以Android 12为目标】的应用务必要加入v2签名，务必要对使用的activity，service，broadcast receiver含有intent-filter，显示声明android:exported属性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2eec2cc8b6d832288ab7a637d3fe4d2a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">思科路由器 密码设置和恢复</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ea26f0a51403527f886adfcfec2b389/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Part6-1-2 uniapp</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>