<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>solidity 特性导致的漏洞 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="solidity 特性导致的漏洞" />
<meta property="og:description" content="目录
1、默认可见性
2、浮点数精度缺失
3、错误的构造函数
4、自毁函数
5、未初始化指针-状态变量覆盖
1、默认可见性 Solidity 的函数和状态变量有四种可见性：external、public、internal、private。函数可见性默认为 public，状态变量可见性默认为 internal。
可见范围：private &lt; internal &lt; external &lt; public
private：只有当前合约可见internal：外部合约不可见，只有当前合约内部和子类合约可见external：只能被外部合约或者外部调用者可见public：公共函数和状态变量对所有智能合约可见 solidity 0.4 版本，函数不设置访问修饰符编译不会报错，函数默认的可见性是 public，如果一下敏感函数没有设置访问修饰符，就可能发生越权函数调用
漏洞场景：
敏感函数忘记设置访问修饰符
漏洞代码示例：
pragma solidity ^0.4.5; contract HashForEther { function withdrawWinnings() { // Winner if the last 8 hex characters of the address are 0. require(uint32(msg.sender) == 0); sendWinnings(); } function sendWinnings() { msg.sender.transfer(this.balance); } } sendWinnings 函数忘记设置函数访问修饰符了，而默认可见性是 public，于是导致任意地址都可以调用改函数而获得转账。
2、浮点数精度缺失 浮点型，定长浮点型——Solidity目前暂时不支持浮点型，也不完全支持定长浮点型。
fixed/ufixed 表示有符号和无符号的定长浮点数，浮点型可以用来声明变量，但不可以用来赋值。
除法运算：除法运算的结果会四舍五入，如果出现小数，小数点后的部分都会被舍弃，只取整数部分
pragma solidity ^0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/421b5e1ccb0cd32faa092a8fb849460d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-14T16:31:21+08:00" />
<meta property="article:modified_time" content="2023-12-14T16:31:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">solidity 特性导致的漏洞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E9%BB%98%E8%AE%A4%E5%8F%AF%E8%A7%81%E6%80%A7-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%BB%98%E8%AE%A4%E5%8F%AF%E8%A7%81%E6%80%A7" rel="nofollow">1、默认可见性</a></p> 
<p id="2%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1" rel="nofollow">2、浮点数精度缺失</a></p> 
<p id="3%E3%80%81%E9%94%99%E8%AF%AF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E9%94%99%E8%AF%AF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">3、错误的构造函数</a></p> 
<p id="4%E3%80%81%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0" rel="nofollow">4、自毁函数</a></p> 
<p id="5%E3%80%81%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E9%92%88-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E9%92%88-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96" rel="nofollow">5、未初始化指针-状态变量覆盖</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1%E3%80%81%E9%BB%98%E8%AE%A4%E5%8F%AF%E8%A7%81%E6%80%A7">1、默认可见性</h3> 
<p>Solidity 的函数和状态变量有四种可见性：external、public、internal、private。函数可见性默认为 public，状态变量可见性默认为 internal。</p> 
<p>可见范围：private &lt; internal &lt; external &lt; public</p> 
<ul><li>private：只有当前合约可见</li><li>internal：外部合约不可见，只有当前合约内部和子类合约可见</li><li>external：只能被外部合约或者外部调用者可见</li><li>public：公共函数和状态变量对所有智能合约可见</li></ul> 
<p>solidity 0.4 版本，函数不设置访问修饰符编译不会报错，函数默认的可见性是 public，如果一下敏感函数没有设置访问修饰符，就可能发生越权函数调用</p> 
<p>漏洞场景：</p> 
<p>敏感函数忘记设置访问修饰符</p> 
<p>漏洞代码示例：</p> 
<pre><code class="language-javascript">pragma solidity ^0.4.5;

contract HashForEther {
    function withdrawWinnings() {
        // Winner if the last 8 hex characters of the address are 0. 
        require(uint32(msg.sender) == 0);
        sendWinnings();
     }

     function sendWinnings() {
         msg.sender.transfer(this.balance);
     }
}</code></pre> 
<p>sendWinnings 函数忘记设置函数访问修饰符了，而默认可见性是 public，于是导致任意地址都可以调用改函数而获得转账。</p> 
<p></p> 
<h3 id="2%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1">2、浮点数精度缺失</h3> 
<p>浮点型，定长浮点型——Solidity目前暂时不支持浮点型，也不完全支持定长浮点型。</p> 
<p>fixed/ufixed 表示有符号和无符号的定长浮点数，浮点型可以用来声明变量，但不可以用来赋值。</p> 
<p>除法运算：除法运算的结果会四舍五入，如果出现小数，小数点后的部分都会被舍弃，只取整数部分</p> 
<pre><code class="language-javascript">pragma solidity ^0.4.0;

contract C {
    uint constant public weiPerEth = 1e18;
    uint public token1;
    uint256 public token2;
    uint256  public token3;

    function testC(uint n1, uint n2) external  {
        token1 = 200 wei / weiPerEth;
        token2 = 80 / 10;
        token3 = n1 /n2;
    }
}</code></pre> 
<p>token1 由于除法运算出现了小数(0.0...02)，取整数部分，变成了0。当 n1 小于 n2 时，如 8/10 ，token3 也将取 0.8 的整数部分，变成 0。</p> 
<p>执行结果：</p> 
<p><img alt="" height="749" src="https://images2.imgbox.com/34/dd/O777SDpR_o.png" width="1113"></p> 
<p>漏洞场景：</p> 
<p>转账发送以太时，以太数量由除法运算结果所得，运算数字可控，可能导致结果精度丢失，最终导致以太丢失</p> 
<p>漏洞示例：</p> 
<pre><code class="language-javascript">pragma solidity ^0.4.23;

contract FunWithNumbers{
    uint constant public tokensPerEth = 10;
    uint constant public weiPerEth = 1e18;
    mapping(address =&gt; uint) public balances;

    function buyTokens() public payable {
        uint tokens = msg.value/weiPerEth * tokensPerEth; // 第一处浮点和精确度问题
        balances[msg.sender] += tokens;
    }

    function sellTokens(uint tokens) public {
        require(balances[msg.sender] &gt;= tokens);
        uint eth = tokens/tokensPerEth;                ?// 第二处浮点和精确度问题
        balances[msg.sender] -= tokens;
        msg.sender.transfer(eth * weiPerEth);
    }
}</code></pre> 
<p></p> 
<h3 id="3%E3%80%81%E9%94%99%E8%AF%AF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3、错误的构造函数</h3> 
<p>在 Solidity 0.4.22 版本之前，在Solidity中的0.4.22版本之前，所有的合约名和构造函数同名。编写合约时，如果构造函数名和合约名不相同，合约会添加一个默认的构造函数，自己设置的构造函数就会被当作普通函数，导致自己原本的合约设置未按照预期执行，从而造成安全漏洞。</p> 
<p>漏洞场景：</p> 
<ol><li>Solidity 0.4.22 前，构造函数与合约名相同，但是大小写不一样</li><li>构造函数错误地声明为了 public 或者 external</li></ol> 
<p>示例 1：</p> 
<pre><code class="language-javascript">pragma solidity ^0.4.20;

contract OwnerWallet {

    address public owner;

    function ownerWallet(address _owner) public {
        owner = _owner;
    }

    function () payable {}

    function withdraw() public {
        require(msg.sender == owner);
        msg.sender.transfer(this.balance);
    }
}</code></pre> 
<p>示例 2：采用更安全的 constructor </p> 
<pre><code class="language-javascript">pragma solidity ^0.4.0;

contract C {
    address owner;
    constructor() public {
        owner = msg.sender;
    }
}</code></pre> 
<p></p> 
<h3 id="4%E3%80%81%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0">4、自毁函数</h3> 
<p>Solidity 智能合约中存在一个 selfdestruct() 自毁函数，该函数可以对创建的合约进行自毁，并且可强制将合约里的 Ether 转到自毁函数定义的地址中。</p> 
<pre><code class="language-javascript">contract DeleteContract {


    constructor() payable {}

    receive() external payable {}

    function deleteContract() external {
        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender
        selfdestruct(payable(msg.sender));
    }

}</code></pre> 
<p>漏洞场景：</p> 
<p>合约限制账户转入的以太数量，而攻击者可以使用自毁函数强制转入任意数量，并且使用 this.balance 作为敏感操作的判断条件</p> 
<p>漏洞示例：</p> 
<pre><code class="language-javascript">contract EtherGame {

    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether; 
    uint public finalMileStone = 10 ether; 
    uint public finalReward = 5 ether; 

    mapping(address =&gt; uint) redeemableEther;
    function play() public payable {
        require(msg.value == 0.5 ether); 
        uint currentBalance = this.balance + msg.value;
        require(currentBalance &lt;= finalMileStone);
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
    }

    function claimReward() public {
        require(this.balance == finalMileStone);
        require(redeemableEther[msg.sender] &gt; 0); 
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
}</code></pre> 
<p>攻击者角度分析</p> 
<p>由于合约设置参与者每次提交的 Ether 数为 0.5，提交多次后就会达到10 Ether，因此攻击者就可以创建带有 selfdestruct() 函数的合约，通过 selfdestruct() 函数强制给它提供 0.1 Ether，当强制转入的 0.1 Ether 进入条件判断，最终的计算数值将永远不会成为整数，this.balance==finalMileStone 判断将永远不会成立，导致参与者永远不会获得奖励。所有参与者的 Ether 就会永远锁在 EtherGame 合约中。</p> 
<p></p> 
<h3 id="5%E3%80%81%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E9%92%88-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96">5、未初始化指针-状态变量覆盖</h3> 
<p>合约中状态变量存储在 storage 中，会按声明顺序存入卡槽 slot</p> 
<pre><code class="language-javascript">contract A{
    address owner;
    B addrB;
}
</code></pre> 
<p><img alt="" height="175" src="https://images2.imgbox.com/0c/8b/cc2vIiNa_o.png" width="408"></p> 
<p>Solidity 对于复杂的数据类型，在函数中作为局部变量时，会默认存储在 storage 中。当声明的复杂数据类型局部变量未初始化时，它会默认成为指向 storage 的指针，就会指向 slot 0，这时如果声明了状态变量，那么第一个状态变量将会被覆盖。</p> 
<pre><code class="language-javascript">pragma solidity ^0.4.0;

contract CC { 

    string public _name1;
    string public _name2;

    struct NameRecord {  
        string name1;   
        string name2; 
    }

    function CC() {
        _name1 = "makabaka";
        _name2 = "nigubigu";
    } 

    function register(string n1, string n2) public { 
        // 设置新的NameRecord ，未初始化
        NameRecord newRecord; 
        newRecord.name1 = n1; 
        newRecord.name2 = n2;  
    } 
    
}</code></pre> 
<p>register 函数中的结构体类型局部变量 newRecord，由于未初始化，默认会指向 slot 0，于是 newRecord.name1 会覆盖状态变量 _name1，newRecord.name2 会覆盖状态变量 _name2</p> 
<p><img alt="" height="755" src="https://images2.imgbox.com/3b/a6/ylBJ0zQY_o.png" width="1186"></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b34c40d1fba014dbe86542e6546f16a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【ELEC362 】APPLICATION DEVELOPMENT WITH</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/283766f93d051b35d5ce11ccaabed191/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp计算视频学习进程，并且下次回来继续播放（不能快进）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>