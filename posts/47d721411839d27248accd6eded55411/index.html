<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python中ix用法_Python numpy.ix_() 使用实例 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python中ix用法_Python numpy.ix_() 使用实例" />
<meta property="og:description" content="The following are code examples for showing how to use . They are extracted from open source Python projects. You can vote up the examples you like or vote down the exmaples you don’t like. You can also save this page to your account.
Example 1
def test_large_fancy_indexing(self, level=rlevel):
# Large enough to fail on 64-bit.
nbits = np.dtype(np.intp).itemsize * 8
thesize = int((2**nbits)**(1.0/5.0)&#43;1)
def dp():
n = 3" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/47d721411839d27248accd6eded55411/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-08T23:26:25+08:00" />
<meta property="article:modified_time" content="2020-12-08T23:26:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python中ix用法_Python numpy.ix_() 使用实例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>The following are code examples for showing how to use . They are extracted from open source Python projects. You can vote up the examples you like or vote down the exmaples you don’t like. You can also save this page to your account.</p> 
 <p>Example 1</p> 
 <p>def test_large_fancy_indexing(self, level=rlevel):</p> 
 <p># Large enough to fail on 64-bit.</p> 
 <p>nbits = np.dtype(np.intp).itemsize * 8</p> 
 <p>thesize = int((2**nbits)**(1.0/5.0)+1)</p> 
 <p>def dp():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)] = 0</p> 
 <p>def dp2():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)]</p> 
 <p>self.assertRaises(ValueError, dp)</p> 
 <p>self.assertRaises(ValueError, dp2)</p> 
 <p>Example 2</p> 
 <p>def graphlet_kernel(graphs, num_samples):</p> 
 <p>N = len(graphs)</p> 
 <p>Phi = np.zeros((N,2**15))</p> 
 <p>P = generate_permutation_matrix()</p> 
 <p>for i in range(len(graphs)):</p> 
 <p>n = graphs[i].number_of_nodes()</p> 
 <p>if n &gt;= 6:</p> 
 <p>A = nx.to_numpy_matrix(graphs[i])</p> 
 <p>A = np.asarray(A, dtype=np.uint8)</p> 
 <p>for j in range(num_samples):</p> 
 <p>r = np.random.permutation(n)</p> 
 <p>window = A[np.ix_(r[:6],r[:6])]</p> 
 <p>Phi[i, graphlet_type(window)] += 1</p> 
 <p>Phi[i,:] /= num_samples</p> 
 <p>K = np.dot(Phi,np.dot(P,np.transpose(Phi)))</p> 
 <p>return K</p> 
 <p>Example 3</p> 
 <p>def MakeEquationSystem_volumeControl_extendedFP(w_lst_tmstp, wTip, EltChannel, EltTip, C, dt, Q, ElemArea):</p> 
 <p>Ccc = C[np.ix_(EltChannel, EltChannel)]</p> 
 <p>Cct = C[np.ix_(EltChannel, EltTip)]</p> 
 <p>A = np.hstack((Ccc,-np.ones((EltChannel.size,1),dtype=np.float64)))</p> 
 <p>A = np.vstack((A, np.ones((1, EltChannel.size + 1), dtype=np.float64)))</p> 
 <p>A[-1,-1] = 0</p> 
 <p>S = -np.dot(Ccc,w_lst_tmstp[EltChannel]) - np.dot(Cct,wTip)</p> 
 <p>S = np.append(S,Q * dt / ElemArea - (sum(wTip)-sum(w_lst_tmstp[EltTip])))</p> 
 <p>return A, S</p> 
 <p>#-----------------------------------------------------------------------------------------------------------------------</p> 
 <p>Example 4</p> 
 <p>def jw_number_restrict_operator(operator, n_electrons, n_qubits=None):</p> 
 <p>"""Restrict a Jordan-Wigner encoded operator to a given particle number</p> 
 <p>Args:</p> 
 <p>sparse_operator(ndarray or sparse): Numpy operator acting on</p> 
 <p>the space of n_qubits.</p> 
 <p>n_electrons(int): Number of particles to restrict the operator to</p> 
 <p>n_qubits(int): Number of qubits defining the total state</p> 
 <p>Returns:</p> 
 <p>new_operator(ndarray or sparse): Numpy operator restricted to</p> 
 <p>acting on states with the same particle number.</p> 
 <p>"""</p> 
 <p>if n_qubits is None:</p> 
 <p>n_qubits = int(numpy.log2(operator.shape[0]))</p> 
 <p>select_indices = jw_number_indices(n_electrons, n_qubits)</p> 
 <p>return operator[numpy.ix_(select_indices, select_indices)]</p> 
 <p>Example 5</p> 
 <p>def _M2_sparse_sym(Xvar, mask_X, Yvar, mask_Y, weights=None):</p> 
 <p>""" 2nd self-symmetric moment matrix exploiting zero input columns</p> 
 <p>Computes X'X + Y'Y and X'Y + Y'X</p> 
 <p>"""</p> 
 <p>assert len(mask_X) == len(mask_Y), 'X and Y need to have equal sizes for symmetrization'</p> 
 <p>Cxxyy = np.zeros((len(mask_X), len(mask_Y)))</p> 
 <p>Cxxyy[np.ix_(mask_X, mask_X)] = _M2_dense(Xvar, Xvar, weights=weights)</p> 
 <p>Cxxyy[np.ix_(mask_Y, mask_Y)] += _M2_dense(Yvar, Yvar, weights=weights)</p> 
 <p>Cxyyx = np.zeros((len(mask_X), len(mask_Y)))</p> 
 <p>Cxy = _M2_dense(Xvar, Yvar, weights=weights)</p> 
 <p>Cyx = _M2_dense(Yvar, Xvar, weights=weights)</p> 
 <p>Cxyyx[np.ix_(mask_X, mask_Y)] = Cxy</p> 
 <p>Cxyyx[np.ix_(mask_Y, mask_X)] += Cyx</p> 
 <p>return Cxxyy, Cxyyx</p> 
 <p>Example 6</p> 
 <p>def test_large_fancy_indexing(self, level=rlevel):</p> 
 <p># Large enough to fail on 64-bit.</p> 
 <p>nbits = np.dtype(np.intp).itemsize * 8</p> 
 <p>thesize = int((2**nbits)**(1.0/5.0)+1)</p> 
 <p>def dp():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)] = 0</p> 
 <p>def dp2():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)]</p> 
 <p>self.assertRaises(ValueError, dp)</p> 
 <p>self.assertRaises(ValueError, dp2)</p> 
 <p>Example 7</p> 
 <p>def test_large_fancy_indexing(self, level=rlevel):</p> 
 <p># Large enough to fail on 64-bit.</p> 
 <p>nbits = np.dtype(np.intp).itemsize * 8</p> 
 <p>thesize = int((2**nbits)**(1.0/5.0)+1)</p> 
 <p>def dp():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)] = 0</p> 
 <p>def dp2():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)]</p> 
 <p>self.assertRaises(ValueError, dp)</p> 
 <p>self.assertRaises(ValueError, dp2)</p> 
 <p>Example 8</p> 
 <p>def _cartesian_product(*arrays):</p> 
 <p>"""</p> 
 <p>Get the cartesian product of a number of arrays.</p> 
 <p>Parameters</p> 
 <p>----------</p> 
 <p>arrays : Iterable[np.ndarray]</p> 
 <p>The arrays to get a cartesian product of. Always sorted with respect</p> 
 <p>to the original array.</p> 
 <p>Returns</p> 
 <p>-------</p> 
 <p>out : np.ndarray</p> 
 <p>The overall cartesian product of all the input arrays.</p> 
 <p>"""</p> 
 <p>broadcastable = np.ix_(*arrays)</p> 
 <p>broadcasted = np.broadcast_arrays(*broadcastable)</p> 
 <p>rows, cols = np.prod(broadcasted[0].shape), len(broadcasted)</p> 
 <p>dtype = np.result_type(*arrays)</p> 
 <p>out = np.empty(rows * cols, dtype=dtype)</p> 
 <p>start, end = 0, rows</p> 
 <p>for a in broadcasted:</p> 
 <p>out[start:end] = a.reshape(-1)</p> 
 <p>start, end = end, end + rows</p> 
 <p>return out.reshape(cols, rows)</p> 
 <p>Example 9</p> 
 <p>def test_large_fancy_indexing(self, level=rlevel):</p> 
 <p># Large enough to fail on 64-bit.</p> 
 <p>nbits = np.dtype(np.intp).itemsize * 8</p> 
 <p>thesize = int((2**nbits)**(1.0/5.0)+1)</p> 
 <p>def dp():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)] = 0</p> 
 <p>def dp2():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)]</p> 
 <p>self.assertRaises(ValueError, dp)</p> 
 <p>self.assertRaises(ValueError, dp2)</p> 
 <p>Example 10</p> 
 <p>def _find_motif(self, data, row_indices):</p> 
 <p>"""Finds the largest xMOTIF (this is the direct implementation of the</p> 
 <p>pseucode of the FindMotif() procedure described in the original paper).</p> 
 <p>"""</p> 
 <p>num_rows, num_cols = data.shape</p> 
 <p>best_motif = Bicluster([], [])</p> 
 <p>seeds = np.random.choice(num_cols, self.num_seeds, replace=False)</p> 
 <p>for s in seeds:</p> 
 <p>seed_col = data[row_indices, s][:, np.newaxis]</p> 
 <p>for i in range(self.num_sets):</p> 
 <p>cols_set = np.random.choice(num_cols, self.set_size, replace=False)</p> 
 <p>rows_comp_data = seed_col == data[np.ix_(row_indices, cols_set)]</p> 
 <p>selected_rows = np.array([y for x, y in enumerate(row_indices) if np.all(rows_comp_data[x])], np.int)</p> 
 <p>seed_values = data[selected_rows, s][:, np.newaxis]</p> 
 <p>cols_comp_data = seed_values == data[selected_rows]</p> 
 <p>selected_cols = np.array([k for k in range(num_cols) if np.all(cols_comp_data[:, k])])</p> 
 <p>if len(selected_cols) &gt;= self.alpha * num_cols and len(selected_rows) &gt; len(best_motif.rows):</p> 
 <p>best_motif = Bicluster(selected_rows, selected_cols)</p> 
 <p>return best_motif</p> 
 <p>Example 11</p> 
 <p>def _find_constrained_bicluster(self, data):</p> 
 <p>"""Find a k x l bicluster."""</p> 
 <p>num_rows, num_cols = data.shape</p> 
 <p>k = random.randint(1, math.ceil(num_rows / 2))</p> 
 <p>l = random.randint(1, math.ceil(num_cols / 2))</p> 
 <p>cols = np.random.choice(num_cols, size=l, replace=False)</p> 
 <p>old_avg, avg = float('-inf'), 0.0</p> 
 <p>while abs(avg - old_avg) &gt; self.tol:</p> 
 <p>old_avg = avg</p> 
 <p>row_sums = np.sum(data[:, cols], axis=1)</p> 
 <p>rows = bn.argpartition(row_sums, num_rows - k)[-k:] # this is usually faster than rows = np.argsort(row_sums)[-k:]</p> 
 <p>col_sums = np.sum(data[rows, :], axis=0)</p> 
 <p>cols = bn.argpartition(col_sums, num_cols - l)[-l:] # this is usually faster than cols = np.argsort(col_sums)[-l:]</p> 
 <p>avg = np.mean(data[np.ix_(rows, cols)])</p> 
 <p>return Bicluster(rows, cols)</p> 
 <p>Example 12</p> 
 <p>def compute_activity_matrix(self, xywrap, thwrap, wdim, pcw):</p> 
 <p>"""Compute the activation of pose cells. Taken from Renato de Pontes Pereira"""</p> 
 <p># The goal is to return an update matrix that can be added/subtracted</p> 
 <p># from the posecell matrix</p> 
 <p>pca_new = np.zeros([PC_DIM_XY, PC_DIM_XY, PC_DIM_TH])</p> 
 <p># for nonzero posecell values</p> 
 <p>indices = np.nonzero(self.posecells)</p> 
 <p>for i,j,k in itertools.izip(*indices):</p> 
 <p>pca_new[np.ix_(xywrap[i:i+wdim],</p> 
 <p>xywrap[j:j+wdim],</p> 
 <p>thwrap[k:k+wdim])] += self.posecells[i,j,k]*pcw</p> 
 <p>return pca_new</p> 
 <p>Example 13</p> 
 <p>def test_large_fancy_indexing(self, level=rlevel):</p> 
 <p># Large enough to fail on 64-bit.</p> 
 <p>nbits = np.dtype(np.intp).itemsize * 8</p> 
 <p>thesize = int((2**nbits)**(1.0/5.0)+1)</p> 
 <p>def dp():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)] = 0</p> 
 <p>def dp2():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)]</p> 
 <p>self.assertRaises(ValueError, dp)</p> 
 <p>self.assertRaises(ValueError, dp2)</p> 
 <p>Example 14</p> 
 <p>def section_by_index(array, index, axis=0):</p> 
 <p>"""</p> 
 <p>Take the slice of `array` indexed by entries of `index`</p> 
 <p>along the specified `axis`.</p> 
 <p>"""</p> 
 <p># alternative `axisindex` implementation</p> 
 <p># that avoids the index arithmetic</p> 
 <p># uses `numpy` fancy indexing instead</p> 
 <p># possible index values for each dimension represented</p> 
 <p># as `numpy` arrays all having the shape of `index`</p> 
 <p>indices = np.ix_(*[np.arange(dim) for dim in index.shape])</p> 
 <p># the slice is taken along `axis`</p> 
 <p># except for the array `index` itself, the other indices</p> 
 <p># do nothing except trigger `numpy` fancy indexing</p> 
 <p>fancy_index = indices[:axis] + (index,) + indices[axis:]</p> 
 <p># result has the same shape as `index`</p> 
 <p>return array[fancy_index]</p> 
 <p>Example 15</p> 
 <p>def get_element_type_subset_indices(self):</p> 
 <p>"""</p> 
 <p>It is currently required that the element of two matching atoms is the same.</p> 
 <p>This constructs indices to e.g. the carbon-carbon submatrix.</p> 
 <p>"""</p> 
 <p># TODO: this is redundant if the elements does not have to match</p> 
 <p>unique_elements = np.unique(self.reactants_elements)</p> 
 <p>subset_indices = np.empty(unique_elements.size, dtype=object)</p> 
 <p>for i, element in enumerate(unique_elements):</p> 
 <p>rows = np.where(self.reactants_elements == element)[0]</p> 
 <p>cols = np.where(self.products_elements == element)[0]</p> 
 <p>subset_indices[i] = np.ix_(rows,cols)</p> 
 <p>return subset_indices</p> 
 <p>Example 16</p> 
 <p>def test_large_fancy_indexing(self, level=rlevel):</p> 
 <p># Large enough to fail on 64-bit.</p> 
 <p>nbits = np.dtype(np.intp).itemsize * 8</p> 
 <p>thesize = int((2**nbits)**(1.0/5.0)+1)</p> 
 <p>def dp():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)] = 0</p> 
 <p>def dp2():</p> 
 <p>n = 3</p> 
 <p>a = np.ones((n,)*5)</p> 
 <p>i = np.random.randint(0, n, size=thesize)</p> 
 <p>a[np.ix_(i, i, i, i, i)]</p> 
 <p>self.assertRaises(ValueError, dp)</p> 
 <p>self.assertRaises(ValueError, dp2)</p> 
 <p>Example 17</p> 
 <p>def test_regression_1(self):</p> 
 <p># Test empty inputs create ouputs of indexing type, gh-5804</p> 
 <p># Test both lists and arrays</p> 
 <p>for func in (range, np.arange):</p> 
 <p>a, = np.ix_(func(0))</p> 
 <p>assert_equal(a.dtype, np.intp)</p> 
 <p>Example 18</p> 
 <p>def test_shape_and_dtype(self):</p> 
 <p>sizes = (4, 5, 3, 2)</p> 
 <p># Test both lists and arrays</p> 
 <p>for func in (range, np.arange):</p> 
 <p>arrays = np.ix_(*[func(sz) for sz in sizes])</p> 
 <p>for k, (a, sz) in enumerate(zip(arrays, sizes)):</p> 
 <p>assert_equal(a.shape[k], sz)</p> 
 <p>assert_(all(sh == 1 for j, sh in enumerate(a.shape) if j != k))</p> 
 <p>assert_(np.issubdtype(a.dtype, int))</p> 
 <p>Example 19</p> 
 <p>def test_bool(self):</p> 
 <p>bool_a = [True, False, True, True]</p> 
 <p>int_a, = np.nonzero(bool_a)</p> 
 <p>assert_equal(np.ix_(bool_a)[0], int_a)</p> 
 <p>Example 20</p> 
 <p>def test_1d_only(self):</p> 
 <p>idx2d = [[1, 2, 3], [4, 5, 6]]</p> 
 <p>assert_raises(ValueError, np.ix_, idx2d)</p> 
 <p>Example 21</p> 
 <p>def _gaus_condition(self, xi):</p> 
 <p>if np.ma.count_masked(xi) == 0:</p> 
 <p>return xi</p> 
 <p>a = xi.mask</p> 
 <p>b = ~xi.mask</p> 
 <p>xb = xi[b].data</p> 
 <p>Laa = self.prec[np.ix_(a, a)]</p> 
 <p>Lab = self.prec[np.ix_(a, b)]</p> 
 <p>xfill = np.empty_like(xi)</p> 
 <p>xfill[b] = xb</p> 
 <p>xfill[a] = self.mean[a] - solve(Laa, Lab.dot(xb - self.mean[b]))</p> 
 <p>return xfill</p> 
 <p>Example 22</p> 
 <p>def gacPathCondEntropy(IminuszW, cluster_i, cluster_j):</p> 
 <p># Compute conditional complexity from the subpart of the weighted adjacency matrix</p> 
 <p># Inputs:</p> 
 <p># - IminuszW: the matrix (I - z*P)</p> 
 <p>#- cluster_i: index vector of cluster i</p> 
 <p>#- cluster_j: index vector of cluster j</p> 
 <p># Output:</p> 
 <p>#- L_ij - the sum of conditional complexities of cluster i and j after merging.</p> 
 <p># by Wei Zhang (wzhang009 at gmail.com), June, 8, 2011</p> 
 <p>num_i = np.size(cluster_i)</p> 
 <p>num_j = np.size(cluster_j)</p> 
 <p># detecting cross elements (this check costs much and is unnecessary)</p> 
 <p>ijGroupIndex = np.append(cluster_i, cluster_j)</p> 
 <p>y_ij = np.zeros((num_i + num_j, 2)) # [y_i, y_j]</p> 
 <p>y_ij[:num_i, 0] = 1</p> 
 <p>y_ij[num_i:, 1] = 1</p> 
 <p>idx = np.ix_(ijGroupIndex, ijGroupIndex)</p> 
 <p>L_ij = scipy.linalg.inv(IminuszW[idx]).dot(y_ij)</p> 
 <p>L_ij = sum(L_ij[:num_i, 0]) / (num_i * num_i) + sum(L_ij[num_i:, 1]) / (num_j * num_j)</p> 
 <p>return L_ij</p> 
 <p>Example 23</p> 
 <p>def reconstruct_original_mat(self, thresh, intracluster_weight=0):</p> 
 <p>"""</p> 
 <p>reconstruct a similarity matrix with size equals to the original one, from the reduced similarity matrix</p> 
 <p>:param thresh: a threshold parameter to prune the edges of the graph</p> 
 <p>:param intracluster_weight: the weight to assign at each connection generated by the expansion of a cluster</p> 
 <p>:return: the reconstructed graph</p> 
 <p>"""</p> 
 <p>reconstructed_mat = np.zeros((self.N, self.N))</p> 
 <p>r_nodes = self.classes &gt; 0</p> 
 <p>reconstructed_mat[np.ix_(r_nodes, r_nodes)] = intracluster_weight</p> 
 <p>for r in range(2, self.k + 1):</p> 
 <p>r_nodes = self.classes == r</p> 
 <p>reconstructed_mat[np.ix_(r_nodes, r_nodes)] = intracluster_weight</p> 
 <p>for s in range(1, r):</p> 
 <p>if self.is_weighted:</p> 
 <p>cl_pair = WeightedClassesPair(self.sim_mat, self.adj_mat, self.classes, r, s, self.epsilon)</p> 
 <p>else:</p> 
 <p>cl_pair = ClassesPair(self.adj_mat, self.classes, r, s, self.epsilon)</p> 
 <p>s_nodes = self.classes == s</p> 
 <p>if cl_pair.bip_density &gt; thresh:</p> 
 <p>reconstructed_mat[np.ix_(r_nodes, s_nodes)] = reconstructed_mat[np.ix_(s_nodes, r_nodes)] = cl_pair.bip_density</p> 
 <p>np.fill_diagonal(reconstructed_mat, 0.0)</p> 
 <p>return reconstructed_mat</p> 
 <p>Example 24</p> 
 <p>def __init__(self, adj_mat, classes, r, s, epsilon):</p> 
 <p>self.r = r</p> 
 <p>self.s = s</p> 
 <p>self.index_map = np.where(classes == r)[0]</p> 
 <p>self.index_map = np.vstack((self.index_map, np.where(classes == s)[0]))</p> 
 <p>self.bip_adj_mat = adj_mat[np.ix_(self.index_map[0], self.index_map[1])]</p> 
 <p>self.n = self.bip_adj_mat.shape[0]</p> 
 <p>self.bip_avg_deg = self.bip_avg_degree()</p> 
 <p>self.bip_density = self.compute_bip_density()</p> 
 <p>self.epsilon = epsilon</p> 
 <p>Example 25</p> 
 <p>def __init__(self, sim_mat, adj_mat, classes, r, s, epsilon):</p> 
 <p>self.r = r</p> 
 <p>self.s = s</p> 
 <p>self.index_map = np.where(classes == r)[0]</p> 
 <p>self.index_map = np.vstack((self.index_map, np.where(classes == s)[0]))</p> 
 <p>self.bip_sim_mat = sim_mat[np.ix_(self.index_map[0], self.index_map[1])]</p> 
 <p>self.bip_adj_mat = adj_mat[np.ix_(self.index_map[0], self.index_map[1])]</p> 
 <p>self.n = self.bip_sim_mat.shape[0]</p> 
 <p>self.bip_avg_deg = self.bip_avg_degree()</p> 
 <p>self.bip_density = self.compute_bip_density()</p> 
 <p>self.epsilon = epsilon</p> 
 <p>Example 26</p> 
 <p>def bin_sizes(self):</p> 
 <p>sizes1 = np.cos(self.get_bin_left_edges(0)) - np.cos(self.get_bin_right_edges(0))</p> 
 <p>sizes2 = self.get_bin_widths(1)</p> 
 <p>return reduce(np.multiply, np.ix_(sizes1, sizes2))</p> 
 <p>Example 27</p> 
 <p>def bin_sizes(self):</p> 
 <p>sizes1 = (self.get_bin_right_edges(0) ** 3 - self.get_bin_left_edges(0) ** 3) / 3</p> 
 <p>sizes2 = np.cos(self.get_bin_left_edges(1)) - np.cos(self.get_bin_right_edges(1))</p> 
 <p>sizes3 = self.get_bin_widths(2)</p> 
 <p># Hopefully correct</p> 
 <p>return reduce(np.multiply, np.ix_(sizes1, sizes2,sizes3))</p> 
 <p>#return np.outer(sizes, sizes2, self.get_bin_widths(2)) # Correct</p> 
 <p>Example 28</p> 
 <p>def bin_sizes(self):</p> 
 <p>sizes1 = 0.5 * (self.get_bin_right_edges(0) ** 2 - self.get_bin_left_edges(0) ** 2)</p> 
 <p>sizes2 = self.get_bin_widths(1)</p> 
 <p>sizes3 = self.get_bin_widths(2)</p> 
 <p>return reduce(np.multiply, np.ix_(sizes1, sizes2, sizes3))</p> 
 <p>Example 29</p> 
 <p>def reduce_distmat(full_dist_mat,</p> 
 <p>gal_templateids,</p> 
 <p>probe_templateids,</p> 
 <p>reduce_type=ReduceType.MeanMin):</p> 
 <p># Get unique template indices and there positions for keeping initial order</p> 
 <p>#gal_tuids,gal_tuind=np.unique(gal_templateids,return_index=True)</p> 
 <p>#probe_tuids,probe_tuind=np.unique(probe_templateids,return_index=True)</p> 
 <p>gal_tuids, gal_tuind = np.unique(</p> 
 <p>[str(x) for x in gal_templateids], return_index=True)</p> 
 <p>probe_tuids, probe_tuind = np.unique(</p> 
 <p>[str(x) for x in probe_templateids], return_index=True)</p> 
 <p>red_dist_mat = np.zeros((len(gal_tuids), len(probe_tuids)))</p> 
 <p># Loop on gallery</p> 
 <p>for g, gtupos in enumerate(gal_tuind):</p> 
 <p>gutid = gal_templateids[gtupos]</p> 
 <p>gt_pos = np.where(gal_templateids == gutid)[0]</p> 
 <p># Loop on probe</p> 
 <p>for p, ptupos in enumerate(probe_tuind):</p> 
 <p>putid = probe_templateids[ptupos]</p> 
 <p>pt_pos = np.where(probe_templateids == putid)[0]</p> 
 <p># Get appropriate distance</p> 
 <p>#print g,p</p> 
 <p>dist_val = 0.0</p> 
 <p># TO BE FIXED</p> 
 <p>if reduce_type == ReduceType.MeanMin:</p> 
 <p>dist_val = np.mean(np.min(full_dist_mat[np.ix_(gt_pos, pt_pos)]))</p> 
 <p>else:</p> 
 <p>dist_val = np.amin(full_dist_mat[np.ix_(gt_pos, pt_pos)])</p> 
 <p>red_dist_mat[g, p] = dist_val</p> 
 <p>return red_dist_mat, gal_tuind, probe_tuind</p> 
 <p>Example 30</p> 
 <p>def test_regression_1(self):</p> 
 <p># Test empty inputs create ouputs of indexing type, gh-5804</p> 
 <p># Test both lists and arrays</p> 
 <p>for func in (range, np.arange):</p> 
 <p>a, = np.ix_(func(0))</p> 
 <p>assert_equal(a.dtype, np.intp)</p> 
 <p>Example 31</p> 
 <p>def test_shape_and_dtype(self):</p> 
 <p>sizes = (4, 5, 3, 2)</p> 
 <p># Test both lists and arrays</p> 
 <p>for func in (range, np.arange):</p> 
 <p>arrays = np.ix_(*[func(sz) for sz in sizes])</p> 
 <p>for k, (a, sz) in enumerate(zip(arrays, sizes)):</p> 
 <p>assert_equal(a.shape[k], sz)</p> 
 <p>assert_(all(sh == 1 for j, sh in enumerate(a.shape) if j != k))</p> 
 <p>assert_(np.issubdtype(a.dtype, int))</p> 
 <p>Example 32</p> 
 <p>def test_bool(self):</p> 
 <p>bool_a = [True, False, True, True]</p> 
 <p>int_a, = np.nonzero(bool_a)</p> 
 <p>assert_equal(np.ix_(bool_a)[0], int_a)</p> 
 <p>Example 33</p> 
 <p>def test_1d_only(self):</p> 
 <p>idx2d = [[1, 2, 3], [4, 5, 6]]</p> 
 <p>assert_raises(ValueError, np.ix_, idx2d)</p> 
 <p>Example 34</p> 
 <p>def _compute_log_likelihood(self, X):</p> 
 <p>seq_len = X.shape[0]</p> 
 <p>n_states = self.n_components</p> 
 <p>n_dim = X.shape[1]</p> 
 <p>p = np.zeros((seq_len,n_states))</p> 
 <p>for i in range(seq_len):</p> 
 <p>miss = np.isnan(X[i])</p> 
 <p>p[i] = np.sum(miss * np.log(self.miss_probs_) + (1-miss) * np.log(1-self.miss_probs_), axis=1)</p> 
 <p>if not np.all(miss):</p> 
 <p>for state in range(n_states):</p> 
 <p>mean = self.means_[state][miss==0]</p> 
 <p>cov = self.covars_[state][np.ix_(miss==0,miss==0)]</p> 
 <p>p[i][state] = p[i][state] + np.log(multivariate_normal.pdf(X[i][miss==0],mean=mean,cov=cov))</p> 
 <p>return p</p> 
 <p>Example 35</p> 
 <p>def split_data(self, X, y, i):</p> 
 <p>sub_dict = {}</p> 
 <p>unique_val = np.unique(X[:, i])</p> 
 <p>c = range(i) + range(i + 1, X.shape[1])</p> 
 <p>for val in unique_val:</p> 
 <p>indice = np.where(X[:, i] == val)[0]</p> 
 <p># print indice.shape</p> 
 <p>sub_dict[val] = (X[np.ix_(indice, c)], y[indice])</p> 
 <p>return sub_dict # sub_data, sub_target</p> 
 <p>Example 36</p> 
 <p>def _extract_pairwise(self, X, y, n, is_train=True):</p> 
 <p>if self.cache is not None and (n, True, is_train) in self.cache:</p> 
 <p>return self.cache[n, True, is_train]</p> 
 <p>if not hasattr(X, "shape"):</p> 
 <p>raise ValueError("Precomputed kernels or affinity matrices have "</p> 
 <p>"to be passed as arrays or sparse matrices.")</p> 
 <p>if X.shape[0] != X.shape[1]:</p> 
 <p>raise ValueError("X should be a square kernel matrix")</p> 
 <p>train, test = self.splits[n]</p> 
 <p>result = X[np.ix_(train if is_train else test, train)]</p> 
 <p>if self.cache is not None:</p> 
 <p>self.cache[n, True, is_train] = result</p> 
 <p>return result</p> 
 <p>Example 37</p> 
 <p>def compute_new_medoid(self,cluster, distances):</p> 
 <p>mask = np.ones(distances.shape)</p> 
 <p>mask[np.ix_(cluster,cluster)] = 0.</p> 
 <p>cluster_distances = np.ma.masked_array(data=distances, mask=mask, fill_value=10e9)</p> 
 <p>costs = cluster_distances.sum(axis=1)</p> 
 <p>return costs.argmin(axis=0, fill_value=10e9)</p> 
 <p>Example 38</p> 
 <p>def get_global_stiffness(self,msz):</p> 
 <p>pass</p> 
 <p>#~ ni, nj = self.get_nodes()</p> 
 <p>#~ self.keg = np.zeros((msz,msz))</p> 
 <p>#~ idx = np.ix_([ni.label, nj.label],[ni.label, nj.label])</p> 
 <p>#~ row = np.array([ni.label, ni.label, nj.label, nj.label])</p> 
 <p>#~ col = np.array([ni.label, nj.label, ni.label, nj.label])</p> 
 <p>#~ data = self.get_element_stiffness().reshape(-1)</p> 
 <p>#~ print data, row, col</p> 
 <p>#~ self.keg = csr_matrix((data, (row, col)), shape=(msz,msz)).toarray()</p> 
 <p>#~ return self.keg</p> 
 <p>Example 39</p> 
 <p>def generate_permutation_matrix():</p> 
 <p>P = np.zeros((2**15,2**15),dtype=np.uint8)</p> 
 <p>for a in range(2):</p> 
 <p>for b in range(2):</p> 
 <p>for c in range(2):</p> 
 <p>for d in range(2):</p> 
 <p>for e in range(2):</p> 
 <p>for f in range(2):</p> 
 <p>for g in range(2):</p> 
 <p>for h in range(2):</p> 
 <p>for i in range(2):</p> 
 <p>for j in range(2):</p> 
 <p>for k in range(2):</p> 
 <p>for l in range(2):</p> 
 <p>for m in range(2):</p> 
 <p>for n in range(2):</p> 
 <p>for o in range(2):</p> 
 <p>A = np.array([[0,a,b,c,d,e],[a,0,f,g,h,i],[b,f,0,j,k,l],[c,g,j,0,m,n],[d,h,k,m,0,o],[e,i,l,n,o,0]])</p> 
 <p>perms = multiset_permutations(np.array(range(6),dtype=np.uint8))</p> 
 <p>Per = np.zeros((factorial(6),6),dtype=np.uint8)</p> 
 <p>ind = 0</p> 
 <p>for permutation in perms:</p> 
 <p>Per[ind,:] = permutation</p> 
 <p>ind += 1</p> 
 <p>for p in range(factorial(6)):</p> 
 <p>A_per = A[np.ix_(Per[p,:],Per[p,:])]</p> 
 <p>P[graphlet_type(A), graphlet_type(A_per)] = 1</p> 
 <p>return P</p> 
 <p>Example 40</p> 
 <p>def MakeEquationSystem_mechLoading_sameFP(w_LoadedElts, EltCrack, EltLoaded, C):</p> 
 <p>C_Crack = C[np.ix_(EltCrack, EltCrack)]</p> 
 <p>A = np.hstack((C_Crack, -np.ones((EltCrack.size, 1), dtype=np.float64)))</p> 
 <p>A = np.vstack((A, np.zeros((1, EltCrack.size + 1), dtype=np.float64)))</p> 
 <p>A[-1, np.where(EltCrack == EltLoaded)[0]] = 1</p> 
 <p>S = np.zeros((EltCrack.size + 1), dtype=np.float64)</p> 
 <p>S[-1] = w_LoadedElts</p> 
 <p>return A, S</p> 
 <p>#-----------------------------------------------------------------------------------------------------------------------</p> 
 <p>Example 41</p> 
 <p>def MakeEquationSystem_mechLoading_extendedFP(wTip, EltChannel, EltTip, C, EltLoaded, w_loaded):</p> 
 <p>Ccc = C[np.ix_(EltChannel, EltChannel)]</p> 
 <p>Cct = C[np.ix_(EltChannel, EltTip)]</p> 
 <p>A = np.hstack((Ccc, -np.ones((EltChannel.size, 1),dtype=np.float64)))</p> 
 <p>A = np.vstack((A,np.zeros((1,EltChannel.size+1),dtype=np.float64)))</p> 
 <p>A[-1, np.where(EltChannel == EltLoaded)[0]] = 1</p> 
 <p>S = - np.dot(Cct, wTip)</p> 
 <p>S = np.append(S, w_loaded)</p> 
 <p>return A, S</p> 
 <p>#-----------------------------------------------------------------------------------------------------------------------</p> 
 <p>Example 42</p> 
 <p>def MakeEquationSystem_volumeControl_sameFP(w, EltCrack, C, dt, Q, ElemArea):</p> 
 <p>C_Crack = C[np.ix_(EltCrack, EltCrack)]</p> 
 <p>A = np.hstack((C_Crack,-np.ones((EltCrack.size,1),dtype=np.float64)))</p> 
 <p>A = np.vstack((A,np.ones((1,EltCrack.size+1),dtype=np.float64)))</p> 
 <p>A[-1,-1] = 0</p> 
 <p>S = -np.dot(C_Crack,w[EltCrack])</p> 
 <p>S = np.append(S,Q * dt / ElemArea)</p> 
 <p>return A, S</p> 
 <p>#-----------------------------------------------------------------------------------------------------------------------</p> 
 <p>Example 43</p> 
 <p>def maybe_convert_ix(*args):</p> 
 <p>"""</p> 
 <p>We likely want to take the cross-product</p> 
 <p>"""</p> 
 <p>ixify = True</p> 
 <p>for arg in args:</p> 
 <p>if not isinstance(arg, (np.ndarray, list, ABCSeries, Index)):</p> 
 <p>ixify = False</p> 
 <p>if ixify:</p> 
 <p>return np.ix_(*args)</p> 
 <p>else:</p> 
 <p>return args</p> 
 <p>Example 44</p> 
 <p>def fit(self, X):</p> 
 <p>"""Sample a training set.</p> 
 <p>Parameters</p> 
 <p>----------</p> 
 <p>X: array-like</p> 
 <p>training set to sample observations from.</p> 
 <p>Returns</p> 
 <p>----------</p> 
 <p>self: obj</p> 
 <p>fitted instance with stored sample.</p> 
 <p>"""</p> 
 <p>self.train_shape = X.shape</p> 
 <p>sample_idx = {}</p> 
 <p>for i in range(2):</p> 
 <p>dim_size = min(X.shape[i], self.size)</p> 
 <p>sample_idx[i] = permutation(X.shape[i])[:dim_size]</p> 
 <p>sample = X[ix_(sample_idx[0], sample_idx[1])]</p> 
 <p>self.sample_idx_ = sample_idx</p> 
 <p>self.sample_ = sample</p> 
 <p>return self</p> 
 <p>Example 45</p> 
 <p>def is_train(self, X):</p> 
 <p>"""Check if an array is the training set.</p> 
 <p>Parameters</p> 
 <p>----------</p> 
 <p>X: array-like</p> 
 <p>training set to sample observations from.</p> 
 <p>Returns</p> 
 <p>----------</p> 
 <p>self: obj</p> 
 <p>fitted instance with stored sample.</p> 
 <p>"""</p> 
 <p>if not hasattr(self, "train_shape"):</p> 
 <p>raise NotFittedError("This IdTrain instance is not fitted yet.")</p> 
 <p>if not self._check_shape(X):</p> 
 <p>return False</p> 
 <p>idx = self.sample_idx_</p> 
 <p>try:</p> 
 <p># Grab sample from `X`</p> 
 <p>sample = X[ix_(idx[0], idx[1])]</p> 
 <p>return array_equal(sample, self.sample_)</p> 
 <p>except IndexError:</p> 
 <p># If index is out of bounds, X.shape &lt; training_set.shape</p> 
 <p># -&gt; X is not the training set</p> 
 <p>return False</p> 
 <p>Example 46</p> 
 <p>def _M2_sparse(Xvar, mask_X, Yvar, mask_Y, weights=None):</p> 
 <p>""" 2nd moment matrix exploiting zero input columns """</p> 
 <p>C = np.zeros((len(mask_X), len(mask_Y)))</p> 
 <p>C[np.ix_(mask_X, mask_Y)] = _M2_dense(Xvar, Yvar, weights=weights)</p> 
 <p>return C</p> 
 <p>Example 47</p> 
 <p>def cartesian_product(arrays):</p> 
 <p>""" Returns Cartesian product of given arrays (x and y): cartesian_product([x,y]) """</p> 
 <p>broadcastable = np.ix_(*arrays)</p> 
 <p>broadcasted = np.broadcast_arrays(*broadcastable)</p> 
 <p>rows, cols = reduce(np.multiply, broadcasted[0].shape), len(broadcasted)</p> 
 <p>out = np.empty(rows * cols, dtype=broadcasted[0].dtype)</p> 
 <p>start, end = 0, rows</p> 
 <p>for a in broadcasted:</p> 
 <p>out[start:end] = a.reshape(-1)</p> 
 <p>start, end = end, end + rows</p> 
 <p># Return value(s)</p> 
 <p>return out.reshape(cols, rows).T</p> 
 <p>Example 48</p> 
 <p>def test_regression_1(self):</p> 
 <p># Test empty inputs create ouputs of indexing type, gh-5804</p> 
 <p># Test both lists and arrays</p> 
 <p>for func in (range, np.arange):</p> 
 <p>a, = np.ix_(func(0))</p> 
 <p>assert_equal(a.dtype, np.intp)</p> 
 <p>Example 49</p> 
 <p>def test_shape_and_dtype(self):</p> 
 <p>sizes = (4, 5, 3, 2)</p> 
 <p># Test both lists and arrays</p> 
 <p>for func in (range, np.arange):</p> 
 <p>arrays = np.ix_(*[func(sz) for sz in sizes])</p> 
 <p>for k, (a, sz) in enumerate(zip(arrays, sizes)):</p> 
 <p>assert_equal(a.shape[k], sz)</p> 
 <p>assert_(all(sh == 1 for j, sh in enumerate(a.shape) if j != k))</p> 
 <p>assert_(np.issubdtype(a.dtype, int))</p> 
 <p>Example 50</p> 
 <p>def test_bool(self):</p> 
 <p>bool_a = [True, False, True, True]</p> 
 <p>int_a, = np.nonzero(bool_a)</p> 
 <p>assert_equal(np.ix_(bool_a)[0], int_a)</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7642e903cef38ea0b835758330285902/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python中ix用法_在python的pandas模块中，DataFrame对象，如何选择一行？索引、loc、iloc、ix的用法及区别...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/213c451aabae138192d85f72c74b28c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python中os.path.join()的循环用法_Python os.path.join()用法及代码示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>