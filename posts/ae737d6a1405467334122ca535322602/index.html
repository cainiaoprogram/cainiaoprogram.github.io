<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>原型模式和单例模式的区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="原型模式和单例模式的区别" />
<meta property="og:description" content="原型模式和单例模式的区别
1. 定义上的区别 1.1. 原型模式 用原型模式是在已指定对象的基础上，然后通过拷贝这些原型对象创建新的对象。
当要实例化的类是在运行时刻指定或者为了避免创建一个与产品类层次平行的工厂类层次时或者当一个类的实例只能有几个不同状态组合中的一种时 —— 建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 1.2. 单例模式 单态设计模式的核心就是：将类的构造方法私有化，之后在类的内部产生实例化对象，并通过静态方法返回实例化对象的应用。
如果不希望一个类产生更多对象的情况下，必须使用单态模式，所谓单态就是在对象的入口处（构造方法）限制了对象的实例化操作。
2. JAVA实现上的区别 2.1. 原型模式 import java.util.ArrayList; class ConcretePrototype implements Cloneable { private String name; private ArrayList&lt;String&gt; nameList = new ArrayList&lt;String&gt;(); public ConcretePrototype(String name) { this.name = name; this.nameList.add(this.name); } // 添加nameList中的对象 public void setName(String name) { this.nameList.add(name); } public ArrayList&lt;String&gt; getNameList() { return this.nameList; } // 覆盖Object基类中的clone()方法，并扩大该方法的访问权限，具体化返回本类型 public ConcretePrototype clone() { try { return (ConcretePrototype) super.clone(); } catch (CloneNotSupportedException e) { e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ae737d6a1405467334122ca535322602/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-12-19T13:24:06+08:00" />
<meta property="article:modified_time" content="2012-12-19T13:24:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">原型模式和单例模式的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="artical-content-bak main-content editor-side-new"> 
 <div class="con editor-preview-side" id="result"> 
  <p><span style="text-transform:none;text-indent:0px;letter-spacing:normal;border-collapse:separate;font:medium 'Times New Roman';color:rgb(0,0,0);word-spacing:0px;" class="Apple-style-span"> </span></p> 
  <p style="text-align:center;" class="MsoNormal" align="center"><span style="font-family:'微软雅黑', sans-serif;font-size:22pt;">原型模式和单例模式的区别<span lang="en-us"></span></span></p> 
  <p></p> 
  <h2 style="text-indent:-21.25pt;margin-left:21.25pt;"><span style="line-height:50px;font-family:'微软雅黑', sans-serif;font-size:16pt;" lang="en-us">1.<span style="font:7pt 'Times New Roman';">  <span class="Apple-converted-space"> </span></span></span><span style="line-height:50px;font-family:'微软雅黑', sans-serif;font-size:16pt;">定义上的区别<span lang="en-us"></span></span></h2> 
  <p></p> 
  <h3 style="text-indent:-1cm;margin-left:1cm;"><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;" lang="en-us">1.1.<span style="font:7pt 'Times New Roman';"> <span class="Apple-converted-space"> </span></span></span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;">原型模式<span lang="en-us"></span></span></h3> 
  <p></p> 
  <p style="margin-left:21pt;" class="MsoNormal"><span style="font-family:'微软雅黑', sans-serif;color:rgb(51,51,51);">用原型模式是在已指定对象的基础上，然后通过拷贝这些原型对象创建新的对象。<span lang="en-us"></span></span></p> 
  <p></p> 
  <p style="text-indent:21pt;" class="MsoNormal"><span style="font-family:'微软雅黑', sans-serif;color:rgb(51,51,51);">当要实例化的类是在运行时刻指定或者为了避免创建一个与产品类层次平行的工厂类层次时或者当一个类的实例只能有几个不同状态组合中的一种时 —— 建立相应数目的原型并<b>克隆</b>它们可能比每次用合适的状态手工实例化该类更方便一些。<span lang="en-us"> </span></span></p> 
  <p></p> 
  <h3 style="text-indent:-1cm;margin-left:1cm;"><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;" lang="en-us">1.2.<span style="font:7pt 'Times New Roman';"> <span class="Apple-converted-space"> </span></span></span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;">单例模式<span lang="en-us"></span></span></h3> 
  <p></p> 
  <p style="text-indent:21pt;" class="MsoNormal"><span style="font-family:'微软雅黑', sans-serif;color:rgb(51,51,51);">单态设计模式的核心就是：将类的构造方法私有化，之后在类的内部产生实例化对象，并通过静态方法返回实例化对象的应用。<span lang="en-us"></span></span></p> 
  <p></p> 
  <p style="text-indent:21pt;" class="MsoNormal"><span style="font-family:'微软雅黑', sans-serif;color:rgb(51,51,51);">如果不希望一个类产生更多对象的情况下，必须使用单态模式，所谓单态就是在对象的入口处（构造方法）限制了对象的实例化操作。<span lang="en-us"></span></span></p> 
  <p></p> 
  <h2 style="text-indent:-21.25pt;margin-left:21.25pt;"><span style="line-height:50px;font-family:'微软雅黑', sans-serif;font-size:16pt;" lang="en-us">2.<span style="font:7pt 'Times New Roman';">  <span class="Apple-converted-space"> </span></span></span><span style="line-height:50px;font-family:'微软雅黑', sans-serif;font-size:16pt;" lang="en-us">JAVA</span><span style="line-height:50px;font-family:'微软雅黑', sans-serif;font-size:16pt;">实现上的区别<span lang="en-us"></span></span></h2> 
  <p></p> 
  <h3 style="text-indent:-1cm;margin-left:1cm;"><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;" lang="en-us">2.1.<span style="font:7pt 'Times New Roman';"> <span class="Apple-converted-space"> </span></span></span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;">原型模式</span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;"><span lang="en-us"></span></span></h3> 
  <p></p> 
  <pre></pre> 
  <ol class="dp-j"><li class="alt"><span class="keyword">import</span> java.util.ArrayList;  </li><li> </li><li class="alt"><span class="keyword">class</span> ConcretePrototype <span class="keyword">implements</span> Cloneable {  </li></ol> 
  <pre></pre> 
  <ol class="dp-j"><li class="alt"> </li><li> </li><li class="alt">    <span class="keyword">private</span> String name;  </li><li>    <span class="keyword">private</span> ArrayList&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </li><li class="alt"> </li><li>    <span class="keyword">public</span> ConcretePrototype(String name) {  </li><li class="alt">        <span class="keyword">this</span>.name = name;  </li><li>        <span class="keyword">this</span>.nameList.add(<span class="keyword">this</span>.name);  </li><li class="alt">    }  </li><li> </li><li class="alt">    <span class="comment">// 添加nameList中的对象 </span> </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> setName(String name) {  </li><li class="alt">        <span class="keyword">this</span>.nameList.add(name);  </li><li>    }  </li><li class="alt"> </li><li>    <span class="keyword">public</span> ArrayList&lt;String&gt; getNameList() {  </li><li class="alt">        <span class="keyword">return</span> <span class="keyword">this</span>.nameList;  </li><li>    }  </li><li class="alt"> </li><li>    <span class="comment">// 覆盖Object基类中的clone()方法，并扩大该方法的访问权限，具体化返回本类型 </span> </li><li class="alt">    <span class="keyword">public</span> ConcretePrototype clone() {  </li><li>        <span class="keyword">try</span> {  </li><li class="alt">            <span class="keyword">return</span> (ConcretePrototype) <span class="keyword">super</span>.clone();  </li><li>        } <span class="keyword">catch</span> (CloneNotSupportedException e) {  </li><li class="alt">            e.printStackTrace();  </li><li>        }  </li><li class="alt">        <span class="keyword">return</span> <span class="keyword">null</span>;  </li><li>    }  </li><li class="alt">}  </li><li> </li><li class="alt"><span class="keyword">public</span> <span class="keyword">class</span> TestConcretePrototype {  </li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String args[]) {  </li><li class="alt">        <span class="keyword">try</span> {  </li><li>            ConcretePrototype prototype = <span class="keyword">new</span> ConcretePrototype(<span class="string">"调用原型方法"</span>);  </li><li class="alt">            <span class="comment">// 通过clone获取一个拷贝 </span> </li><li>            System.out.println(prototype.getNameList());  </li><li class="alt">            ConcretePrototype fromClone = prototype.clone();  </li><li>            fromClone.setName(<span class="string">"调用克隆方法"</span>);  </li><li class="alt">            System.out.println(fromClone.getNameList());  </li><li>        } <span class="keyword">catch</span> (Exception e) {  </li><li class="alt">            e.printStackTrace();  </li><li>        }  </li><li class="alt">    }  </li><li>}  </li></ol> 
  <h3 style="text-indent:-1cm;margin-left:1cm;"><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;" lang="en-us">2.2.<span style="font:7pt 'Times New Roman';"> <span class="Apple-converted-space"> </span></span></span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;">单例模式<span lang="en-us"></span></span></h3> 
  <p></p> 
  <h4 style="text-indent:-35.45pt;margin-left:35.45pt;"><span style="line-height:27px;font-family:'微软雅黑', sans-serif;font-size:12pt;" lang="en-us">2.2.1.<span style="font:7pt 'Times New Roman';"><span class="Apple-converted-space"> </span></span></span><span style="line-height:27px;font-family:'微软雅黑', sans-serif;font-size:12pt;">单利模式的通用代码</span><span style="line-height:27px;font-family:'微软雅黑', sans-serif;font-size:12pt;"><span lang="en-us"></span></span></h4> 
  <p></p> 
  <pre></pre> 
  <ol class="dp-j"><li class="alt"><span class="keyword">class</span> Singleton {  </li><li> </li><li class="alt">    <span class="keyword">private</span> Singleton() {  </li><li>        <span class="comment">// 将构造方法进行封装，私有化 </span> </li><li class="alt">        <span class="comment">// 定义为private的，是为了不让Singleton在外部生成对象，这才能体现单例模式 </span> </li><li>    }  </li><li class="alt">      </li><li>    <span class="comment">// 在内部产生本类的实例化对象 </span> </li><li class="alt">    <span class="comment">// 注意这是private只供内部调用 </span> </li><li>    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </li><li class="alt"> </li><li>    <span class="keyword">public</span> <span class="keyword">static</span> Singleton getInstance() {  </li><li class="alt">        <span class="comment">// 通过静态方法取得instance对象 </span> </li><li>        <span class="comment">// 这里提供了一个供外部访问本class的静态方法，可以直接访问 </span> </li><li class="alt">        <span class="keyword">return</span> instance;  </li><li>    }  </li><li class="alt"> </li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> setInstance(Singleton instance) {  </li><li class="alt">        Singleton.instance = instance;  </li><li>    }  </li><li class="alt">}  </li><li> </li><li class="alt"><span class="keyword">public</span> <span class="keyword">class</span> TestSingleton {  </li><li>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String args[]) {  </li><li class="alt">        <span class="comment">// 初始化 </span> </li><li>        Singleton s1 = <span class="keyword">null</span>;  </li><li class="alt">        Singleton s2 = <span class="keyword">null</span>;  </li><li>        <span class="comment">// 实例化对象 </span> </li><li class="alt">        s1 = Singleton.getInstance();  </li><li>        s2 = Singleton.getInstance();  </li><li class="alt">        <span class="comment">// 若相等则表示生成的对象是唯一的 </span> </li><li>        System.out.println(s1 == s2);  </li><li class="alt">    }  </li><li>}  </li></ol> 
  <h4 style="text-indent:-35.45pt;margin-left:35.45pt;"><span style="line-height:27px;font-family:'微软雅黑', sans-serif;font-size:12pt;" lang="en-us">2.2.2.<span style="font:7pt 'Times New Roman';"><span class="Apple-converted-space"> </span></span></span><span style="line-height:27px;font-family:'微软雅黑', sans-serif;font-size:12pt;">懒汉似的单例模式<span lang="en-us"></span></span></h4> 
  <p></p> 
  <p class="MsoNormal"><span lang="en-us"></span></p> 
  <p></p> 
  <pre></pre> 
  <ol class="dp-j"><li class="alt"><span class="keyword">class</span> SingletonLazy { </li><li> <span class="comment">// 在内部产生本类的实例化对象 </span> </li><li class="alt"> <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance = <span class="keyword">null</span>; </li><li> </li><li class="alt"> <span class="keyword">private</span> SingletonLazy() { </li><li> } </li><li class="alt"> </li><li> <span class="comment">// 线程安全，确保内存中只有一个实例 </span> </li><li class="alt"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazy getInstance() { </li><li> <span class="comment">// 这个方法比上边有所改进，不用每次都进行生成对象，只是第一次使用时生成实例 </span> </li><li class="alt"> <span class="keyword">if</span> (instance == <span class="keyword">null</span>) { </li><li> instance = <span class="keyword">new</span> SingletonLazy(); </li><li class="alt"> } </li><li> <span class="keyword">return</span> instance; </li><li class="alt"> } </li><li> </li><li class="alt">} </li><li> </li><li class="alt"><span class="keyword">public</span> <span class="keyword">class</span> TestSingletonLazy { </li><li> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String args[]) { </li><li class="alt"> <span class="comment">// TODO Auto-generated method stub </span> </li><li> <span class="comment">// 初始化 </span> </li><li class="alt"> SingletonLazy s1 = <span class="keyword">null</span>; </li><li> SingletonLazy s2 = <span class="keyword">null</span>; </li><li class="alt"> <span class="comment">// 实例化对象 </span> </li><li> s1 = SingletonLazy.getInstance(); </li><li class="alt"> s2 = SingletonLazy.getInstance(); </li><li> <span class="comment">// 若相等则表示生成的对象是唯一的 </span> </li><li class="alt"> System.out.println(s1 == s2); </li><li> } </li><li class="alt"> </li><li>} </li></ol> 
  <h2 style="text-indent:-21.25pt;margin-left:21.25pt;"><span style="line-height:50px;font-family:'微软雅黑', sans-serif;font-size:16pt;" lang="en-us">3.<span style="font:7pt 'Times New Roman';">  <span class="Apple-converted-space"> </span></span></span><span style="line-height:50px;font-family:'微软雅黑', sans-serif;font-size:16pt;" lang="en-us">Spring</span><span style="line-height:50px;font-family:'微软雅黑', sans-serif;font-size:16pt;">源码学习<span lang="en-us"></span></span></h2> 
  <p></p> 
  <h3 style="text-indent:-1cm;margin-left:1cm;"><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;" lang="en-us">3.1.<span style="font:7pt 'Times New Roman';"> <span class="Apple-converted-space"> </span></span></span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;" lang="en-us">Spring</span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;">的原型模式<span lang="en-us"></span></span></h3> 
  <p></p> 
  <p class="MsoNormal"><span lang="en-us"></span></p> 
  <p></p> 
  <pre></pre> 
  <ol class="dp-j"><li class="alt"><span class="keyword">abstract</span> <span class="keyword">class</span> AbstractBeanDefinition <span class="keyword">extends</span> BeanMetadataAttributeAccessor </li><li> <span class="keyword">implements</span> BeanDefinition, Cloneable { </li><li class="alt"> </li><li> <span class="keyword">private</span> String scope = SCOPE_DEFAULT; </li><li class="alt"> <span class="keyword">private</span> <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>; </li><li> <span class="keyword">private</span> <span class="keyword">boolean</span> prototype = <span class="keyword">false</span>; </li><li class="alt"> </li><li> <span class="keyword">public</span> <span class="keyword">void</span> setScope(String scope) { </li><li class="alt"> <span class="keyword">this</span>.scope = scope; </li><li> <span class="keyword">this</span>.singleton = SCOPE_SINGLETON.equals(scope) </li><li class="alt"> || SCOPE_DEFAULT.equals(scope); </li><li> <span class="keyword">this</span>.prototype = SCOPE_PROTOTYPE.equals(scope); </li><li class="alt"> } </li><li> </li><li class="alt"> <span class="keyword">public</span> String getScope() { </li><li> <span class="keyword">return</span> <span class="keyword">this</span>.scope; </li><li class="alt"> } </li><li> </li><li class="alt"> <span class="annotation">@Override</span> </li><li> <span class="keyword">public</span> Object clone() { </li><li class="alt"> <span class="keyword">return</span> cloneBeanDefinition(); </li><li> } </li><li class="alt"> </li><li> <span class="keyword">public</span> <span class="keyword">abstract</span> AbstractBeanDefinition cloneBeanDefinition(); </li><li class="alt">} </li><li> </li><li class="alt"><span class="keyword">public</span> <span class="keyword">class</span> SpringAbstractBeanDefinition { </li><li> </li><li class="alt">} </li></ol> 
  <h3 style="text-indent:-1cm;margin-left:1cm;"><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;" lang="en-us">3.2.<span style="font:7pt 'Times New Roman';"> <span class="Apple-converted-space"> </span></span></span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;" lang="en-us">Spring</span><span style="line-height:32px;font-family:'微软雅黑', sans-serif;font-size:14pt;">的单例模式<span lang="en-us"></span></span></h3> 
  <p></p> 
  <p class="MsoNormal"> </p> 
  <p> </p> 
  <p> </p> 
  <pre></pre> 
  <ol class="dp-j"><li class="alt"><span class="keyword">import</span> java.util.HashMap; </li><li><span class="keyword">import</span> java.util.Map; </li><li class="alt"> </li><li><span class="keyword">class</span> SingletonBeanFactoryLocator <span class="keyword">implements</span> BeanFactoryLocator { </li><li class="alt"> </li><li> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, BeanFactoryLocator&gt; instances = <span class="keyword">new</span> HashMap&lt;String, BeanFactoryLocator&gt;(); </li><li class="alt"> </li><li> <span class="keyword">public</span> SingletonBeanFactoryLocator(String resourceLocation) { </li><li class="alt"> } </li><li> </li><li class="alt"> <span class="keyword">public</span> <span class="keyword">static</span> BeanFactoryLocator getInstance(String selector) </li><li> <span class="keyword">throws</span> BeansException { </li><li class="alt"> String resourceLocation = selector; </li><li> <span class="comment">// 线程安全，确保内存中只有一个实例 </span> </li><li class="alt"> <span class="keyword">synchronized</span> (instances) { </li><li> BeanFactoryLocator bfl = instances.get(resourceLocation); </li><li class="alt"> <span class="keyword">if</span> (bfl == <span class="keyword">null</span>) { </li><li> bfl = <span class="keyword">new</span> SingletonBeanFactoryLocator(resourceLocation); </li><li class="alt"> instances.put(resourceLocation, bfl); </li><li> } </li><li class="alt"> } </li><li> <span class="keyword">return</span> getInstance(<span class="keyword">null</span>); </li><li class="alt"> } </li><li>} </li><li class="alt"> </li><li><span class="keyword">public</span> <span class="keyword">class</span> SpringSingletonBeanFactoryLocator { </li><li class="alt"> </li><li>} </li></ol> 
 </div> 
</div> 
<p>转载于:https://blog.51cto.com/sauron/1093898</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/870e63046c9b004873df1603c027f9e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在虚拟机上运行vxWorks</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c96e86bceb75a93be9a1c008e130449c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">order by排序的字段的值相等，导致两个sql查询出来的显示结果不一样</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>