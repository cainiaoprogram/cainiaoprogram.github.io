<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BlueBell注册功能逻辑及其实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BlueBell注册功能逻辑及其实现" />
<meta property="og:description" content="注册路由 r.POST(&#34;/signup&#34;, controller.SignupHandler) 控制层实现 第一步，获取参数和参数校验 在models包中定义一个注册请求参数的结构体（ParamSignUp），用于将JSON参数绑定至结构体中。
json 的tag用于绑定参数，binding参数是gin内置validator校验的tag，required代表此字段是传入参数中必须要有的，eqfield=xxx，代表此字段与结构体中的xxx字段值需要相等，否则会校验失败，返回错误
package models // 定义请求的参数结构体 // ParamSignUp 注册请求参数 type ParamSignUp struct { Username string `json:&#34;username&#34; binding:&#34;required&#34;` // 代表校验此字段是必须在的 Password string `json:&#34;password&#34; binding:&#34;required&#34;` RePassword string `json:&#34;re_password&#34; binding:&#34;required,eqfield=Password&#34;` } 得到一个注册请求参数结构体指针
p := new(models.ParamSignUp) // 得到一个注册请求参数结构体指针 ps：new返回类型的指针。
gin自带ShouldBindJSON方法将传入参数序列化到p结构体中
if err := c.ShouldBindJSON(p); err != nil { // 请求参数有误，直接返回响应 zap.L().Error(&#34;SignUp with invalid param&#34;, zap.Error(err)) // 判断err类型是不是validator.ValidationErrors类型 errs, ok := err.(validator.ValidationErrors) // 如果不是就返回正常错误 if !ok { c.JSON(http.StatusOK, gin." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3e6914bc9cd99bfead5cd44533a70427/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-06T23:43:37+08:00" />
<meta property="article:modified_time" content="2023-10-06T23:43:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BlueBell注册功能逻辑及其实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>注册路由</h3> 
<pre><code class="language-Go">r.POST("/signup", controller.SignupHandler)</code></pre> 
<h3>控制层实现</h3> 
<h4><strong>第一步，获取参数和参数校验</strong></h4> 
<p>在models包中定义一个注册请求参数的结构体（ParamSignUp），用于将JSON参数绑定至结构体中。</p> 
<p>json 的tag用于绑定参数，binding参数是gin内置validator校验的tag，required代表此字段是传入参数中必须要有的，eqfield=xxx，代表此字段与结构体中的xxx字段值需要相等，否则会校验失败，返回错误</p> 
<pre><code class="language-Go">package models

// 定义请求的参数结构体

// ParamSignUp 注册请求参数
type ParamSignUp struct {
	Username   string `json:"username" binding:"required"` // 代表校验此字段是必须在的
	Password   string `json:"password" binding:"required"`
	RePassword string `json:"re_password" binding:"required,eqfield=Password"`
}
</code></pre> 
<p>得到一个注册请求参数结构体指针</p> 
<pre><code class="language-Go">p := new(models.ParamSignUp) // 得到一个注册请求参数结构体指针</code></pre> 
<p>ps：new返回类型的指针。</p> 
<p>gin自带ShouldBindJSON方法将传入参数序列化到p结构体中</p> 
<pre><code class="language-Go">	if err := c.ShouldBindJSON(p); err != nil {
		// 请求参数有误，直接返回响应
		zap.L().Error("SignUp with invalid param", zap.Error(err))
		// 判断err类型是不是validator.ValidationErrors类型
		errs, ok := err.(validator.ValidationErrors)
		// 如果不是就返回正常错误
		if !ok {
			c.JSON(http.StatusOK, gin.H{
				"msg": "请求参数错误",
			})
			return
		}
		// 如果是就返回翻译过后的内容
		c.JSON(http.StatusOK, gin.H{
			"msg": errs.Translate(trans),
		})
		return
	}</code></pre> 
<h5>Validator翻译器完整代码</h5> 
<p>由于validator校验返回的错误信息是英文，为方便用户读取，做一个翻译器，将错误类型为validator.ValidationErrors的内容翻译成中文。</p> 
<pre><code class="language-Go">package controller

/*
用于翻译validator.ValidationErrors错误的内容
*/
import (
	"bluebell/models"
	"fmt"
	"github.com/gin-gonic/gin/binding"
	"github.com/go-playground/locales/en"
	"github.com/go-playground/locales/zh"
	ut "github.com/go-playground/universal-translator"
	"github.com/go-playground/validator/v10"
	enTranslations "github.com/go-playground/validator/v10/translations/en"
	zhTranslations "github.com/go-playground/validator/v10/translations/zh"
	"reflect"
	"strings"
)

// 定义一个全局翻译器T
var trans ut.Translator

// InitTrans 初始化翻译器
func InitTrans(locale string) (err error) {
	// 修改gin框架中的Validator引擎属性，实现自定制
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {

		// 注册一个获取json tag的自定义方法
		v.RegisterTagNameFunc(func(fld reflect.StructField) string {
			name := strings.SplitN(fld.Tag.Get("json"), ",", 2)[0]
			if name == "-" {
				return ""
			}
			return name
		})

		// 为SignUpParam注册自定义校验方法
		v.RegisterStructValidation(SignUpParamStructLevelValidation, models.ParamSignUp{})

		zhT := zh.New() // 中文翻译器
		enT := en.New() // 英文翻译器

		// 第一个参数是备用（fallback）的语言环境
		// 后面的参数是应该支持的语言环境（支持多个）
		// uni := ut.New(zhT, zhT) 也是可以的
		uni := ut.New(enT, zhT, enT)

		// locale 通常取决于 http 请求头的 'Accept-Language'
		var ok bool
		// 也可以使用 uni.FindTranslator(...) 传入多个locale进行查找
		trans, ok = uni.GetTranslator(locale)
		if !ok {
			return fmt.Errorf("uni.GetTranslator(%s) failed", locale)
		}

		// 注册翻译器
		switch locale {
		case "en":
			err = enTranslations.RegisterDefaultTranslations(v, trans)
		case "zh":
			err = zhTranslations.RegisterDefaultTranslations(v, trans)
		default:
			err = enTranslations.RegisterDefaultTranslations(v, trans)
		}
		return
	}
	return
}

// removeTopStruct 去除提示信息中的结构体名称
func removeTopStruct(fields map[string]string) map[string]string {
	res := map[string]string{}
	for field, err := range fields {
		res[field[strings.Index(field, ".")+1:]] = err
	}
	return res
}

// SignUpParamStructLevelValidation 自定义SignUpParam结构体校验函数
func SignUpParamStructLevelValidation(sl validator.StructLevel) {
	su := sl.Current().Interface().(models.ParamSignUp)

	if su.Password != su.RePassword {
		// 输出错误提示信息，最后一个参数就是传递的param
		sl.ReportError(su.RePassword, "re_password", "RePassword", "eqfield", "password")
	}
}
</code></pre> 
<h4><strong>第二步，业务处理，logic层进行业务处理</strong></h4> 
<p>调用logic包中的Signup方法，实现用户插入数据库的操作，完成注册的功能。</p> 
<pre><code class="language-Go">// 2.业务处理 logic层进行业务处理
	if err := logic.Signup(p); err != nil {
		c.JSON(http.StatusOK, gin.H{
			"msg": err.Error(),
		})
		return
	}</code></pre> 
<h5>Signup方法实现</h5> 
<p><strong>第一步，校验用户是否存在</strong></p> 
<pre><code class="language-Go">// 1.校验用户是否存在
	if err := mysql.CheckUserExist(p); err != nil {
		return err
	}</code></pre> 
<p>调用mysql中的CheckUserExist方法，判断该用户是否已存在，如果存在，说明该用户已经注册过了。</p> 
<h6>mysql包中CheckUserExist方法实现</h6> 
<pre><code class="language-Go">// CheckUserExist 判断用户是否存在
func CheckUserExist(user *models.ParamSignUp) error {
	sqlStr := "select count(user_id) from user where username = ?"
	var count int
	if err := db.Get(&amp;count, sqlStr, user.Username); err != nil {
		return err
	}
	if count &gt; 0 {
		return errors.New("用户已存在")
	}
	return nil
}</code></pre> 
<p>搜索相关用户名，统计个数，判断是否大于0，大于0即是存在。</p> 
<p><strong>第二步，雪花算法生成UID，生成一个用户实例</strong></p> 
<p>调用snowflake包中的GenID获取UID</p> 
<pre><code class="language-Go">// 2.生成UID
	UID := snowflake.GenID()</code></pre> 
<p>在models表中创建一个用户User结构体，对应数据库中的user表，相互绑定。</p> 
<pre><code class="language-Go">package models

/*
构造user结构体与数据库中user表相对应，相互绑定
*/

type User struct {
	UserID   int64  `db:"user_id"`
	UserName string `db:"username"`
	PassWord string `db:"password"`
}
</code></pre> 
<p>生成一个用户实例</p> 
<pre><code class="language-Go">// 生成一个用户实例
	user := &amp;models.User{
		UserID:   UID,
		UserName: p.Username,
		PassWord: p.Password,
	}</code></pre> 
<p><strong>第三步，保存到数据库</strong></p> 
<p>调用mysql包中的InsertUser方法，传入用户实例</p> 
<pre><code class="language-Go">// 3.保存到数据库
	if err := mysql.InsertUser(user); err != nil {
		return err
	}</code></pre> 
<h6>mysql包中InsertUser方法实现</h6> 
<pre><code class="language-Go">// InsertUser 向数据库中插入一条用户数据
func InsertUser(user *models.User) error {
	sqlStr := "insert into user(user_id,username,password) values(?,?,?)"
	user.PassWord = encryptPassword(user.PassWord)
	if _, err := db.Exec(sqlStr, user.UserID, user.UserName, user.PassWord); err != nil {
		return err
	}
	return nil
}
</code></pre> 
<p>创建相关sql语句，执行写入数据库。</p> 
<h6 style="background-color:transparent;"><strong>mysql包中encryptPassword方法实现</strong></h6> 
<p>数据库中不能存储明文密码，所以要对密码进行加密。</p> 
<pre><code class="language-Go">// 对密码进行加密
func encryptPassword(oPassword string) string {
	h := md5.New()
	h.Write([]byte(secret))
	return hex.EncodeToString(h.Sum([]byte(oPassword)))
}</code></pre> 
<h6> logic/Signup完整代码</h6> 
<pre><code class="language-Go">package logic

import (
	"bluebell/dao/mysql"
	"bluebell/models"
	"bluebell/pkg/snowflake"
)

func Signup(p *models.ParamSignUp) error {
	// 1.校验用户是否存在
	if err := mysql.CheckUserExist(p); err != nil {
		return err
	}
	// 2.生成UID
	UID := snowflake.GenID()
	// 生成一个用户实例
	user := &amp;models.User{
		UserID:   UID,
		UserName: p.Username,
		PassWord: p.Password,
	}
	// 3.保存到数据库
	if err := mysql.InsertUser(user); err != nil {
		return err
	}
	return nil
}</code></pre> 
<h4>第三步，返回响应</h4> 
<p>如果没有任何报错，则返回success</p> 
<pre><code class="language-Go">// 3.返回响应
	c.JSON(http.StatusOK, gin.H{
		"msg": "success",
	})</code></pre> 
<h4>控制层完整代码</h4> 
<pre><code class="language-Go">package controller

import (
	"bluebell/logic"
	"bluebell/models"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"go.uber.org/zap"
	"net/http"
)

func SignupHandler(c *gin.Context) {
	// 1.获取参数和参数校验
	p := new(models.ParamSignUp) // 得到一个注册请求参数结构体指针
	if err := c.ShouldBindJSON(p); err != nil {
		// 请求参数有误，直接返回响应
		zap.L().Error("SignUp with invalid param", zap.Error(err))
		// 判断err类型是不是validator.ValidationErrors类型
		errs, ok := err.(validator.ValidationErrors)
		// 如果不是就返回正常错误
		if !ok {
			c.JSON(http.StatusOK, gin.H{
				"msg": "请求参数错误",
			})
			return
		}
		// 如果是就返回翻译过后的内容
		c.JSON(http.StatusOK, gin.H{
			"msg": errs.Translate(trans),
		})
		return
	}
	// 2.业务处理 logic层进行业务处理
	if err := logic.Signup(p); err != nil {
		c.JSON(http.StatusOK, gin.H{
			"msg": err.Error(),
		})
		return
	}
	// 3.返回响应
	c.JSON(http.StatusOK, gin.H{
		"msg": "success",
	})
	return
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9bcdb5054a4eea30c0daa0da7dc1970/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spring boot图片上传，存到数据库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ff023d6be6fe313fa451bf0273f3a9c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">汉字编码技術與標準</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>