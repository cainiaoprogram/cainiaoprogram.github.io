<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Node】npm使用手册 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Node】npm使用手册" />
<meta property="og:description" content="npm是什么? 包管理工具 npm （node package manager）这个包管理器工具随着Node.js 的安装一起被安装到了用户的电脑上 ,npm由三个独立的部分组成：
网站注册表（registry）命令行工具 (CLI) 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。
注册表 是一个巨大的数据库，保存了每个包（package）的信息。
CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。
查看已安装的 npm 软件包 npm list npm list -g 也一样，但适用于全局安装的软件包。
安装npm软件包 有两种方式用来安装 npm 包：本地安装和全局安装。至于选择哪种方式来安装，取决于我们如何使用这个包。
如果你自己的模块依赖于某个包，并通过 Node.js 的 require 加载，那么你应该选择本地安装，这种方式也是 npm install 命令的默认行为。如果你想将包作为一个命令行工具，（比如 grunt CLI），那么你应该选择全局安装。 npm install &lt;package_name&gt; // install可以简写成 i npm i &lt;package_name&gt; 全局安装
npm install -g &lt;package&gt; 卸载npm软件包 若要卸载之前在本地安装（在 node_modules 文件夹使用 npm install &lt;package-name&gt;）的软件包，则从项目的根文件夹（包含 node_modules 文件夹的文件夹）中运行：
npm uninstall &lt;package-name&gt; npm uninstall jquery 如果使用 -S 或 --save 标志，则还会移除 package." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/399638ad1b0a2643749d06475ff843e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-18T17:06:24+08:00" />
<meta property="article:modified_time" content="2023-12-18T17:06:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Node】npm使用手册</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>npm是什么?</h4> 
<p>包管理工具 npm （node package manager）这个包管理器工具随着Node.js 的安装一起被安装到了用户的电脑上 ,npm由三个独立的部分组成：</p> 
<ul><li>网站</li><li>注册表（registry）</li><li>命令行工具 (CLI)</li></ul> 
<p><em><a href="https://link.zhihu.com/?target=https%3A//npmjs.com/" rel="nofollow" title="网站">网站</a></em> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</p> 
<p><em>注册表</em> 是一个巨大的数据库，保存了每个包（package）的信息。</p> 
<p><em><a href="https://link.zhihu.com/?target=https%3A//docs.npmjs.com/cli/npm" rel="nofollow" title="CLI">CLI</a></em> 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。</p> 
<h4>查看已安装的 npm 软件包</h4> 
<pre><code>npm list</code></pre> 
<p><code>npm list -g</code> 也一样，但适用于全局安装的软件包。</p> 
<h4>安装npm软件包</h4> 
<p>有两种方式用来安装 npm 包：<strong>本地安装</strong>和<strong>全局安装</strong>。至于选择哪种方式来安装，取决于我们如何使用这个包。</p> 
<ul><li>如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，那么你应该选择本地安装，这种方式也是 <code>npm install</code> 命令的默认行为。</li><li>如果你想将包作为一个命令行工具，（比如 grunt CLI），那么你应该选择<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.cn/getting-started/installing-npm-packages-globally" rel="nofollow" title="全局安装">全局安装</a>。</li></ul> 
<pre><code>npm install &lt;package_name&gt;
//  install可以简写成 i 
npm i &lt;package_name&gt;</code></pre> 
<p>全局安装</p> 
<pre><code>npm install -g &lt;package&gt;</code></pre> 
<h4>卸载npm软件包</h4> 
<p>若要卸载之前在本地安装（在 <code>node_modules</code> 文件夹使用 <code>npm install &lt;package-name&gt;</code>）的软件包，则从项目的根文件夹（包含 <code>node_modules</code> 文件夹的文件夹）中运行：</p> 
<pre><code>npm uninstall &lt;package-name&gt;
npm uninstall jquery</code></pre> 
<p>如果使用 <code>-S</code> 或 <code>--save</code> 标志，则还会移除 <code>package.json</code> 文件中的引用。</p> 
<p>如果程序包是开发依赖项（列出在 <code>package.json</code> 文件的 devDependencies 中），则必须使用 <code>-D</code> 或 <code>--save-dev</code> 标志从文件中移除：</p> 
<pre><code>npm uninstall -S &lt;package-name&gt;
npm uninstall -D &lt;package-name&gt;</code></pre> 
<p>如果该软件包是全局安装的，则需要添加 <code>-g</code> 或 <code>--global</code> 标志：</p> 
<pre><code>npm uninstall -g &lt;package-name&gt;</code></pre> 
<h4>npm全局和本地</h4> 
<p>本地和全局的软件包之间的主要区别是：</p> 
<ul><li><strong>本地的软件包</strong> 安装在运行 <code>npm install &lt;package-name&gt;</code> 的目录中，并且放置在此目录下的 <code>node_modules</code> 文件夹中。</li><li><strong>全局的软件包</strong> 放在系统中的单独位置（确切的位置取决于设置），无论在何处运行 <code>npm install -g &lt;package-name&gt;</code>。</li></ul> 
<p>在代码中，应该只引入本地的软件包：</p> 
<pre><code>JS
require('package-name')
</code></pre> 
<p>所以何时应该以一种或另一种方式安装？</p> 
<p>通常，所有的软件包都应本地安装。</p> 
<p>这样可以确保计算机中可以有数十个应用程序，并且如果需要，每个应用程序都可以运行不同的版本。</p> 
<p><strong><em>更新全局软件包会使所有的项目都使用新的版本，这可能会导致维护方面的噩梦，因为某些软件包可能会破坏与其他依赖项的兼容性等。</em></strong></p> 
<p>所有的项目都有自己的软件包本地版本，即使这看起来有点浪费资源，但与可能产生的负面影响相比也很小。</p> 
<p>当程序包提供了可从 shell（CLI）运行的可执行命令、且可在项目间复用时，则该程序包应被全局安装。</p> 
<p>也可以在本地安装可执行命令并使用 npx 运行，但是某些软件包最好在全局安装。</p> 
<p>一些流行的全局软件包的示例有：</p> 
<ul><li><code>npm</code></li><li><code>create-react-app</code></li><li><code>vue-cli</code></li><li><code>grunt-cli</code></li><li><code>mocha</code></li><li><code>react-native-cli</code></li><li><code>gatsby-cli</code></li><li><code>forever</code></li><li><code>nodemon</code></li></ul> 
<p>可能已经在系统上安装了一些全局软件包。 可以通过在命令行上运行以下命令查看：</p> 
<pre><code>BASH
npm list -g --depth 0</code></pre> 
<h4>npm语义版本控制</h4> 
<p>如果 Node.js 软件包中有一件很棒的事情，那就是它们都同意使用语义版本控制作为版本编号。</p> 
<p>语义版本控制的概念很简单：所有的版本都有 3 个数字：<code>x.y.z</code>。</p> 
<ul><li>第一个数字是主版本。也可以叫<strong>大版本</strong></li><li>第二个数字是次版本。也可以叫<strong>功能版本</strong></li><li>第三个数字是补丁版本。也可以叫<strong>Bug修复版本</strong></li></ul> 
<p>当发布新的版本时，不仅仅是随心所欲地增加数字，还要遵循以下规则：</p> 
<ul><li>当进行不兼容的 API 更改时，则升级主版本。</li><li>当以向后兼容的方式添加功能时，则升级次版本。</li><li>当进行向后兼容的缺陷修复时，则升级补丁版本。</li></ul> 
<p>该约定在所有编程语言中均被采用，每个 <code>npm</code> 软件包都必须遵守该约定，这一点非常重要，因为整个系统都依赖于此。</p> 
<p>为什么这么重要？</p> 
<p>因为 <code>npm</code> 设置了一些规则，可用于在 <code>package.json</code> 文件中选择要将软件包更新到的版本（当运行 <code>npm update</code> 时）。</p> 
<p>规则使用了这些符号：</p> 
<ul><li><code>^</code></li><li><code>~</code></li><li><code>&gt;</code></li><li><code>&gt;=</code></li><li><code>&lt;</code></li><li><code>&lt;=</code></li><li><code>=</code></li><li><code>-</code></li><li><code>||</code></li></ul> 
<p>这些规则的详情如下：</p> 
<ul><li><code>^</code>: 只会执行不更改最左边非零数字的更新。 如果写入的是 <code>^0.13.0</code>，则当运行 <code>npm update</code> 时，可以更新到 <code>0.13.1</code>、<code>0.13.2</code> 等，但不能更新到 <code>0.14.0</code> 或更高版本。 如果写入的是 <code>^1.13.0</code>，则当运行 <code>npm update</code> 时，可以更新到 <code>1.13.1</code>、<code>1.14.0</code> 等，但不能更新到 <code>2.0.0</code> 或更高版本。</li><li><code>~</code>: 如果写入的是 <code>〜0.13.0</code>，则当运行 <code>npm update</code> 时，会更新到补丁版本：即 <code>0.13.1</code> 可以，但 <code>0.14.0</code> 不可以。</li><li><code>&gt;</code>: 接受高于指定版本的任何版本。</li><li><code>&gt;=</code>: 接受等于或高于指定版本的任何版本。</li><li><code>&lt;=</code>: 接受等于或低于指定版本的任何版本。</li><li><code>&lt;</code>: 接受低于指定版本的任何版本。</li><li><code>=</code>: 接受确切的版本。</li><li><code>-</code>: 接受一定范围的版本。例如：<code>2.1.0 - 2.6.2</code>。</li><li><code>||</code>: 组合集合。例如 <code>&lt; 2.1 || &gt; 2.6</code>。</li></ul> 
<p>可以合并其中的一些符号，例如 <code>1.0.0 || &gt;=1.1.0 &lt;1.2.0</code>，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。</p> 
<pre><code>"dependencies": {
    "vue": "^3.2.25"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^2.3.3",
    "vite": "^2.9.9"
  }</code></pre> 
<h4>node_modules文件夹</h4> 
<p>node_modules 文件夹用来<code>存放所有已安装到项目中的包</code>。require() 导入第三方包时，就是从这个目录中查找并加载包。</p> 
<h4>package-lock.json</h4> 
<p><strong><em>package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。</em></strong></p> 
<p><code>package-lock.json</code>对于 npm 修改<code>node_modules</code>树或<code>package.json</code>. 它描述了生成的确切树，以便后续安装能够生成相同的树，而不管中间依赖项更新如何。</p> 
<ul><li>描述依赖关系树的单一表示，以保证团队成员、部署和持续集成安装完全相同的依赖关系。</li><li>为用户提供一种“时间旅行”到以前状态的工具，<code>node_modules</code>而无需提交目录本身。</li><li>通过可读的源代码控制差异来促进对树更改的更大可见性。</li><li>并通过允许 npm 跳过以前安装的包的重复元数据解析来优化安装过程。</li></ul> 
<h4>安装指定版本的npm包</h4> 
<p>通过@符号指定安装包时的版本号</p> 
<ul><li>@</li></ul> 
<pre><code>npm i moment@2.22.2</code></pre> 
<h4>使用package.json</h4> 
<ul><li><code>version</code> 表明了当前的版本。</li><li><code>name</code> 设置了应用程序/软件包的名称。</li><li><code>description</code> 是应用程序/软件包的简短描述。</li><li><code>main</code> 设置了应用程序的入口点。</li><li><code>private</code> 如果设置为 <code>true</code>，则可以防止应用程序/软件包被意外地发布到 <code>npm</code>。</li><li><code>scripts</code> 定义了一组可以运行的 node 脚本。</li><li><code>dependencies</code> 设置了作为依赖安装的 <code>npm</code> 软件包的列表。</li><li><code>devDependencies</code> 设置了作为开发依赖安装的 <code>npm</code> 软件包的列表。</li><li><code>engines</code> 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li><li><code>browserslist</code> 用于告知要支持哪些浏览器（及其版本）。</li></ul> 
<h4><code>--save</code>安装<code>--save-dev</code>标志</h4> 
<p>添加依赖项的更简单（也更棒）的方法是从命令行执行此操作，使用或 <code>package.json</code>标记<code>npm install</code>命令，具体取决于您希望如何使用该依赖项。<code>--save --save-dev</code></p> 
<p>在<code>package.json</code>'s 下的dependencies 下添加入口</p> 
<p>To add an entry to your <code>package.json</code>'s <code>dependencies</code>:</p> 
<pre><code>npm install &lt;package_name&gt; --save</code></pre> 
<p>To add an entry to your <code>package.json</code>'s <code>devDependencies</code>:</p> 
<pre><code>npm install &lt;package_name&gt; --save-dev</code></pre> 
<h4>进一步了解package.json</h4> 
<h4>多人协作的问题:</h4> 
<p>package.json中必须包含name,version,main这三个属性,分别代表包的名字,版本号,包的入口</p> 
<pre><code>"name": "kblog",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",</code></pre> 
<p>第三方包的体积过大,不方便在团队成员之间共享项目源代码</p> 
<p><strong><em>解决:把node_modules添加到.gitignore忽略文件中</em></strong></p> 
<p><strong><em>package.json中会记录之前安装过哪些包</em></strong>，团队成员拉取代码后直接基于package.json就可以快速把需要的第三方包都安装好（只需要执行一条命令）</p> 
<h4>通过命令快速创建package.json文件</h4> 
<pre><code>npm init -y</code></pre> 
<blockquote>
  项目文件夹的名称一定要使用英文命名，不能出现空格 
 <br> 运行 npm install 命令安装包的时候,npm包概念里工具会自动把包的名称和版本号,记录到package.json中 
</blockquote> 
<h4>dependencies节点</h4> 
<p>专门用来记录您使用 npm install 命令安装了哪些包。</p> 
<h4>devDependencies节点</h4> 
<ul><li>如果某些包只在项目<strong><em>开发阶段</em></strong>会用到，在项目上线之后不会用到，则建议把这些包记录到 <strong><em>devDependencies</em></strong> 节点中。</li><li>与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中</li></ul> 
<h4>开发依赖包</h4> 
<p>To add an entry to your <code>package.json</code>'s <code>devDependencies</code>:</p> 
<pre><code>npm install &lt;package_name&gt; --save-dev
// 指定为开发依赖包，而非核心依赖包
npm i 包名 -D
或者
npm install 包名 --save-dev</code></pre> 
<h4>安装多个包</h4> 
<p>一次安装多个包,分别是jquery 和 art-template,中间用空格隔开</p> 
<pre><code>npm i jquery art-template</code></pre> 
<h4>一次性安装所有的包</h4> 
<pre><code>npm install
或者
npm i</code></pre> 
<blockquote>
  执行npm install 命令时，npm包管理工具会先读取 packagejson 中的dependencies节点 
 <br> 读取到记录的所有依赖包名称和版本号之后，npm 包管理工具会把这些包一次性下载到项目中中 
</blockquote> 
<h4>npm包分类</h4> 
<h4>开发依赖包</h4> 
<p>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）</p> 
<h4>核心依赖包</h4> 
<p>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</p> 
<h4>全局包目录地址</h4> 
<p>在执行npm install命令时 , 如果提供了-g参数 ,则会把包安装为全局包</p> 
<p>全局包会被安装到C:\Users\Kevin\AppData\Roaming\npm\node_modules目录下</p> 
<p></p> 
<p></p> 
<p></p> 
<blockquote>
  只有 
 <strong>工具性的包</strong> ,才会有全局安装的必要性,因为它们提供了好用的终端命令 
</blockquote> 
<h4>i5ting_toc将md转为html</h4> 
<p>i5ting_toc是一个可以把md文档转为html页面的小工具</p> 
<h4>开发属于自己的包</h4> 
<h4>了解需要实现的功能</h4> 
<h4>初始化包的基本解构</h4> 
<p>新建 <code>project_name-tools</code> 文件夹，作为包的根目录</p> 
<p>在 <code>project_name-tools</code> 文件夹中，新建如下三个文件：</p> 
<ul><li><code>package.json</code> (包管理配置文件)</li><li><code>index.js</code> (包的入口文件) <strong><em>通过require导入这个文件</em></strong></li><li><code>README.md</code> (包的说明文档)</li></ul> 
<h4>初始化package.json配置文件</h4> 
<pre><code>{
  "name": "project_name-tools",//名字不能是npm已经有的
  "version": "1.1.0",//版本
  "main": "index.js",//入口文件
  "description": "提供了XXX功能",
  "keywords": [//搜索关键字
    "XXX",
    "XXX",
    "XXX"
  ],
  "license": "ISC"
}
</code></pre> 
<h4>在index.js中定义格式化时间的方法</h4> 
<h4>package.json中main属性</h4> 
<p>package.json中main属性的作用:</p> 
<ol><li><code>Node</code> 在使用 <code>require</code> 导入某个路径的时候，发现没有具体的文件，就会看这个路径下查看是否有 <code>package.json</code> 这个文件</li><li>如果有，则查看是否有 <code>main</code> 这个属性</li><li>而如果main属性也有，则指定 <code>main</code> 属性对应的文件作为要执行的文件</li></ol> 
<h4>将不同的功能进行模块化的拆分</h4> 
<p>index.js中不写太多代码，主要负责导入其他模块，并把这些模块中需要向外暴露的成员，统一往外暴露。</p> 
<h4>把包发布到npm上</h4> 
<p>将终端切换到包的根目录之后 .运行 <code>npm publish</code> 命令，即可将包发布到 <code>npm</code> 上</p> 
<blockquote>
  注意:包名不能雷同 
</blockquote> 
<h4>删除已发布的包</h4> 
<p><code>npm unpublish 包名 --force</code></p> 
<ul><li><code>npm unpublish</code> 命令只能删除 72 小时以内发布的包</li><li><code>npm unpublish</code> 删除的包，<strong>在 24 小时内不允许重复发布</strong></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65f1475a664af12294d0fdf515e2c96b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">5.docker容器及相关命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/11ad7c2a225400971c67d54af409aa70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">日期取值(年月日…)方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>