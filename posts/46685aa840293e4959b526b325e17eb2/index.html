<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue-history模式的SpringBoot配置以及对错误状态的处理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue-history模式的SpringBoot配置以及对错误状态的处理" />
<meta property="og:description" content="Vue-history模式的SpringBoot配置以及对错误状态的处理 使用history模式 vue-router 默认是hash模式的，但是连中文官网都承认hash 模式的url很丑，的确像我这种小渣渣都能一眼看出这是个单页面无疑了。比如这样http://xxx.com/#/home/index 官网提出了一种能让url能像http://xxx.com/home/index这样显示的办法，就是利用HTML5的history属性
vue-router配置 配置方法很简单： history模式：在实例Router的地方加入mode: &#39;history&#39; 根路由：加入base: &#39;base&#39;（这么做是因为服务器只需要对base相关的url进行转发操作就可以了，同时也能对404画面进行处理）
那么我们刚才的路由正确访问方法应当时这样的：http://xxx.com/base/home/index
但是这个模式的缺点就是需要后台对这种连接做一些处理，否则get不到对应的资源只会返回404。
后台配置 我用SpringBoot框架随便定义了一个controller：
@RequestMapping(value={ &#34;/base&#34;, &#34;/base/**&#34; }) public String fowardRouter(){ return &#34;forward://index.html&#34;; } （@RequestMapping的value值可以是多个，以上是对根路由相关的url进行相应处理） 如果访问根路由下不存在的路由：http://xxx.com/base/notExists，会调用fowardRouter()，将会出现空白页； 如果连根路由都没写：http://xxx.com/randomstr/notExists，那么会由服务器返回404
以下是对vue-router单页面和springboot前后分离框架的异常状态处理
错误状态处理 在上面这种配置的情况下，找不到页面有可能有两种情况，一种是找不到的路由，一种就是服务器返回的404，找不到路由的情况我们还是得靠前台处理，但服务器其返回的所有异常状态，SpringBoot都会返回默认的error页面
针对不存在的路由的处理 使用vue-router是有可能发生用户随意修改路由地址，造成访问了不存在的路由出现空白页面的情况。结合官网对HTML5 history模式给出的警告，我们可以在配置路由时增加一个路由地址，覆盖所有的路由情况。
routes: [ { path: &#39;*&#39;, component: ERROR404 }, ...其他路由... ] ERROR404是我们应该要自定义的组件，渲染不存在的路由的画面
由服务器返回的异常状态的处理 上面说过SpringBoot会根据错误状态码返回指定的页面，网上也有很多资源关于如何在发生错误时指定到自定义模板上。不过我想处理的方式是所有的错误页面全都由单页面组件来完成，这样可能就需要不管是不是ajax请求我们都不能用服务器渲染的方式，只能用返回JSON数据的方式来统一处理。 下面是SpringBoot服务器对此状况的处理：
拦截错误状态请求，主动抛异常 首先第一步重写了SpringBoot对错误页面的默认处理，我们需要实现ErrorController：
@Controller public class MainErrorController implements ErrorController { private static final String ERROR_PATH = &#34;/error&#34;; @Override public String getErrorPath() { return ERROR_PATH; } @RequestMapping(ERROR_PATH) public Object handleError(HttpServletRequest request) { Integer statusCode = (Integer) request." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/46685aa840293e4959b526b325e17eb2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-22T11:50:12+08:00" />
<meta property="article:modified_time" content="2018-03-22T11:50:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue-history模式的SpringBoot配置以及对错误状态的处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="vue-history模式的springboot配置以及对错误状态的处理">Vue-history模式的SpringBoot配置以及对错误状态的处理</h2> 
<h3 id="使用history模式">使用history模式</h3> 
<p>vue-router 默认是hash模式的，但是连中文官网都承认hash 模式的url很丑，的确像我这种小渣渣都能一眼看出这是个单页面无疑了。比如这样<code>http://xxx.com/#/home/index</code> <br> 官网提出了一种能让url能像<code>http://xxx.com/home/index</code>这样显示的办法，就是利用HTML5的history属性</p> 
<h4 id="vue-router配置">vue-router配置</h4> 
<p>配置方法很简单： <br> <strong>history模式</strong>：在实例Router的地方加入<code>mode: 'history'</code> <br> <strong>根路由</strong>：加入<code>base: 'base'</code>（这么做是因为服务器只需要对base相关的url进行转发操作就可以了，同时也能对404画面进行处理）</p> 
<p>那么我们刚才的路由正确访问方法应当时这样的：<code>http://xxx.com/base/home/index</code></p> 
<p>但是这个模式的<strong>缺点就是需要后台对这种连接做一些处理，否则get不到对应的资源只会返回404</strong>。</p> 
<h4 id="后台配置">后台配置</h4> 
<p>我用SpringBoot框架随便定义了一个controller：</p> 
<pre class="prettyprint"><code class=" hljs cs">@RequestMapping(<span class="hljs-keyword">value</span>={
        <span class="hljs-string">"/base"</span>,
        <span class="hljs-string">"/base/**"</span>
})
<span class="hljs-keyword">public</span> String <span class="hljs-title">fowardRouter</span>(){
    <span class="hljs-keyword">return</span> <span class="hljs-string">"forward://index.html"</span>;
}</code></pre> 
<p>（@RequestMapping的value值可以是多个，以上是对根路由相关的url进行相应处理） <br> 如果访问根路由下不存在的路由：<code>http://xxx.com/base/notExists</code>，会调用fowardRouter()，将会出现空白页； <br> 如果连根路由都没写：<code>http://xxx.com/randomstr/notExists</code>，那么会由服务器返回404</p> 
<p>以下是对vue-router单页面和springboot前后分离框架的异常状态处理</p> 
<h3 id="错误状态处理">错误状态处理</h3> 
<p>在上面这种配置的情况下，找不到页面有可能有两种情况，一种是找不到的路由，一种就是服务器返回的404，找不到路由的情况我们还是得靠前台处理，但服务器其返回的所有异常状态，SpringBoot都会返回默认的error页面</p> 
<h4 id="针对不存在的路由的处理">针对不存在的路由的处理</h4> 
<p>使用vue-router是有可能发生用户随意修改路由地址，造成访问了不存在的路由出现空白页面的情况。结合官网对HTML5 history模式给出的警告，我们可以在配置路由时增加一个路由地址，覆盖所有的路由情况。</p> 
<pre class="prettyprint"><code class=" hljs r">routes: [
   {
     path: <span class="hljs-string">'*'</span>,
     component: ERROR404
   },
   <span class="hljs-keyword">...</span>其他路由<span class="hljs-keyword">...</span>
 ]</code></pre> 
<p><code>ERROR404</code>是我们应该要自定义的组件，渲染不存在的路由的画面</p> 
<h4 id="由服务器返回的异常状态的处理">由服务器返回的异常状态的处理</h4> 
<p>上面说过SpringBoot会根据错误状态码返回指定的页面，网上也有很多资源关于如何在发生错误时指定到自定义模板上。不过我想处理的方式是所有的错误页面全都由单页面组件来完成，这样可能就需要不管是不是ajax请求我们都不能用服务器渲染的方式，只能用返回JSON数据的方式来统一处理。 <br> 下面是SpringBoot服务器对此状况的处理：</p> 
<h5 id="拦截错误状态请求主动抛异常">拦截错误状态请求，主动抛异常</h5> 
<p>首先第一步重写了SpringBoot对错误页面的默认处理，我们需要实现ErrorController：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainErrorController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ErrorController</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ERROR_PATH = <span class="hljs-string">"/error"</span>;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getErrorPath</span>() {
        <span class="hljs-keyword">return</span> ERROR_PATH;
    }

    <span class="hljs-annotation">@RequestMapping</span>(ERROR_PATH)
    <span class="hljs-keyword">public</span> Object <span class="hljs-title">handleError</span>(HttpServletRequest request) 
    {
        Integer statusCode = (Integer) request.getAttribute(<span class="hljs-string">"javax.servlet.error.status_code"</span>);
        <span class="hljs-keyword">switch</span> (statusCode) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoHandlerFoundException(request.getMethod(), request.getRequestURI(), <span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:
        <span class="hljs-comment">// 这是一个自定义的异常</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException();
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
        }
        System.out.println(<span class="hljs-string">"其他错误啦"</span>+statusCode);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}</code></pre> 
<p>我列举出了少数情况，但是都在各种异常状态下主动抛异常，其实我完全不用这么做的，如果用服务器渲染的方式，各自返回相应的模板url即可，比如你自定义了一个好看的404页面，你直接<code>return "error404"</code>就结束了。 <br> 但我的工作还未停止。 <br> 我之所以没在这里直接返回JSON数据，是因为所需要返回的格式不一样。 <br> 例如404和500，针对于404我可能需要重定向到我的单页面的html：<code>"forward://index.html"</code> <br> 但对于500，我只想返回json数据即可，比如<code>{"errorStatus", 500}</code>，那么如果我都放在这个handleError方法下处理，就需要这个方法既能够@Response的方式处理，又能够以返回模板url的方式处理，我是不知道能不能实现，反正我实现不了。</p> 
<h5 id="处理全局异常">处理全局异常</h5> 
<p>新建一个注解了@ControllerAdvice的类，就能够对Controller级别的异常进行拦截处理。下面是我对刚才各种状态主动抛的异常的处理。</p> 
<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">@ControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> GlobalExceptionHandler {

    <span class="hljs-keyword">@ExceptionHandler</span>(UsernameNotFoundException.<span class="hljs-keyword">class</span>)
    <span class="hljs-keyword">@ResponseBody</span>
    Object handleException(){
        Map&lt;String,Object&gt; ret = <span class="hljs-keyword">new</span> HashedMap&lt;&gt;();
        ret.put(<span class="hljs-string">"errorStatus"</span>, <span class="hljs-number">401</span>);
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-keyword">@ExceptionHandler</span>(NoHandlerFoundException.<span class="hljs-keyword">class</span>)
    String handleException404(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward://index.html"</span>;
    }

    <span class="hljs-keyword">@ExceptionHandler</span>(MyException.<span class="hljs-keyword">class</span>)
    <span class="hljs-keyword">@ResponseBody</span>
    Object handleException2(){
        Map&lt;String,Object&gt; ret = <span class="hljs-keyword">new</span> HashedMap&lt;&gt;();
        ret.put(<span class="hljs-string">"errorStatus"</span>, <span class="hljs-number">500</span>);
        <span class="hljs-keyword">return</span> ret;
    }
}</code></pre> 
<p>我上面是对401状态的处理有点随意了，大家不要效仿，以后补全如何精确的处理认证失败状态。</p> 
<p>只要在方法上注解ExceptionHandler并添加要处理的异常类，就可以对异常情况分门别类的进行处理了。 <br> 除了404是重新跳转回去以错误路由方式处理，以上大多处理方式都是返回JSON的方式<code>"errorStatus", 500</code>，然后在前台用拦截器来处理：</p> 
<h5 id="vue-resource拦截器">vue-resource拦截器</h5> 
<p>所有由服务器返回的自定义状态，我们都可以用vue-resoursse的拦截器来处理 <br> 前提是我们已经引入了此模块<code>import VueResource from 'vue-resource'</code></p> 
<pre class="prettyprint"><code class=" hljs coffeescript">Vue.http.interceptors.push<span class="hljs-function"><span class="hljs-params">((request, next) =&gt; {
  next((response) =&gt; {
    <span class="hljs-reserved">let</span> errorStatus = response.data.errorStatus
    <span class="hljs-keyword">if</span> (!errorStatus) {
      <span class="hljs-keyword">return</span> response
    }
    <span class="hljs-keyword">if</span> (errorStatus === <span class="hljs-number">401</span>) {
      <span class="hljs-keyword">if</span> (request.url === <span class="hljs-string">'/login'</span>) {
        store.state.logins = <span class="hljs-string">'401'</span>
      }
      router.push(<span class="hljs-string">'/login'</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errorStatus === <span class="hljs-number">500</span>) {
      store.state.lastRouter = router.currentRoute.fullPath
      router.push(<span class="hljs-string">'/error/syseeror500'</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errorStatus === <span class="hljs-number">404</span>) {
      store.state.lastRouter = router.currentRoute.fullPath
      router.push(<span class="hljs-string">'/error/syseeror404'</span>)
    }
    <span class="hljs-keyword">return</span> response
  })
})</span></span></code></pre> 
<p><code>/error/syseerorxxx</code>都是路由地址，指定了我自定义的组件 <br> vue-resource的interceptors的push方法为我们提供一个在每次http请求响应后优先执行的函数，这个函数的第一个参数request即请求体，next是一个以response为参数的回调函数。</p> 
<h4 id="我的处理方式不好">我的处理方式不好</h4> 
<ul><li>我不知我是不是应该定义几个模板由服务器来渲染，可能会简单的多</li><li>如果非要以我的方式，有没有更简化的可能？</li></ul> 
<p>网上有说用重写各种异常状态的默认请求地址：</p> 
<pre class="prettyprint"><code class=" hljs axapta">@Bean
<span class="hljs-keyword">public</span> EmbeddedServletContainerCustomizer containerCustomizer(
        ConfigurableEmbeddedServletContainer configurableEmbeddedServletContainer) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EmbeddedServletContainerCustomizer() {
        @Override
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> customize(ConfigurableEmbeddedServletContainer <span class="hljs-keyword">container</span>) {
            <span class="hljs-keyword">container</span>.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, <span class="hljs-string">"/error/500"</span>));
            <span class="hljs-keyword">container</span>.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="hljs-string">"/error/400"</span>));
            <span class="hljs-keyword">container</span>.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="hljs-string">"/error/404"</span>));
            <span class="hljs-keyword">container</span>.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(HttpStatus.BAD_GATEWAY, <span class="hljs-string">"/error/500"</span>));
            <span class="hljs-keyword">container</span>.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(Throwable.class, <span class="hljs-string">"/error/500"</span>));
            <span class="hljs-keyword">container</span>.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(Exception.class, <span class="hljs-string">"/error/500"</span>));
        }
    };
}</code></pre> 
<p>然后我们只需在MainErrorController中增加对应的处理方法即可，我试了没好用，如果有清楚的朋友希望多多提意见。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ab811483ea3d8f7d9de36828e8e5c26/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一个前序遍历序列和一个中序遍历序列可以确定一颗唯一的二叉树。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c4b2621471ca2b9d2bc71779b242071/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sentry部署整理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>