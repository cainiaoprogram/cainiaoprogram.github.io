<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>共享内存shmget传输数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="共享内存shmget传输数据" />
<meta property="og:description" content="共享内存的接口函数以及指令
1.查看系统中的共享存储段
ipcs -m 删除系统中的共享存储段 ipcrm -m [shmid] 3.shmget ( )：创建共享内存
int shmget(key_t key, size_t size, int shmflg); [参数key]：由ftok生成的key标识，标识系统的唯一IPC资源。 [参数size]：需要申请共享内存的大小。在操作系统中，申请内存的最小单位为页，一页是4k字节，为了避免内存碎片，我们一般申请的内存大小为页的整数倍。 [参数shmflg]：如果要创建新的共享内存，需要使用IPC_CREAT，IPC_EXCL，如果是已经存在的，可以使用IPC_CREAT或直接传0。 [返回值]：成功时返回一个新建或已经存在的的共享内存标识符，取决于shmflg的参数。失败返回-1并设置错误码。 4.shmat ( )：挂接共享内存
void *shmat(int shmid, const void *shmaddr, int shmflg); [参数shmid]：共享存储段的标识符。 [参数*shmaddr]：shmaddr = 0，则存储段连接到由内核选择的第一个可以地址上（推荐使用）。 [参数shmflg]：若指定了SHM_RDONLY位，则以只读方式连接此段，否则以读写方式连接此段。 [返回值]：成功返回共享存储段的指针（虚拟地址），并且内核将使其与该共享存储段相关的shmid_ds结构中的shm_nattch计数器加1（类似于引用计数）；出错返回-1。 5.shmdt ( )：去关联共享内存
当一个进程不需要共享内存的时候，就需要去关联。该函数并不删除所指定的共享内存区，而是将之前用shmat函数连接好的共享内存区脱离目前的进程。
int shmdt(const void *shmaddr); [参数*shmaddr]：连接以后返回的地址。 [返回值]：成功返回0，并将shmid_ds结构体中的 shm_nattch计数器减1；出错返回-1。 6.shmctl ( )：销毁共享内存
int shmctl(int shmid, int cmd, struct shmid_ds *buf); [参数shmid]：共享存储段标识符。 [参数cmd]：指定的执行操作，设置为IPC_RMID时表示可以删除共享内存。 [参数*buf]：设置为NULL即可。 [返回值]：成功返回0，失败返回-1。 模拟共享内存
我们用server来创建共享存储段，用client获取共享存储段的标识符，二者关联起来之后server将数据写入共享存储段，client从共享区读取数据。通信结束之后server与client断开与共享区的关联，并由server释放共享存储段。
#include &lt;unistd.h&gt; #include &lt;stdlib." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5600e017e6e66a698004fa9ffef26d4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T10:45:33+08:00" />
<meta property="article:modified_time" content="2023-03-15T10:45:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">共享内存shmget传输数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">共享内存的接口函数以及指令</p> 
 <p style="">1.查看系统中的共享存储段</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">ipcs -m</code></pre> 
 <blockquote class="kdocs-blockquote" style="">
   删除系统中的共享存储段 
 </blockquote> 
 <pre class="kdocs-cpp"><code class="language-cpp">ipcrm -m [shmid]</code></pre> 
 <p style="">3.shmget ( )：创建共享内存</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int shmget(key_t key, size_t size, int shmflg);</code></pre> 
 <blockquote class="kdocs-blockquote" style="">
   [参数key]：由ftok生成的key标识，标识系统的唯一IPC资源。 
  <br>[参数size]：需要申请共享内存的大小。在操作系统中，申请内存的最小单位为页，一页是4k字节，为了避免内存碎片，我们一般申请的内存大小为页的整数倍。 
  <br>[参数shmflg]：如果要创建新的共享内存，需要使用IPC_CREAT，IPC_EXCL，如果是已经存在的，可以使用IPC_CREAT或直接传0。 
  <br>[返回值]：成功时返回一个新建或已经存在的的共享内存标识符，取决于shmflg的参数。失败返回-1并设置错误码。 
 </blockquote> 
 <p style="">4.shmat ( )：挂接共享内存</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void *shmat(int shmid, const void *shmaddr, int shmflg);</code></pre> 
 <blockquote class="kdocs-blockquote" style="">
   [参数shmid]：共享存储段的标识符。 
  <br>[参数*shmaddr]：shmaddr = 0，则存储段连接到由内核选择的第一个可以地址上（推荐使用）。 
  <br>[参数shmflg]：若指定了SHM_RDONLY位，则以只读方式连接此段，否则以读写方式连接此段。 
  <br>[返回值]：成功返回共享存储段的指针（虚拟地址），并且内核将使其与该共享存储段相关的shmid_ds结构中的shm_nattch计数器加1（类似于引用计数）；出错返回-1。 
 </blockquote> 
 <p style="">5.shmdt ( )：去关联共享内存</p> 
 <p style="">当一个进程不需要共享内存的时候，就需要去关联。该函数并不删除所指定的共享内存区，而是将之前用shmat函数连接好的共享内存区脱离目前的进程。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int shmdt(const void *shmaddr);</code></pre> 
 <blockquote class="kdocs-blockquote" style="">
   [参数*shmaddr]：连接以后返回的地址。 
  <br>[返回值]：成功返回0，并将shmid_ds结构体中的 shm_nattch计数器减1；出错返回-1。 
 </blockquote> 
 <p style="">6.shmctl ( )：销毁共享内存</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></pre> 
 <blockquote class="kdocs-blockquote" style="">
   [参数shmid]：共享存储段标识符。 
  <br>[参数cmd]：指定的执行操作，设置为IPC_RMID时表示可以删除共享内存。 
  <br>[参数*buf]：设置为NULL即可。 
  <br>[返回值]：成功返回0，失败返回-1。 
 </blockquote> 
 <p style="">模拟共享内存</p> 
 <p style="">我们用server来创建共享存储段，用client获取共享存储段的标识符，二者关联起来之后server将数据写入共享存储段，client从共享区读取数据。通信结束之后server与client断开与共享区的关联，并由server释放共享存储段。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/shm.h&gt;
#include "shmdata.h"

int main()
{
    int running = 1;
    void *shm = NULL;
    struct shared_use_st *shared = NULL;
    char buffer[BUFSIZ + 1]; // 用于保存输入的文本
    int shmid;
    // 创建共享内存
    shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT);
    if (shmid == -1)
    {
        fprintf(stderr, "shmget failed\n");
        exit(EXIT_FAILURE);
    }
    // 将共享内存连接到当前进程的地址空间
    shm = shmat(shmid, (void *)0, 0);
    if (shm == (void *)-1)
    {
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }
    printf("Memory attached at %X\n", (int)shm);
    // 设置共享内存
    shared = (struct shared_use_st *)shm;
    while (running) // 向共享内存中写数据
    {
        // 数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本
        while (shared-&gt;written == 1)
        {
            sleep(1);
            printf("Waiting...\n");
        }
        // 向共享内存中写入数据
        printf("Enter some text: ");
        fgets(buffer, BUFSIZ, stdin);
        strncpy(shared-&gt;text, buffer, TEXT_SZ);
        // 写完数据，设置written使共享内存段可读
        shared-&gt;written = 1;
        // 输入了end，退出循环（程序）
        if (strncmp(buffer, "end", 3) == 0)
            running = 0;
    }
    sleep(1);
    puts("123");
    shared = (struct shared_use_st *)shm;
    shared-&gt;written = 0;
    running = 1;
    puts("123");
    while (running) // 读取共享内存中的数据
    {
    
        // 没有进程向共享内存定数据有数据可读取
        if (shared-&gt;written != 0)
        {
            printf("You wrote: %s", shared-&gt;text);
            sleep(rand() % 3);
            // 读取完数据，设置written使共享内存段可写
            shared-&gt;written = 0;
            // 输入了end，退出循环（程序）
            if (strncmp(shared-&gt;text, "end", 3) == 0)
                running = 0;
        }
        else // 有其他进程在写数据，不能读取数据
            sleep(1);
    }

    // 把共享内存从当前进程中分离
    if (shmdt(shm) == -1)
    {
        fprintf(stderr, "shmdt failed\n");
        exit(EXIT_FAILURE);
    }
    sleep(2);
    exit(EXIT_SUCCESS);
}</code></pre> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/shm.h&gt;
#include "shmdata.h"

int main()
{
    int running = 1;              // 程序是否继续运行的标志
    void *shm = NULL;              // 分配的共享内存的原始首地址
    struct shared_use_st *shared; // 指向shm
    int shmid;                      // 共享内存标识符
    char buffer[BUFSIZ + 1]; 
    // 创建共享内存
    shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT);
    if (shmid == -1)
    {
        fprintf(stderr, "shmget failed\n");
        exit(EXIT_FAILURE);
    }
    // 将共享内存连接到当前进程的地址空间
    shm = shmat(shmid, 0, 0);
    if (shm == (void *)-1)
    {
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }
    printf("\nMemory attached at %X\n", (int)shm);
    // 设置共享内存
    shared = (struct shared_use_st *)shm;
    shared-&gt;written = 0;
    while (running) // 读取共享内存中的数据
    {
        // 没有进程向共享内存定数据有数据可读取
        if (shared-&gt;written != 0)
        {
            printf("You wrote: %s", shared-&gt;text);
            sleep(rand() % 3);
            // 读取完数据，设置written使共享内存段可写
            shared-&gt;written = 0;
            // 输入了end，退出循环（程序）
            if (strncmp(shared-&gt;text, "end", 3) == 0)
                running = 0;
        }
        else // 有其他进程在写数据，不能读取数据
            sleep(1);
    }

    
    running = 1;
    while (running) // 向共享内存中写数据
    {
        puts("123");
        // 数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本
        while (shared-&gt;written == 1)
        {
            sleep(1);
            printf("Waiting...\n");
        }
        // 向共享内存中写入数据
        printf("Enter some text: ");
        fgets(buffer, BUFSIZ, stdin);
        strncpy(shared-&gt;text, buffer, TEXT_SZ);
        // 写完数据，设置written使共享内存段可读
        shared-&gt;written = 1;
        // 输入了end，退出循环（程序）
        if (strncmp(buffer, "end", 3) == 0)
            running = 0;
    }

    // 把共享内存从当前进程中分离
    if (shmdt(shm) == -1)
    {
        fprintf(stderr, "shmdt failed\n");
        exit(EXIT_FAILURE);
    }
    // 删除共享内存
    if (shmctl(shmid, IPC_RMID, 0) == -1)
    {
        fprintf(stderr, "shmctl(IPC_RMID) failed\n");
        exit(EXIT_FAILURE);
    }
    exit(EXIT_SUCCESS);
}</code></pre> 
 <pre class="kdocs-makefile"><code class="language-makefile">//Makefile
.PHONY:all
all:server client
 
client:client.c 
    gcc -o $@ $^
server:server.c 
    gcc -o $@ $^
 
.PHONY:clean
clean:
    rm -f client server</code></pre> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e013e4171f108359e5dd3ced476f5ae1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java启动jar包引入外部配置文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1284d6247ebc76a43b0966527e0bb47d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">将Conda Prompt Here添加到右键菜单</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>