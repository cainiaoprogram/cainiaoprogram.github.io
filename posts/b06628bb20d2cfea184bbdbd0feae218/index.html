<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ExecuteNonQuery(),ExecuteDataSet() ,ExecuteReader() ,ExecuteScalar(),DataTable() 用法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ExecuteNonQuery(),ExecuteDataSet() ,ExecuteReader() ,ExecuteScalar(),DataTable() 用法" />
<meta property="og:description" content="一、ExecuteNonQuery方法 ：执行非查询SQL操作，包括增insert、删delete、改update；ExecuteNonQuery()方法执行SQL语句并且不返回数据。
public static int ExecuteNonQuery(string strSql, SqlParameter[] parameter){SqlConnection sqlConn = new SqlConnection(strConn);SqlCommand sqlCmd = new SqlCommand(strSql, sqlConn);if (parameter != null){sqlCmd.Parameters.AddRange(parameter);}sqlConn.Open();int objResult = sqlCmd.ExecuteNonQuery();sqlConn.Close();return objResult;} 二、ExecuteDataset会运行你的基本SELECT（选择）查询并生成一个DataSet，然后就能够被绑定到服务器对象上，或者被用来创建DataView(数据视图）。
public static DataSet ExecuteDataSet(string strSql, SqlParameter[] parameter){SqlConnection sqlConn = new SqlConnection(strConn);SqlCommand sqlCmd = new SqlCommand(strSql, sqlConn);SqlDataAdapter sqlAdp = new SqlDataAdapter(sqlCmd);DataSet ds = new DataSet();sqlAdp.Fill(ds);return ds;}&lt;span style=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b06628bb20d2cfea184bbdbd0feae218/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-10-06T15:04:29+08:00" />
<meta property="article:modified_time" content="2014-10-06T15:04:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ExecuteNonQuery(),ExecuteDataSet() ,ExecuteReader() ,ExecuteScalar(),DataTable() 用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:12px"><span style="font-size:14px">一、</span>ExecuteNonQuery方法 ：执行非查询SQL操作，包括增insert、删delete、改update；ExecuteNonQuery()方法执行SQL语句并且不返回数据。</span></p> 
<pre><code class="language-csharp"> public static int ExecuteNonQuery(string strSql, SqlParameter[] parameter)
        {
            SqlConnection sqlConn = new SqlConnection(strConn);
            SqlCommand sqlCmd = new SqlCommand(strSql, sqlConn);
            if (parameter != null)
            {
                sqlCmd.Parameters.AddRange(parameter);
            }
            sqlConn.Open();
            int objResult = sqlCmd.ExecuteNonQuery();
            sqlConn.Close();
            return objResult;
        }</code></pre> 
<p><br> </p> 
<p> 二、<span style="font-size:12px">ExecuteDataset会运行你的基本SELECT（选择）查询并生成一个Da<img class="founctionpic3" alt="close" src="https://images2.imgbox.com/d9/cc/xHKV5FYk_o.gif">taSet，然后就能够被绑定到服务器对象上，或者被用来创建DataView(数据视图）。</span></p> 
<pre><code class="language-csharp">public static DataSet ExecuteDataSet(string strSql, SqlParameter[] parameter)
        {
            SqlConnection sqlConn = new SqlConnection(strConn);
            SqlCommand sqlCmd = new SqlCommand(strSql, sqlConn);
            SqlDataAdapter sqlAdp = new SqlDataAdapter(sqlCmd);
            
            DataSet ds = new DataSet();
            sqlAdp.Fill(ds);
            return ds;
        }
&lt;span style="font-size:12px;"&gt;&lt;/span&gt;</code></pre> 
<p style="text-indent:2em"><span style="font-size:12px">三、ExecuteReader主要是用于查询语句（SELECT），它是为了提高运行性能而设置的。SqlDataReaders很类似于经典 ADO里的只能向前的只读记录集(即类似ASP中的movenext)，它们对于填充ListBoxe控件和CheckBoxList控件很有用处。对ExecuteReader的调用看起来就像是一个ExecuteDataset。要记住，它需要命名空间为System.Data.SqlClient：</span></p> 
<p style="text-indent:2em"><span style="font-size:12px">所以以后如果SQL语句中，只要是查找单条的数据中的某个字段或全部字段时，如select  top  1  *  from XX  where id=xx;用DataSet (即ExecuteDataSet  )，但是如果说满足id＝xx的结果有很多个数据，此时用ExecuteReader，因为它能够查询出“只读的向前的数据流”（如ASP中的movenext 一样,明白了吧,哈哈）,如果此时用ExecuteDataSet就错了，更何况ExecuteReader读取数据的效率会比ExecuteDataSet高。</span></p> 
<pre><code class="language-csharp"> public static SqlDataReader ExecuteReader(string strSql, CommandType commandType = CommandType.Text)
        {
            SqlConnection myConn = new SqlConnection(strSqlConnection);
            SqlCommand SqlCmd = new SqlCommand(strSql, myConn);
            SqlCmd.CommandType = commandType;
            SqlDataReader sdr = null;
            try
            {
                myConn.Open();
                sdr = SqlCmd.ExecuteReader(CommandBehavior.CloseConnection);
            }
            catch (Exception ex)
            {

            }
            return sdr;

        }</code></pre> 
<p style="text-indent:2em"><br> <span style="font-size:12px">四、对于使用ExecuteScalar()，ExecuteScalar()方法执行SQl查询，并返回查询结果集中的第一行的第一列，忽略额外的列或行！虽然返回的值的数据类型可以是string,int。。。但msdn.com微软上说：</span></p> 
<p style="text-indent:2em"><span style="font-size:12px">使用 ExecuteScalar 方法从数据库中检索单个值（例如一个聚合值）。与使用 ExecuteReader 方法，然后使用 SqlDataReader 返回的数据执行生成单个值所需的操作相比，此操作需要的代码较少。所以我习惯在count(字段)才用ExecuteScalar，如:</span></p> 
<p style="text-indent:2em"><span style="font-size:12px"> public int SelClass(decimal id) //添加类别<br>         {<!-- --><br>             string commText = string.Format("select Count(id) as [Count] from FAQ_List where ClassID like '{0}%'", id);<br>             return Convert.ToInt32(db.ExecuteScalar(CommandType.Text, commText));<br>         } </span></p> 
<p style="text-indent:2em"> </p> 
<pre><code class="language-csharp"> public static object ExecuteScalar(string strSql, CommandType commandType = CommandType.Text)
        {
            SqlConnection myConn = new SqlConnection(strSqlConnection);
            SqlCommand SqlCmd = new SqlCommand(strSql, myConn);
            SqlCmd.CommandType = commandType;
            object objResult = null;
            try 
            {
                myConn.Open();
                objResult=SqlCmd.ExecuteScalar();
            }
            catch(Exception ex)
            {

            }
            finally
            {
                myConn.Close();
            }
            return objResult;</code></pre> 
<p style="text-indent:2em"><br>  五、DataTable 与dataset十分相似；可以把DataTable和DataSet看做是数据容器，比如你查询数据库后得到一些结果，可以放到这种容器里，那你可能要问：我不用这种容器，自己读到变量或数组里也一样可以存起来啊，为什么用容器？</p> 
<p style="text-indent:2em">原因是，这种容器的功能比较强大，除了可以存数据，还可以有更大用途。举例：在一个c/s结构的桌面数据库系统里，你可以把前面存放查询结果的容器里的数据显示到你客户端界面上，用户在界面上对数据进行添加、删除、修改，你可以把用户的操作更新到容器，等用户操作完毕了，要求更新，然后你才把容器整个的数据变化更新到中心数据库，这样做的好处是什么？就是减少了数据库操作，客户端速度提高了，数据库压力减小了。<br> DataSet可以比作一个内存中的数据库，DataTable是一个内存中的数据表，DataSet里可以存储多个DataTable</p> 
<pre><code class="language-csharp">public DataTable reDt(string cmdstr)  //执行sql查询
    {
        SqlConnection con =GetCon();
        SqlDataAdapter da = new SqlDataAdapter(cmdstr, con);
        DataSet ds = new DataSet();
        da.Fill(ds);
        return (ds.Tables[0]);
    }</code></pre> 
<p style="text-indent:2em"><br> <br>  </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/63c6d8b4beb6214e2fcfd49ece3ebbdd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最简单的基于FFmpeg的推流器（以推送RTMP为例）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbe0b6534c7c4f2dec3ba4effe8e26fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《深度探索C&#43;&#43;对象模型》读书笔记——Function 语意学【for_wind】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>