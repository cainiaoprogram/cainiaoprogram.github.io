<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TMS320C6748_SPI_FLASH - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TMS320C6748_SPI_FLASH" />
<meta property="og:description" content="目录
1.主函数流程
2.初始化
2.1 PSC初始化
2.2 UART初始化
2.3 管脚复用配置
2.4 DSP中断初始化
2.5 SPI中断初始化
2.6 SPI初始化
2.6.1.SPI复位
2.6.2.设置SPI模式
2.6.3.设置SPI的时钟
2.6.4.设置SPI引脚控制寄存器
2.6.5.设置SPIDEF寄存器
2.6.6.设置SPI数据格式
2.6.7.设置SPI数据格式及片选信号
2.6.8.设置中断映射
3.读写SPI外设
3.1 SPI FLASH写使能
3.2 擦除SPI FLASH
3.3 写SPI FLASH
3.4 读SPI FLASH
3.5 比较读出的SPI FLASH的数据和写入的SPI FLASH的数据
1.主函数流程 此程序的作用是实现SPI FLASH设备的数据读写功能，此设备使用SPI1总线CS0片选。主函数流程图如下：
主函数如下：
int main(void) { PSCInit(); GPIOBankPinMuxSet(); char choice; // 初始化串口终端 使用串口2 UARTStdioInit(); UARTPuts(&#34;Tronlong SPI Flash Application......\r\n&#34;, -1); // 管脚复用配置 GPIOBankPinMuxSet(); // DSP 中断初始化 InterruptInit(); // SPI 中断初始化 SPIInterruptInit(); // SPI 初始化 SPIInit(); // 写使能 WriteEnable(); UARTPuts(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/114e5c614eb36c9895136b85ee26f6c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-28T18:34:47+08:00" />
<meta property="article:modified_time" content="2017-11-28T18:34:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TMS320C6748_SPI_FLASH</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#1.%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B" rel="nofollow" title="1.主函数流程">1.主函数流程</a></p> 
<p id="2.%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#2.%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow" title="2.初始化">2.初始化</a></p> 
<p id="2.1%20PSC%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.1%20PSC%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow" title="2.1 PSC初始化">2.1 PSC初始化</a></p> 
<p id="2.2%20UART%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.2%20UART%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow" title="2.2 UART初始化">2.2 UART初始化</a></p> 
<p id="2.3%20%E7%AE%A1%E8%84%9A%E5%A4%8D%E7%94%A8%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#2.3%20%E7%AE%A1%E8%84%9A%E5%A4%8D%E7%94%A8%E9%85%8D%E7%BD%AE" rel="nofollow" title="2.3 管脚复用配置">2.3 管脚复用配置</a></p> 
<p id="2.4%20DSP%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.4%20DSP%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow" title="2.4 DSP中断初始化">2.4 DSP中断初始化</a></p> 
<p id="2.5%20SPI%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.5%20SPI%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow" title="2.5 SPI中断初始化">2.5 SPI中断初始化</a></p> 
<p id="2.6%20SPI%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.6%20SPI%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow" title="2.6 SPI初始化">2.6 SPI初始化</a></p> 
<p id="2.6.1.-toc" style="margin-left:80px;"><a href="https://mp.csdn.net/mp_blog/creation/editor/78657961#2.6.1." title="2.6.1.SPI复位">2.6.1.SPI复位</a></p> 
<p id="2.6.2.-toc" style="margin-left:80px;"><a href="https://mp.csdn.net/mp_blog/creation/editor/78657961#2.6.2." title="2.6.2.设置SPI模式">2.6.2.设置SPI模式</a></p> 
<p id="2.6.3.-toc" style="margin-left:80px;"><a href="https://mp.csdn.net/mp_blog/creation/editor/78657961#2.6.3." title="2.6.3.设置SPI的时钟">2.6.3.设置SPI的时钟</a></p> 
<p id="2.6.4.-toc" style="margin-left:80px;"><a href="https://mp.csdn.net/mp_blog/creation/editor/78657961#2.6.4." title="2.6.4.设置SPI引脚控制寄存器">2.6.4.设置SPI引脚控制寄存器</a></p> 
<p id="2.6.5.-toc" style="margin-left:80px;"><a href="https://mp.csdn.net/mp_blog/creation/editor/78657961#2.6.5." title="2.6.5.设置SPIDEF寄存器">2.6.5.设置SPIDEF寄存器</a></p> 
<p id="2.6.6.-toc" style="margin-left:80px;"><a href="https://mp.csdn.net/mp_blog/creation/editor/78657961#2.6.6." title="2.6.6.设置SPI数据格式">2.6.6.设置SPI数据格式</a></p> 
<p id="2.6.7.-toc" style="margin-left:80px;"><a href="https://mp.csdn.net/mp_blog/creation/editor/78657961#2.6.7." title="2.6.7.设置SPI数据格式及片选信号">2.6.7.设置SPI数据格式及片选信号</a></p> 
<p id="2.6.8.-toc" style="margin-left:80px;"><a href="https://mp.csdn.net/mp_blog/creation/editor/78657961#2.6.8." title="2.6.8.设置中断映射">2.6.8.设置中断映射</a></p> 
<p id="3.%E8%AF%BB%E5%86%99SPI%E5%A4%96%E8%AE%BE-toc" style="margin-left:0px;"><a href="#3.%E8%AF%BB%E5%86%99SPI%E5%A4%96%E8%AE%BE" rel="nofollow" title="3.读写SPI外设">3.读写SPI外设</a></p> 
<p id="3.1%20SPI%20FLASH%E5%86%99%E4%BD%BF%E8%83%BD-toc" style="margin-left:40px;"><a href="#3.1%20SPI%20FLASH%E5%86%99%E4%BD%BF%E8%83%BD" rel="nofollow" title="3.1 SPI FLASH写使能">3.1 SPI FLASH写使能</a></p> 
<p id="3.2%20%E6%93%A6%E9%99%A4SPI%20FLASH-toc" style="margin-left:40px;"><a href="#3.2%20%E6%93%A6%E9%99%A4SPI%20FLASH" rel="nofollow" title="3.2 擦除SPI FLASH">3.2 擦除SPI FLASH</a></p> 
<p id="3.3%20%E5%86%99SPI%20FLASH-toc" style="margin-left:40px;"><a href="#3.3%20%E5%86%99SPI%20FLASH" rel="nofollow" title="3.3 写SPI FLASH">3.3 写SPI FLASH</a></p> 
<p id="3.4%20%E8%AF%BBSPI%20FLASH-toc" style="margin-left:40px;"><a href="#3.4%20%E8%AF%BBSPI%20FLASH" rel="nofollow" title="3.4 读SPI FLASH">3.4 读SPI FLASH</a></p> 
<p id="3.5%20%E6%AF%94%E8%BE%83%E8%AF%BB%E5%87%BA%E7%9A%84SPI%20FLASH%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E5%86%99%E5%85%A5%E7%9A%84SPI%20FLASH%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#3.5%20%E6%AF%94%E8%BE%83%E8%AF%BB%E5%87%BA%E7%9A%84SPI%20FLASH%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E5%86%99%E5%85%A5%E7%9A%84SPI%20FLASH%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow" title="3.5 比较读出的SPI FLASH的数据和写入的SPI FLASH的数据">3.5 比较读出的SPI FLASH的数据和写入的SPI FLASH的数据</a></p> 
<hr id="hr-toc"> 
<h2 id="1.%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B">1.主函数流程</h2> 
<p>此程序的作用是实现SPI FLASH设备的数据读写功能，此设备使用SPI1总线CS0片选。主函数流程图如下：</p> 
<p style="text-align:center;"><img alt="" height="652" src="https://images2.imgbox.com/38/72/lZ2CkSbS_o.png" width="226"></p> 
<p>主函数如下：</p> 
<pre class="has"><code class="language-cpp">int main(void)
{
  PSCInit();

  GPIOBankPinMuxSet();

  char choice;

  // 初始化串口终端 使用串口2
  UARTStdioInit();

  UARTPuts("Tronlong SPI Flash Application......\r\n", -1);

  // 管脚复用配置
  GPIOBankPinMuxSet();

  // DSP 中断初始化
  InterruptInit();

  // SPI 中断初始化
  SPIInterruptInit();

  // SPI 初始化
  SPIInit();

  // 写使能
  WriteEnable();
    
  UARTPuts("Do you want to erase a sector of the flash before writing to it ?.", -1);
  UARTPuts("\r\nInput y(Y)/n(N) to proceed.\r\n", -1);

  choice = UARTGetc();
  UARTPutc(choice);

  if(('y' == choice) || ('Y' == choice))
  {
    // 擦除 Flash
    SectorErase();
  }

  WriteEnable();
  // 写 Flash
  WritetoFlash();
  // 读 Flash
  ReadFromFlash();

  // 数据校验
  VerifyData();

  for(;;)
  {

  }
}</code></pre> 
<p><span style="color:#000000;">主函数中，先对各相关外设作初始化，然后再执行具体操作。</span></p> 
<h2 id="2.%E5%88%9D%E5%A7%8B%E5%8C%96">2.初始化</h2> 
<h3 id="2.1%20PSC%E5%88%9D%E5%A7%8B%E5%8C%96">2.1 PSC初始化</h3> 
<p><span style="color:#000000;">首先进行PSC初始化，在PSC1中使能SPI1模块。PSC初始化函数PSCInit()如下：</span></p> 
<pre class="has"><code class="language-cpp">void PSCInit(void)
{
  // 对相应外设模块的使能也可以在 BootLoader 中完成
  // 使能 SPI 模块
  PSCModuleControl(SOC_PSC_1_REGS, HW_PSC_SPI1, PSC_POWERDOMAIN_ALWAYS_ON, 
    PSC_MDCTL_NEXT_ENABLE);
}
</code></pre> 
<p><span style="color:#000000;">该函数中调用了PSCModuleControl函数，PSCModuleControl函数作用是将所要请求的模块（requested module）设置到所需要的状态（required state），这里是把SPI1模块设置为使能态，即使能SPI1。SPI1模块由PSC1管理，其LPSC的ID为10，如图所示：</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/ab/a3/ES1ys7fJ_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（指南P163）</span></p> 
<p><span style="color:#000000;">PSC1的寄存器（regs）基地址为0x01E2 7000，如图所示：</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/1f/98/lPC3ty1l_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（手册P97）</span></p> 
<p><span style="color:#000000;">PSCModuleControl函数具体执行细节可以参考这篇博文：</span></p> 
<p><a href="http://blog.csdn.net/zengaliang/article/details/78348051" title="C6748_UART_EDMA">C6748_UART_EDMA</a></p> 
<h3 id="2.2%20UART%E5%88%9D%E5%A7%8B%E5%8C%96">2.2 UART初始化</h3> 
<p><span style="color:#000000;">第二步，初始化串口终端，使用串口2。函数<span style="color:#642880;"><strong>UARTStdioInit</strong><span style="color:#000000;">();</span>该函数在<span style="color:#000000;">demo\StarterWare\Source\StarterWare\Utils路径下工程文件里的uartStdio.c程序中，函数具体细节可以参考这篇博文。</span></span></span></p> 
<p><a href="http://blog.csdn.net/zengaliang/article/details/78348051" title="C6748_UART_EDMA">C6748_UART_EDMA</a></p> 
<h3 id="2.3%20%E7%AE%A1%E8%84%9A%E5%A4%8D%E7%94%A8%E9%85%8D%E7%BD%AE">2.3 管脚复用配置</h3> 
<p><span style="color:#000000;">第三步，将GPIO引脚功能设为复用功能，GPIOBankPinMuxSet();函数如下：</span></p> 
<pre class="has"><code class="language-cpp">void GPIOBankPinMuxSet(void)
{
  SPIPinMuxSetup(1);
  SPI1CSPinMuxSetup(0);
}
</code></pre> 
<p><span style="color:#642880;"><strong>SPIPinMuxSetup</strong><span style="color:#000000;">函数如下：</span></span></p> 
<pre class="has"><code class="language-cpp">void SPIPinMuxSetup(unsigned int instanceNum)
{
  unsigned int savePinMux = 0;    

  if(0 == instanceNum)
  {
    savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(3)) &amp; \
                       ~(SYSCFG_PINMUX3_PINMUX3_3_0 | \
                         SYSCFG_PINMUX3_PINMUX3_15_12 | \
                         SYSCFG_PINMUX3_PINMUX3_11_8 | \
                         SYSCFG_PINMUX3_PINMUX3_7_4);

    HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(3)) = \
         (PINMUX3_SPI0_CLK_ENABLE | PINMUX3_SPI0_SIMO_ENABLE | \
          PINMUX3_SPI0_SOMI_ENABLE | PINMUX3_SPI0_ENA_ENABLE | \
          savePinMux);

  }
  else if(1 == instanceNum)
  {
    savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(5)) &amp; \
                        ~(SYSCFG_PINMUX5_PINMUX5_11_8 | \
                          SYSCFG_PINMUX5_PINMUX5_23_20 | \
                          SYSCFG_PINMUX5_PINMUX5_19_16 | \
                          SYSCFG_PINMUX5_PINMUX5_15_12);     

    HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(5)) = \
         (PINMUX5_SPI1_CLK_ENABLE | PINMUX5_SPI1_SIMO_ENABLE | \
          PINMUX5_SPI1_SOMI_ENABLE | PINMUX5_SPI1_ENA_ENABLE | \
          savePinMux);
  }
  else
  {

  }

}
</code></pre> 
<p><span style="color:#000000;">该函数根据要启用的是SPI0还是SPI1通道，分别设置不同的PINMUX寄存器。如果是SPI0，则要设置的是PINMUX3的15_0位；如果是SPI1，则要设置的是PINMUX5的23_8位。所有的PINMUX寄存器都在系统配置模块0（SYSCFG0）中，因此需要以SYSCFG0模块的地址为基地址，再加上偏移地址找到PINMUXn寄存器。</span></p> 
<p><span style="color:#000000;">这里启用的是SPI1通道，因此设置的是PINMUX5。函数先将与SPI1相关的字段，即23_8位清零，同时保存其它无关的位，然后设置23_8位为SPI1四个引脚SPI1_CLK、SPI1_SIMO、SPI1_SOMI、SPI1_ENA对应的值。</span></p> 
<p><span style="color:#642880;"><strong>SPI1CSPinMuxSetup</strong><span style="color:#000000;">函数如下：</span></span></p> 
<pre class="has"><code class="language-cpp">void SPI1CSPinMuxSetup(unsigned int csPinNum)
{
   unsigned int spi1CSPinMux = 0;
   unsigned int savePinMux = 0;

   switch(csPinNum)
   {
     case 0: 
       spi1CSPinMux = (SYSCFG_PINMUX5_PINMUX5_7_4_NSPI1_SCS0 &lt;&lt; \
                       SYSCFG_PINMUX5_PINMUX5_7_4_SHIFT);

       savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(5)) &amp; \
                          ~(SYSCFG_PINMUX5_PINMUX5_7_4);
       HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(5)) = \
             (spi1CSPinMux | savePinMux);

       break;

     case 1: 
       spi1CSPinMux = (SYSCFG_PINMUX5_PINMUX5_3_0_NSPI1_SCS1 &lt;&lt; \
                       SYSCFG_PINMUX5_PINMUX5_3_0_SHIFT);

       savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(5)) &amp; \
                          ~(SYSCFG_PINMUX5_PINMUX5_3_0);

       HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(5)) = \
             (spi1CSPinMux | savePinMux);

       break;

     case 2: 
       spi1CSPinMux = (SYSCFG_PINMUX4_PINMUX4_31_28_NSPI1_SCS2 &lt;&lt; \
                       SYSCFG_PINMUX4_PINMUX4_31_28_SHIFT);

       savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) &amp;
                          ~(SYSCFG_PINMUX4_PINMUX4_31_28);

       HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) = \
             (spi1CSPinMux | savePinMux);

       break;

     case 3: 
       spi1CSPinMux = (SYSCFG_PINMUX4_PINMUX4_27_24_NSPI1_SCS3 &lt;&lt; \
                       SYSCFG_PINMUX4_PINMUX4_27_24_SHIFT);

       savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) &amp; \
                          ~(SYSCFG_PINMUX4_PINMUX4_27_24);

       HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) = \
             (spi1CSPinMux | savePinMux);

       break;

     case 4: 
       spi1CSPinMux = (SYSCFG_PINMUX4_PINMUX4_23_20_NSPI1_SCS4 &lt;&lt; \
                       SYSCFG_PINMUX4_PINMUX4_23_20_SHIFT);

       savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) &amp; \
                          ~(SYSCFG_PINMUX4_PINMUX4_23_20);

       HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) = \
             (spi1CSPinMux | savePinMux);

       break;

     case 5: 
       spi1CSPinMux = (SYSCFG_PINMUX4_PINMUX4_19_16_NSPI1_SCS5 &lt;&lt; \
                       SYSCFG_PINMUX4_PINMUX4_19_16_SHIFT);

       savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) &amp; \
                          ~(SYSCFG_PINMUX4_PINMUX4_19_16);

       HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) = \
             (spi1CSPinMux | savePinMux);

       break;

     case 6: 
        spi1CSPinMux = (SYSCFG_PINMUX4_PINMUX4_15_12_NSPI1_SCS6 &lt;&lt; \
                        SYSCFG_PINMUX4_PINMUX4_15_12_SHIFT);

        savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) &amp; \
                           ~(SYSCFG_PINMUX4_PINMUX4_15_12);

        HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) = \
              (spi1CSPinMux | savePinMux);

        break;

      case 7: 
        spi1CSPinMux = (SYSCFG_PINMUX4_PINMUX4_11_8_NSPI1_SCS7 &lt;&lt; \
                          SYSCFG_PINMUX4_PINMUX4_11_8_SHIFT);

        savePinMux = HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) &amp; \
                           ~(SYSCFG_PINMUX4_PINMUX4_11_8);

        HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(4)) = \
                 (spi1CSPinMux | savePinMux);

        break;

      default:
        break;

   }

}
</code></pre> 
<p><span style="color:#000000;">该函数设置PINMUX寄存器相关字段为SPI1通道片选引脚SPI1_SCSn的值，SPI1通道可以外接多个SPI外设，每个SPI外设由一个片选信号SCSn控制，这里设置的SPI1_SCS0引脚。</span></p> 
<p><span style="color:#000000;">PINMUX5寄存器内容如下：</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/33/1a/NDQixQmL_o.png"></p> 
<p style="text-align:center;"> <span style="color:#000000;">（指南P228）</span></p> 
<h3 id="2.4%20DSP%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96">2.4 DSP中断初始化</h3> 
<p><span style="color:#000000;">第四步，对DSP中断初始化。InterruptInit函数如下：</span></p> 
<pre class="has"><code class="language-cpp">void InterruptInit(void)
{
  // 初始化 DSP 中断控制器
  IntDSPINTCInit();

  // 使能 DSP 全局中断
  IntGlobalEnable();
}
</code></pre> 
<p><span style="color:#000000;">DSP中断初始化函数中，先初始化DSP中断控制器，再使能DSP全局中断。DSP中断控制器初始化函数<span style="color:#642880;"><strong>IntDSPINTCInit</strong><span style="color:#000000;">在StarterWare的interrupt.c文件中，路径为\demo\StarterWare\Source\StarterWare\SystemConfig，<span style="color:#642880;"><strong>IntDSPINTCInit</strong><span style="color:#000000;">函数如下：</span></span></span></span></span></p> 
<pre class="has"><code class="language-cpp">void IntDSPINTCInit (void)
{
  unsigned int step = 0;

  /* Set ISRs to default "do-nothing" routine */
  while(step != C674X_INT_COUNT)
      c674xISRtbl[step++] = IntDefaultHandler;

  /* Set interrupt service table pointer to the vector table */
#ifdef __TI_EABI__
  ISTP = (unsigned int)_intcVectorTable;
#else
  ISTP = (unsigned int)intcVectorTable;
#endif

  /* Clear pending CPU maskable interrupts (if any) */
  ICR = 0xFFF0;

  /* Enable NMIE bit to allow CPU maskable interrupts */
  IER = (1 &lt;&lt; C674X_NMI);
}
</code></pre> 
<p><span style="color:#642880;"><strong>IntDSPINTCInit</strong><span style="color:#000000;">函数设置DSP中断控制器（INTC），在使用DSP INTC前应该要先调用该API。该API清除所有可屏蔽中断标志位（INT4-INT15），</span></span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/36/a0/pcsCtwHF_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（TMS320C674x DSP CPU and Instruction Set Reference Guide P41）</span></p> 
<p><span style="color:#000000;">然后设置IER寄存器的NMIE位，允许可屏蔽中断被使能。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/fd/22/pdLo53Ar_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（TMS320C674x DSP CPU and Instruction Set Reference Guide P42）</span></p> 
<p><span style="color:#000000;">函数将ISTP（Interrupt Service Table Pointer）指向intcVectorTable，intcVectorTable是一张向量表，记录了CPU中断服务程序的入口地址，各向量对应一个CPU中断。该向量表在intvecs.asm文件中，路径同interrupt.c文件一样，内容如下：</span></p> 
<pre class="has"><code class="language-cpp">  .global _intcVectorTable
    .global _c_int00
    .global _c674x_nmi_isr
    .global _c674x_rsvd_int2_isr
    .global _c674x_rsvd_int3_isr
    .global _c674x_mask_int4_isr
    .global _c674x_mask_int5_isr
    .global _c674x_mask_int6_isr
    .global _c674x_mask_int7_isr
    .global _c674x_mask_int8_isr
    .global _c674x_mask_int9_isr
    .global _c674x_mask_int10_isr
    .global _c674x_mask_int11_isr
    .global _c674x_mask_int12_isr
    .global _c674x_mask_int13_isr
    .global _c674x_mask_int14_isr
    .global _c674x_mask_int15_isr

;**********************************************************
;               Interrupt Fetch Packet
;**********************************************************
VEC_ENTRY .macro addr
    STW B0,*--B15
    MVKL addr,B0
    MVKH addr,B0
    B B0
    LDW *B15++,B0
    NOP 2
    NOP
    NOP
    .endm

;**********************************************************
;               Interrupt Vector Table
;**********************************************************
    .align 1024
_intcVectorTable:
    VEC_ENTRY _c_int00
    VEC_ENTRY _c674x_nmi_isr
    VEC_ENTRY _c674x_rsvd_int2_isr
    VEC_ENTRY _c674x_rsvd_int3_isr
    VEC_ENTRY _c674x_mask_int4_isr
    VEC_ENTRY _c674x_mask_int5_isr
    VEC_ENTRY _c674x_mask_int6_isr
    VEC_ENTRY _c674x_mask_int7_isr
    VEC_ENTRY _c674x_mask_int8_isr
    VEC_ENTRY _c674x_mask_int9_isr
    VEC_ENTRY _c674x_mask_int10_isr
    VEC_ENTRY _c674x_mask_int11_isr
    VEC_ENTRY _c674x_mask_int12_isr
    VEC_ENTRY _c674x_mask_int13_isr
    VEC_ENTRY _c674x_mask_int14_isr
    VEC_ENTRY _c674x_mask_int15_isr
intcVectorTable表所有向量的入口函数在interrupt.c文件中，如下：
#ifdef __TI_EABI__
interrupt void _c674x_nmi_isr (void)
#else
interrupt void c674x_nmi_isr (void)
#endif
{
    c674xISRtbl[1]();
}

#ifdef __TI_EABI__
interrupt void _c674x_rsvd_int2_isr (void)
#else
interrupt void c674x_rsvd_int2_isr (void)
#endif
{
    c674xISRtbl[2]();
}

#ifdef __TI_EABI__
interrupt void _c674x_rsvd_int3_isr (void)
#else
interrupt void c674x_rsvd_int3_isr (void)
#endif
{
    c674xISRtbl[3]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int4_isr (void)
#else
interrupt void c674x_mask_int4_isr (void)
#endif
{
    c674xISRtbl[4]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int5_isr (void)
#else
interrupt void c674x_mask_int5_isr (void)
#endif
{
    c674xISRtbl[5]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int6_isr (void)
#else
interrupt void c674x_mask_int6_isr (void)
#endif
{
    c674xISRtbl[6]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int7_isr (void)
#else
interrupt void c674x_mask_int7_isr (void)
#endif
{
    c674xISRtbl[7]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int8_isr (void)
#else
interrupt void c674x_mask_int8_isr (void)
#endif
{
    c674xISRtbl[8]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int9_isr (void)
#else
interrupt void c674x_mask_int9_isr (void)
#endif
{
    c674xISRtbl[9]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int10_isr (void)
#else
interrupt void c674x_mask_int10_isr (void)
#endif
{
    c674xISRtbl[10]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int11_isr (void)
#else
interrupt void c674x_mask_int11_isr (void)
#endif
{
    c674xISRtbl[11]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int12_isr (void)
#else
interrupt void c674x_mask_int12_isr (void)
#endif
{
    c674xISRtbl[12]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int13_isr (void)
#else
interrupt void c674x_mask_int13_isr (void)
#endif
{
    c674xISRtbl[13]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int14_isr (void)
#else
interrupt void c674x_mask_int14_isr (void)
#endif
{
    c674xISRtbl[14]();
}

#ifdef __TI_EABI__
interrupt void _c674x_mask_int15_isr (void)
#else
interrupt void c674x_mask_int15_isr (void)
#endif
{
    c674xISRtbl[15]();
}
</code></pre> 
<p><span style="color:#000000;">当发送CPU中断INTn时，函数从中断向量表intcVectorTable中找到对应的中断服务程序入口地址，然后又在该中断服务函数中调用c674xISRtbl[n]函数。</span></p> 
<p><span style="color:#000000;">初始化DSP中断控制器后，<span style="color:#642880;"><strong>IntDSPINTCInit</strong><span style="color:#000000;">函数使能DSP全局中断，<span style="color:#642880;"><strong>IntDSPINTCInit</strong><span style="color:#000000;">函数如下：</span></span></span></span></span></p> 
<pre class="has"><code class="language-cpp">void IntGlobalEnable (void)
{
  _enable_interrupts();
}
</code></pre> 
<p><span style="color:#000000;">_enable_interrupts函数为Intrinsic函数，函数使能全局中断。Intrinsic函数为C/C++语言提供了一个调用汇编语言的接口机制，通过Intrinsic函数，C/C++函数中可以调用汇编函数。</span></p> 
<h3 id="2.5%20SPI%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96">2.5 SPI中断初始化</h3> 
<p><span style="color:#000000;">第五步，对SPI进行中断初始化。SPIInterruptInit函数如下：</span></p> 
<pre class="has"><code class="language-cpp">void SPIInterruptInit(void)
{
  // 注册中断服务函数
  IntRegister(C674X_MASK_INT4, SPIIsr);

  // 映射中断事件
  IntEventMap(C674X_MASK_INT4, SYS_INT_SPI1_INT);

  // 使能可屏蔽中断
  IntEnable(C674X_MASK_INT4);
}
</code></pre> 
<p><span style="color:#000000;">先注册INT4的中断函数为SPIIsr，将c674xISRtbl[4]指向SPIIsr，然后将SPI1中断源映射到INT4，最后使能INT4。</span></p> 
<h3 id="2.6%20SPI%E5%88%9D%E5%A7%8B%E5%8C%96">2.6 SPI初始化</h3> 
<p><span style="color:#000000;">第六步，SPI初始化。函数SPIInit如下：</span></p> 
<pre class="has"><code class="language-cpp">void SPIInit(void)
{
  unsigned char cs  = 0x01;
  unsigned char dcs = 0x01;
  unsigned int  val = SIMO_SOMI_CLK_CS;

  SPIReset(SOC_SPI_1_REGS);

  SPIOutOfReset(SOC_SPI_1_REGS);

  SPIModeConfigure(SOC_SPI_1_REGS, SPI_MASTER_MODE);

  SPIClkConfigure(SOC_SPI_1_REGS, 228000000, 20000000, SPI_DATA_FORMAT0);

  SPIPinControl(SOC_SPI_1_REGS, 0, 0, &amp;val);

  SPIDefaultCSSet(SOC_SPI_1_REGS, dcs);

  // 配置 SPI 数据格式
  SPIDataFormatConfig(SPI_DATA_FORMAT0);

  // 配置 SPI 数据格式及片选信号
  SPIDat1Config(SOC_SPI_1_REGS, (SPI_CSHOLD | SPI_DATA_FORMAT0), cs);

  // 映射中断到 INT1
  SPIIntLevelSet(SOC_SPI_1_REGS, SPI_RECV_INTLVL | SPI_TRANSMIT_INTLVL);

  // 使能 SPI
  SPIEnable(SOC_SPI_1_REGS);
}
</code></pre> 
<h4 id="2.6.1."><strong>2.6.1.</strong><span style="color:#000000;">SPI复位</span></h4> 
<p><span style="color:#000000;">先将SPI复位，<span style="color:#642880;"><strong>SPIReset</strong><span style="color:#000000;">函数如下：</span></span></span></p> 
<pre class="has"><code class="language-cpp">void SPIReset(unsigned int baseAdd)
{
  HWREG(baseAdd + SPI_SPIGCR0) = ~(SPI_SPIGCR0_RESET);
}</code></pre> 
<p><span style="color:#000000;">函数设置SPIGCR0寄存器（SPI Global Control Register 0）的RESET位为1，复位SPI。然后设置使SPIGCR0的RESET位为0，使SPI out of reset状态，<span style="color:#642880;"><strong>SPIOutOfReset</strong><span style="color:#000000;">函数如下：</span></span></span></p> 
<pre class="has"><code class="language-cpp">void SPIOutOfReset(unsigned int baseAdd)
{
  HWREG(baseAdd + SPI_SPIGCR0) =  SPI_SPIGCR0_RESET; 
}
</code></pre> 
<h4 id="2.6.2.">2.6.2.<span style="color:#000000;">设置SPI模式</span></h4> 
<p><span style="color:#000000;">接着，设置SPIGCR1的CLKMOD，MASTER字段为3，将SPI设为Master模式，<span style="color:#642880;"><strong>SPIModeConfigure</strong><span style="color:#000000;">函数如下：</span></span></span></p> 
<pre class="has"><code class="language-cpp">void SPIModeConfigure(unsigned int baseAdd, unsigned int flag)
{
  HWREG(baseAdd + SPI_SPIGCR1) |= flag;
}
</code></pre> 
<h4 id="2.6.3.">2.6.3.<span style="color:#000000;">设置SPI的时钟</span></h4> 
<p><span style="color:#000000;">下一步，设置SPI的时钟，<span style="color:#642880;"><strong>SPIClkConfigure</strong><span style="color:#000000;">函数如下：</span></span></span></p> 
<pre class="has"><code class="language-cpp">void SPIClkConfigure(unsigned int baseAdd, unsigned int moduleClk,
                     unsigned int spiClk, unsigned int dataFormat)
{
  unsigned int prescale;

  prescale = (moduleClk/spiClk) - 1;

  HWREG(baseAdd + SPI_SPIFMT(dataFormat)) =  \
      (SPI_SPIFMT_PRESCALE &amp; (prescale &lt;&lt; SPI_SPIFMT_PRESCALE_SHIFT));
}
</code></pre> 
<p><span style="color:#000000;">    SPI时钟计算公式为：spiclk=moduleClk/(prescale+1)，Spi1模块时钟moduleclk为PLL1_SYSCLK2，PLL1_SYSCLK2为PLL1_SYSCLK1的一半，PLL1_SYSCLK1这里直连晶振，为456MHz，因此moduleclk为228000000Hz（228MHz）。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/24/eb/EzqOF2Vn_o.png"></p> 
<p><span style="color:#000000;">                                                                          （指南P130~P131）</span></p> 
<p><span style="color:#000000;">要设置spiclk为20000000Hz(20MHz)，则prescale=(moduleclk/spiclk)-1。每个SPI模块有四个格式寄存器（Format register），可以存储四种数据字格式（data word format）。这里只用了一种格式，用了SPIFMT0，设置SPIFMT0（</span>SPI Data Format Register 0<span style="color:#000000;">）的PRESCALE字段的值为prescale，则可得spiclk。</span></p> 
<p>                                         <img alt="" class="has" src="https://images2.imgbox.com/3d/15/E0CA54Sx_o.png"></p> 
<p><span style="color:#000000;">                                                                            （指南P1330）</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/9d/9d/XdkbZhXC_o.png"></p> 
<p><span style="color:#000000;">                                                                           （指南P1380）</span></p> 
<h4 id="2.6.4.">2.6.4.<span style="color:#000000;">设置SPI引脚控制寄存器</span></h4> 
<p><span style="color:#000000;">下一步，设置SPI引脚控制寄存器（<span style="color:#3f7f5f;">SPI Pin Control Registers<span style="color:#000000;">），每个SPI模块有6个SPIPC寄存器，为SPIPC0~SPIPC5，<span style="color:#642880;"><strong>SPIPinControl</strong><span style="color:#000000;">函数如下：</span></span></span></span></span></p> 
<pre class="has"><code class="language-cpp">void SPIPinControl(unsigned int baseAdd, unsigned int idx,
                           unsigned int flag, unsigned int *val)
{
  if (0 == flag)
  {
    HWREG(baseAdd + SPI_SPIPC(idx)) = *val;
  }
  else
  {
    *val = HWREG(baseAdd + SPI_SPIPC(idx));
  }
}
</code></pre> 
<p><span style="color:#000000;">    Idx为SPIPC的标号，为0~5，flag表示读（flag=1）SPIPC还是写（flag=0）SPIPC。这里是写SPIPC0，SPIPC0配置SPI模块的引脚功能（function）是GPIO还是SPI功能引脚，这里设置SOMIFUN、SIMOFUN、CLKFUN、SCS0FUN[0]字段为1，即对应的四个引脚为SPI功能引脚（SPI functional pin）。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/38/37/LAOyoGWv_o.png"></p> 
<p><span style="color:#000000;">                                                                            （指南P1364）</span></p> 
<h4 id="2.6.5.">2.6.5.<span style="color:#000000;">设置SPIDEF寄存器</span></h4> 
<p><span style="color:#000000;">接着，设置SPIDEF寄存器（</span>SPI default chip select register<span style="color:#000000;">），设置CS脚的缺省值，无数据传输时，CS电平为缺省值，<span style="color:#642880;"><strong>SPIDefaultCSSet</strong><span style="color:#000000;">函数如下：</span></span></span></p> 
<pre class="has"><code>void SPIDefaultCSSet(unsigned int baseAdd, unsigned char dcsval)
{
    HWREG(baseAdd + SPI_SPIDEF) = dcsval;
}
</code></pre> 
<p><span style="color:#000000;">这里设置为1，则</span>SPIx_SCS[0]<span style="color:#000000;">脚缺省值为高。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/c0/d4/0bBgkfuj_o.png"></p> 
<p><span style="color:#000000;">                                                                          （指南P1378）</span></p> 
<h4 id="2.6.6.">2.6.6.<span style="color:#000000;">设置SPI数据格式</span></h4> 
<p><span style="color:#000000;">然后，配置SPI数据格式为DATA_FORMAT0寄存器里的格式值，SPIDataFormatConfig函数如下：</span></p> 
<pre class="has"><code>void SPIDataFormatConfig(unsigned int dataFormat)
{
    // 配置 SPI 时钟
    SPIConfigClkFormat(SOC_SPI_1_REGS,
                        (SPI_CLK_POL_HIGH | SPI_CLK_INPHASE),
                         dataFormat);

    // 配置 SPI 发送时 MSB 优先
    SPIShiftMsbFirst(SOC_SPI_1_REGS, dataFormat);

    // 设置字符长度
    SPICharLengthSet(SOC_SPI_1_REGS, CHAR_LENGTH, dataFormat);
}
</code></pre> 
<p><span style="color:#642880;"><strong>SPIConfigClkFormat</strong><span style="color:#000000;">函数如下：</span></span></p> 
<pre class="has"><code>void SPIConfigClkFormat(unsigned int baseAdd, unsigned int flag,
                        unsigned int dataFormat)
{
    HWREG(baseAdd + SPI_SPIFMT(dataFormat)) |= flag;
}
</code></pre> 
<p><span style="color:#000000;">函数设置SPIFMT0的POLARITY和PHASE为1和0，空闲时spiclk线为高电平，spiclk不延迟。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/da/78/8KTLmGGh_o.png"></p> 
<p><span style="color:#000000;">                                                                       （指南P1380）</span></p> 
<p><span style="color:#642880;"><strong>SPIShiftMsbFirst</strong><span style="color:#000000;">函数如下：</span></span></p> 
<pre class="has"><code>void SPIShiftMsbFirst(unsigned int baseAdd, unsigned int dataFormat)
{
    HWREG(baseAdd + SPI_SPIFMT(dataFormat)) &amp;= ~SPI_SPIFMT_SHIFTDIR;
}
</code></pre> 
<p><span style="color:#000000;">函数设置SPIFMT0的SHIFTDIR位，这里设为0，先输出MSB位。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/dc/4d/VmFhNu5X_o.png"></p> 
<p><span style="color:#000000;">                                                                        （指南P1379）</span></p> 
<p><span style="color:#642880;"><strong>SPICharLengthSet</strong><span style="color:#000000;">函数如下：</span></span></p> 
<pre class="has"><code>void SPICharLengthSet(unsigned int baseAdd, unsigned int numOfChar,
                      unsigned int dataFormat)
{
    HWREG(baseAdd + SPI_SPIFMT(dataFormat)) &amp;= ~SPI_SPIFMT_CHARLEN;
    HWREG(baseAdd + SPI_SPIFMT(dataFormat)) |= numOfChar;
}
</code></pre> 
<p><span style="color:#000000;">函数设置SPIFMT的CHARLEN字段，设置SPI数据字的长度，这里设置的是SPIFMT0，数据字长度为8，即一个字符8位。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/4d/e6/TcMXGOLt_o.png"></p> 
<p><span style="color:#000000;">                                                                              （指南P1380）</span></p> 
<h4 id="2.6.7.">2.6.7.<span style="color:#000000;">设置SPI数据格式及片选信号</span></h4> 
<p><span style="color:#000000;">下一步，配置SPI数据格式及片选信号，<span style="color:#642880;"><strong>SPIDat1Config</strong><span style="color:#000000;">函数如下：</span></span></span></p> 
<pre class="has"><code>void SPIDat1Config(unsigned int baseAdd, unsigned int flag, unsigned char cs)
{
    unsigned char *ptr = (unsigned char*)(baseAdd + SPI_SPIDAT1);
    unsigned char dcs;

    *(ptr+3) = (char)((flag &gt;&gt; 24) | (flag &amp; (SPI_SPIDAT1_DFSEL &gt;&gt; 
                                      SPI_SPIDAT1_DFSEL_SHIFT)));

    dcs = HWREG(baseAdd + SPI_SPIDEF ) &amp; (SPI_SPIDEF_CSDEF);          

    *(ptr+2) = cs ^ dcs;
}
</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/0d/2e/qBrZbVta_o.png"><img alt="" class="has" src="https://images2.imgbox.com/c5/92/NVnRPIlv_o.png"><span style="color:#000000;">该函数先设置SPIDAT1的最高8位（ptr+3），这里设置CSHOLD位为1，则CS引脚在数据传输完成后仍然保持有效（active），直到SPIDAT1装载入新的控制信息和数据，才deactivate。DFSEL为0，选择SPIFMT0的数据字格式，即Data word format 0。CS与SPIDEF的CSDEF异或，然后将结果设置SPIDAT1的CSNR[n]位，则SPI1_SCS[0]脚在数据传输时电平为0。这里设置了之后，SPI FLASH对应的CS脚SPI1_SCS[0]脚将为有效，即CS脚被拉低。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/b8/87/Fy7v9AKW_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/c4/3b/L125H0bq_o.png"></p> 
<p><span style="color:#000000;">                                                                          （指南P1371）</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/12/3f/V9gZgdqo_o.png"></p> 
<p><span style="color:#000000;">                                                                         （指南P1378）</span></p> 
<h4 id="2.6.8.">2.6.8.<span style="color:#000000;">设置中断映射</span></h4> 
<p><span style="color:#000000;">下一步，映射中断到INT1。<span style="color:#642880;"><strong>SPIIntLevelSet</strong>函数如下：</span></span></p> 
<pre class="has"><code>void SPIIntLevelSet(unsigned int baseAdd, unsigned int flag)
{
    HWREG(baseAdd + SPI_SPILVL) |= flag;
}
</code></pre> 
<p><span style="color:#000000;">函数映射中断到INT1，这里将接收中断和发送中断映射到SPINT1。</span></p> 
<p>                                           <img alt="" class="has" src="https://images2.imgbox.com/d0/fd/JdDCdMCX_o.png"></p> 
<p><span style="color:#000000;">                                                                               （指南P1329）</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/2b/89/35xvPA1b_o.png"></p> 
<p><span style="color:#000000;">                                                                              （指南P1361）</span></p> 
<h2 id="3.%E8%AF%BB%E5%86%99SPI%E5%A4%96%E8%AE%BE">3.读写SPI外设</h2> 
<h3 id="3.1%20SPI%20FLASH%E5%86%99%E4%BD%BF%E8%83%BD">3.1 SPI FLASH写使能</h3> 
<p><span style="color:#000000;">到这一步，已经完成了所有的初始化工作，可以对SPI外设读写了。在写SPI设备之前，需要先对SPI写使能。WriteEnable函数如下：</span></p> 
<pre class="has"><code>void WriteEnable(void)
{
    tx_data[0] = SPI_FLASH_WRITE_EN;
    tx_len = rx_len = 1;
    SPIDat1Config(SOC_SPI_1_REGS, (SPI_CSHOLD | SPI_DATA_FORMAT0), 0x1);
    SpiTransfer();
}
</code></pre> 
<p><span style="color:#000000;">设置要发送的数据为SPI_FLASH_WRITE_EN（0x06），对spi flash写使能，</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/83/5e/8bJYlht3_o.png"></p> 
<p><span style="color:#000000;">                                                                            （W25Q32FV手册P31）</span></p> 
<p><span style="color:#000000;">发送的数据长度为1，接收的长度也为1。然后对数据的格式进行配置，<span style="color:#642880;"><strong>SPIDat1Config</strong><span style="color:#000000;">函数见2.6SPI初始化的第七步，这里的配置是一样的，配置SPI数据格式及片选信号，细节见上。然后开始进行SPI数据传输，SpiTransfer函数如下：</span></span></span></p> 
<pre class="has"><code>void SpiTransfer(void)
{
    p_tx = &amp;tx_data[0];
    p_rx = &amp;rx_data[0];
    SPIIntEnable(SOC_SPI_1_REGS, (SPI_RECV_INT | SPI_TRANSMIT_INT));
    while(flag);
    flag = 1;

    SPIDat1Config(SOC_SPI_1_REGS, SPI_DATA_FORMAT0, 0x1);
}
</code></pre> 
<p><span style="color:#642880;"><strong>SPIIntEnable</strong><span style="color:#000000;">函数如下：</span></span></p> 
<pre class="has"><code>void SPIIntEnable(unsigned int baseAdd, unsigned int flag)
{
    HWREG(baseAdd + SPI_SPIINT0) |= flag;
}
</code></pre> 
<p><span style="color:#000000;">该函数设置SPIINT0的TXINTENA和RXINTENA位，使能发送中断和接收中断。由于此时SPIDAT0和SPIDAT1的TXDATA部分都没有写入过数据，因此TXBUF都为空，因此SPIFLG的TXINTFLG中断标志位被置为1，一旦使能了SPI发送中断和接收中断，就会产生SPI1中断，就会转入SPIisr中断服务子程序。</span>                  </p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/ae/84/AvizORyG_o.png"></p> 
<p style="text-align:center;"> <span style="color:#000000;">（SPIIFG 指南P1362）</span>                           </p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/a3/06/7Pftj0v1_o.png"></p> 
<p style="text-align:center;"> <span style="color:#000000;">（SPIINT0 指南P1359）</span></p> 
<p><span style="color:#000000;">SPIisr程序如下：</span></p> 
<pre class="has"><code>void SPIIsr(void)
{
  unsigned int intCode = 0;
  IntEventClear(SYS_INT_SPI1_INT);
  intCode = SPIInterruptVectorGet(SOC_SPI_1_REGS);

  while (intCode)
  {
    if(intCode == SPI_TX_BUF_EMPTY)
    {
        tx_len--;
        SPITransmitData1(SOC_SPI_1_REGS, *p_tx);
        p_tx++;
        if (!tx_len)
        {
          SPIIntDisable(SOC_SPI_1_REGS, SPI_TRANSMIT_INT);
        }
    }

    if(intCode == SPI_RECV_FULL)
    {
      rx_len--;
      *p_rx = (char)SPIDataReceive(SOC_SPI_1_REGS);
      p_rx++;
      if (!rx_len)
      {
        flag = 0;
        SPIIntDisable(SOC_SPI_1_REGS, SPI_RECV_INT);
      }
    }

    intCode = SPIInterruptVectorGet(SOC_SPI_1_REGS);
  }
}
</code></pre> 
<p><span style="color:#000000;">该函数中，先是清除CPU中断标志，IntEventClear函数细节见这篇博文。C6748_EDMA_GPIO中断学习笔记</span></p> 
<p><span style="color:#000000;">然后读取INTVEC1，确定什么事件引起的SPI中断，这里是发送缓冲区空引起的SPI中断，因此SPI中断向量码为0x14。<strong>SPIInterruptVectorGet</strong>函数如下：</span></p> 
<pre class="has"><code>unsigned int SPIInterruptVectorGet(unsigned int baseAdd)
{
  unsigned int intVectorCode; 
  intVectorCode = HWREG(baseAdd + SPI_INTVEC1);

  return (intVectorCode &gt;&gt; 1);
}
</code></pre> 
<p style="margin-left:2pt;"><span style="color:#000000;">然后判断中断码intcode是否为空，不为空则判断是发送中断还是接收中断。如果是发送中断，则发送p_tx指向的数组，发送的数据个数为tx_len，当发送完毕后，禁止发送中断。发送函数<span style="color:#642880;"><strong>SPITransmitData1</strong><span style="color:#000000;">如下：</span></span></span></p> 
<pre class="has"><code>void SPITransmitData1(unsigned int baseAdd, unsigned int data)
{
  HWREG(baseAdd + SPI_SPIDAT1) = \
      (HWREG(baseAdd + SPI_SPIDAT1) &amp; ~ SPI_SPIDAT1_TXDATA) | data;
}
</code></pre> 
<p style="margin-left:22pt;"><span style="color:#000000;">往SPIDAT1的TXDATA部分写数据，就可以启动SPI数据传输。</span>   </p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/fe/a2/VLxujgSC_o.png"></p> 
<p style="text-align:center;"> <span style="color:#000000;">（指南P1335）</span></p> 
<p><span style="color:#000000;">禁止发送中断函数<span style="color:#642880;"><strong>SPIIntDisable</strong><span style="color:#000000;">如下：</span></span></span></p> 
<pre class="has"><code>void SPIIntDisable(unsigned int baseAdd, unsigned int flag)
{
  HWREG(baseAdd + SPI_SPIINT0) &amp;= ~(flag);
}
</code></pre> 
<p style="margin-left:22pt;"><span style="color:#000000;">函数清除SPIINT0的TXINTENA位，禁止发送中断。</span></p> 
<p style="margin-left:22pt;text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/44/81/16ZuWM2q_o.png"></p> 
<p style="margin-left:22pt;text-align:center;"><span style="color:#000000;">（指南P1359）</span></p> 
<p style="margin-left:22pt;"><span style="color:#000000;">如果是接收中断，则读取SPIBUF的RXDATA位（SPIBUF[15:0]），读取接收</span></p> 
<p><span style="color:#000000;">到的数据。读取函数<span style="color:#642880;"><strong>SPIDataReceive</strong><span style="color:#000000;">如下：</span></span></span></p> 
<pre class="has"><code>unsigned int SPIDataReceive(unsigned int baseAdd)
{
  return (HWREG(baseAdd + SPI_SPIBUF) &amp;  SPI_SPIBUF_RXDATA);
}
</code></pre> 
<p><span style="color:#000000;">读取rx_len个数据后，flag清零，表示已读取完SPI从设备发回来的数据，然后清除SPIINT0的RXINTENA位，禁用接收中断。</span></p> 
<p style="margin-left:22pt;text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/f5/30/24aPxYfO_o.png"></p> 
<p style="margin-left:22pt;"><span style="color:#000000;">                                                                  （指南P1359）</span></p> 
<p><span style="color:#000000;">处理完发送或接收中断后，再读取中断码intcode，如果为0，说明没有中断发生了，就退出中断服务子程序。回到<strong>SpiTransfer</strong>函数，重新将flag设为1，设置SPIDAT1的数据格式为Data Format 0。写使能就执行完了。</span></p> 
<p><span style="color:#000000;">主函数继续执行，<span style="color:#642880;"><strong>UARTPuts</strong><span style="color:#000000;">执行细节参考这篇博文。</span></span></span></p> 
<p><a href="http://blog.csdn.net/zengaliang/article/details/78369953" title="C6748_I2C">C6748_I2C</a></p> 
<p><span style="color:#642880;"><strong>UARTGetc</strong><span style="color:#000000;">函数在uartStdio.c文件中，uartStdio.c文件在Utils文件夹下，该文件夹路径为\TL_TMS6748\demo\StarterWare\Source\StarterWare\Utils，函数如下：</span></span></p> 
<pre class="has"><code>unsigned char UARTGetc(void)
{
  return (UARTConsoleGetc());
}
</code></pre> 
<p><span style="color:#000000;">UARTConsoleGetc函数在UARTConsole.c文件中，UARTConsole.c文件在Platform文件夹下，该文件夹路径为</span></p> 
<p><span style="color:#000000;">TL_TMS6748\demo\StarterWare\Application\Platform，函数如下：</span></p> 
<pre class="has"><code>unsigned char UARTConsoleGetc(void)
{
  return ((unsigned char)UARTCharGet(UART_CONSOLE_BASE));
}
</code></pre> 
<p><span style="color:#642880;"><strong>UARTCharGet</strong><span style="color:#000000;">函数在uart.c文件中，uart.c在Drivers文件夹下，Drivers文件夹路径为TL_TMS6748\demo\StarterWare\Source\StarterWare\Drivers，函数如下：</span></span></p> 
<pre class="has"><code>int UARTCharGet(unsigned int baseAdd)
{
    int data = 0;
    
    /*
    ** Busy check if data is available in receiver FIFO(RBR regsiter in non-FIFO
    ** mode) so that data could be read from the RBR register.
    */
    while ((HWREG(baseAdd + UART_LSR) &amp; UART_DATA_READY) == 0);
    
    data = (int)HWREG(baseAdd + UART_RBR);

    return data;
}
</code></pre> 
<p><span style="color:#000000;">函数读取UART的LSR寄存器的DR位，判断是否接收到数据，如果有则读取RBR，否则继续等待。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/fb/33/LC89erdh_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（UART LSR寄存器指南P1442）</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/7d/ea/hejpYGTt_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（UART RBR寄存器指南P1431）</span></p> 
<h3 id="3.2%20%E6%93%A6%E9%99%A4SPI%20FLASH">3.2 擦除SPI FLASH</h3> 
<p><span style="color:#000000;">SPIflash写使能后，要写spi flash，还要先擦除flash。SectorErase函数如下：</span></p> 
<pre class="has"><code>void SectorErase(void)
{
    tx_data[0] =  SPI_FLASH_SECTOR_ERASE;
    tx_data[1] =  SPI_FLASH_ADDR_MSB1;
    tx_data[2] =  SPI_FLASH_ADDR_MSB0;
    tx_data[3] =  SPI_FLASH_ADDR_LSB;

    tx_len = rx_len = 4;
    SPIDat1Config(SOC_SPI_1_REGS, (SPI_CSHOLD | SPI_DATA_FORMAT0), 0x1);
    SpiTransfer();

    IsFlashBusy();
}
</code></pre> 
<p><span style="color:#000000;">SPI_FLASH_SECTOR_ERASE（0xD8），SPI_FLASH_ADDR_MSB1（0x0A），</span></p> 
<p><span style="color:#000000;">SPI_FLASH_ADDR_MSB0（0x00），SPI_FLASH_ADDR_LSB（0x00）。后面三个字节组成一个24位地址，0x0A0000，该地址是要擦除的64KB块的地址。因为前面2.6spi初始化的第6步<span style="color:#642880;"><strong>SPICharLengthSet</strong><span style="color:#000000;">函数设置了SPIFMT0的数据字长度为8，所以每往TXDATA写一个16位数据，都是只发送低8位。</span></span></span></p> 
<p>        <img alt="" class="has" src="https://images2.imgbox.com/b4/dd/jsLzhlsu_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（指南P）</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/39/c8/ZeCfluWA_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/99/3d/5YyuIegc_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（W25Q32FV手册P56）</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/36/53/sXI4oGIv_o.png"></p> 
<p style="text-align:center;"> <span style="color:#000000;">（W25Q32FV手册P28）</span></p> 
<p><span style="color:#000000;">启动SPI传输，将擦除指令和擦除地址发送给SPI flash设备，然后等待flash擦除完成，IsFlashBusy函数如下：</span></p> 
<pre class="has"><code>void IsFlashBusy(void)
{
    do{
         StatusGet();

      }while(rx_data[1] &amp; WRITE_IN_PROGRESS);
}
</code></pre> 
<p><span style="color:#000000;">StatusGet函数如下：</span></p> 
<pre class="has"><code>void StatusGet(void)
{
    tx_data[0] = SPI_FLASH_STATUS_RX;
    tx_len = rx_len = 2;
    SPIDat1Config(SOC_SPI_1_REGS, (SPI_CSHOLD | SPI_DATA_FORMAT0), 0x1);
    SpiTransfer();
}
</code></pre> 
<p><span style="color:#000000;">SPI_FLASH_STATUS_RX（0x05），WRITE_IN_PROGRESS（0x01），读取状态寄存器1，时序如下：</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/21/e7/2WiR30F2_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（W25Q32FV手册P32）</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/2b/13/qhZVKdyE_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（状态寄存器 W25Q32FV手册P18）</span></p> 
<p><span style="color:#000000;">一直读取BUSY位，直到BUSY位不为1，则转换已完成。</span></p> 
<h3 id="3.3%20%E5%86%99SPI%20FLASH">3.3 写SPI FLASH</h3> 
<p><span style="color:#000000;">擦除完spi flash，就可以写spi flash了，写之前再使能一下spi flash写使能，调用WriteEnable。然后写flash，WritetoFlash函数如下：</span></p> 
<pre class="has"><code>void WritetoFlash(void)
{
    unsigned int index;

    tx_data[0] =  SPI_FLASH_PAGE_WRITE;
    tx_data[1] =  SPI_FLASH_ADDR_MSB1;
    tx_data[2] =  SPI_FLASH_ADDR_MSB0;
    tx_data[3] =  SPI_FLASH_ADDR_LSB;

    // 准备要写入的数据
    for (index = 4; index &lt; 260; index++)
    {
        tx_data[index] =  index;
    }

    for(index = 4; index &lt; 260; index++)
    {
         vrf_data[index] = index;
    }

    tx_len = rx_len = index;
    SPIDat1Config(SOC_SPI_1_REGS, (SPI_CSHOLD | SPI_DATA_FORMAT0), 0x1);
    SpiTransfer();

    IsFlashBusy();
}
</code></pre> 
<p><span style="color:#000000;">SPI_FLASH_PAGE_WRITE（0x02），SPI_FLASH_ADDR_MSB1（0x0A），SPI_FLASH_ADDR_MSB0（0x00），SPI_FLASH_ADDR_LSB（0x00）。页编程允许1到256字节数据写到之前擦除过的存储位置。写spi flash页，时序是，先发送写指令02h，然后发送24位的页地址，然后发送256字节要写的数据。这里24位页地址和前面擦除过的地址是一样的，都是0x0A0000。时序图如下：</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/27/ac/WIHUllY7_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（W25Q32FV手册P51）</span></p> 
<h3 id="3.4%20%E8%AF%BBSPI%20FLASH">3.4 读SPI FLASH</h3> 
<p><span style="color:#000000;">写完spi flash后，读spi flash，读取刚刚写入的那一页，对比写入的数据和读出的数据是否一样。读spi flash函数ReadFromFlash如下：</span></p> 
<pre class="has"><code>void ReadFromFlash(void)
{
    unsigned int index;

    tx_data[0] =  SPI_FLASH_READ;
    tx_data[1] =  SPI_FLASH_ADDR_MSB1;
    tx_data[2] =  SPI_FLASH_ADDR_MSB0;
    tx_data[3] =  SPI_FLASH_ADDR_LSB;

    // 情况变量
    for (index = 4; index &lt; 260; index++)
    {
        tx_data[index] =  0;
    }

    tx_len = rx_len = index;
    SPIDat1Config(SOC_SPI_1_REGS, (SPI_CSHOLD | SPI_DATA_FORMAT0), 0x1);
    SpiTransfer();
}
</code></pre> 
<p><span style="color:#000000;">SPI_FLASH_READ（0x03），SPI_FLASH_ADDR_MSB1（0x0A），SPI_FLASH_ADDR_MSB0（0x00），SPI_FLASH_ADDR_LSB（0x00）。读数据的时序是，先发送读指令03h，然后发送24位的页地址，然后DO线就会输出该页的数据，此时就可以读取页的数据了。时序图如下：</span></p> 
<p>                                       </p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/2b/14/PBOuGio9_o.png"></p> 
<p style="text-align:center;"> <span style="color:#000000;">（W25Q32FV手册P36）</span></p> 
<p><span style="color:#000000;">发送了读指令03h，24位地址后，SPI模块的RXBUF将会收到数据，此时会同时发生Receive buffer full interrupt和Transmit buffer empty interrupt，但是因为Receive buffer full interrupt的优先级比Transmit buffer empty interrupt要高，所以INTVECT1里的中断码是Receive buffer full interrupt的中断码，在SPIIsr程序中，程序会读取index个数据到rx_data数组中，然后再将没写完的index-4个数据写到spi总线。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/86/e6/DREMTmCE_o.png"></p> 
<p style="text-align:center;"><span style="color:#000000;">（指南P1381）</span></p> 
<h3 id="3.5%20%E6%AF%94%E8%BE%83%E8%AF%BB%E5%87%BA%E7%9A%84SPI%20FLASH%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E5%86%99%E5%85%A5%E7%9A%84SPI%20FLASH%E7%9A%84%E6%95%B0%E6%8D%AE">3.5 比较读出的SPI FLASH的数据和写入的SPI FLASH的数据</h3> 
<p><span style="color:#000000;">函数VerifyData如下：</span></p> 
<pre class="has"><code>int VerifyData(void)
{
    unsigned int index;

    for(index = 4; index &lt; 260; index++)
    {
        if(vrf_data[index] != rx_data[index])
        {
            UARTPuts("\r\n", -1);
            UARTPuts("VerifyData: Comparing the data written to and read", -1);
            UARTPuts(" from Flash.\r\nThe two data blocks are unequal.", -1);
            UARTPuts(" Mismatch found at index ", -1);
            UARTPutNum((int)index - 3);
            UARTPuts("\r\n", -1);
            UARTPuts("Verify Failed.\r\n", -1);
            return 0;
        }
    }

    if (index == 260)
    {
        UARTPuts("\r\nThe data in the Flash and the one written ", -1);
        UARTPuts("to it are equal.\r\n", -1);
        UARTPuts("Verify successfully.\r\n", -1);
        return 1;
    }

    return 0;
}
</code></pre> 
<p><span style="color:#000000;">函数逐个比较读出的数据和写入的数据，如果有一个不一样，则校验失败，否则成功。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05df516bb9f6ac8db3ef7c84f1a04901/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">groovy闭包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5076af66ad9ef477ef074fc59945f392/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js获取当前时间，并格式化为&#34;yyyy-MM-dd HH:mm:ss&#34;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>