<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文告诉你Spring是如何利用“三级缓存“巧妙解决Bean的循环依赖问题的【享学Spring】 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文告诉你Spring是如何利用“三级缓存“巧妙解决Bean的循环依赖问题的【享学Spring】" />
<meta property="og:description" content="每篇一句 你今天的优势会被明天的趋势所取代，所以务必好好学理论，一通则百通
前言 循环依赖：就是N个类循环(嵌套)引用。
通俗的讲就是N个Bean互相引用对方，最终形成闭环。用一副经典的图示可以表示成这样（A、B、C都代表对象，虚线代表引用关系）：
注意：其实可以N=1，也就是极限情况的循环依赖：自己依赖自己
另需注意：这里指的循环引用不是方法之间的循环调用，而是对象的相互依赖关系。（方法之间循环调用若有出口也是能够正常work的）
可以设想一下这个场景：如果在日常开发中我们用new对象的方式，若构造函数之间发生这种循环依赖的话，程序会在运行时一直循环调用最终导致内存溢出，示例代码如下：
public class Main { public static void main(String[] args) throws Exception { System.out.println(new A()); } } class A { public A() { new B(); } } class B { public B() { new A(); } } 运行报错：
Exception in thread &#34;main&#34; java.lang.StackOverflowError 这是一个典型的循环依赖问题。本文说一下Spring是如果巧妙的解决平时我们会遇到的三大循环依赖问题的~
Spring Bean的循环依赖 谈到Spring Bean的循环依赖，有的小伙伴可能比较陌生，毕竟开发过程中好像对循环依赖这个概念无感知。其实不然，你有这种错觉，权是因为你工作在Spring的襁褓中，从而让你“高枕无忧”~
我十分坚信，小伙伴们在平时业务开发中一定一定写过如下结构的代码：
@Service public class AServiceImpl implements AService { @Autowired private BService bService; ... } @Service public class BServiceImpl implements BService { @Autowired private AService aService; ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/59ae3fa712efbaf2489af90f1c94a117/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-19T22:39:19+08:00" />
<meta property="article:modified_time" content="2019-06-19T22:39:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文告诉你Spring是如何利用“三级缓存“巧妙解决Bean的循环依赖问题的【享学Spring】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5><a id="_0"></a>每篇一句</h5> 
<blockquote> 
 <p>你今天的优势会被明天的趋势所取代，所以务必好好学理论，一通则百通</p> 
</blockquote> 
<h5><a id="_2"></a>前言</h5> 
<p><strong>循环依赖：就是N个类循环(嵌套)引用</strong>。<br> 通俗的讲就是N个Bean互相引用对方，最终形成<code>闭环</code>。用一副经典的图示可以表示成这样（A、B、C都代表对象，虚线代表引用关系）：<br> <img src="https://images2.imgbox.com/89/5f/p5vl8L44_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注意：其实可以N=1，也就是极限情况的循环依赖：<code>自己依赖自己</code></p> 
</blockquote> 
<blockquote> 
 <p>另需注意：这里指的循环引用不是方法之间的循环调用，<strong>而是对象的相互依赖关系</strong>。（方法之间循环调用若有出口也是能够正常work的）</p> 
</blockquote> 
<p>可以设想一下这个场景：如果在日常开发中我们用new对象的方式，若构造函数之间发生这种<strong>循环依赖</strong>的话，程序会在运行时一直循环调用<strong>最终导致内存溢出</strong>，示例代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行报错：</p> 
<pre><code class="prism language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>StackOverflowError
</code></pre> 
<p>这是一个典型的循环依赖问题。本文说一下<code>Spring</code>是如果巧妙的解决平时我们会遇到的<code>三大循环依赖问题</code>的~</p> 
<h3><a id="Spring_Bean_37"></a>Spring Bean的循环依赖</h3> 
<p>谈到<code>Spring Bean</code>的循环依赖，有的小伙伴可能比较陌生，毕竟开发过程中好像对<code>循环依赖</code>这个概念<strong>无感知</strong>。其实不然，你有这种错觉，权是因为你工作在Spring的<code>襁褓</code>中，从而让你“高枕无忧”~<br> <strong>我十分坚信，小伙伴们在平时业务开发中一定一定写过如下结构的代码：</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">AService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> BService bService<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> AService aService<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这其实就是Spring环境下典型的循环依赖场景。但是很显然，这种循环依赖场景，Spring已经完美的帮我们解决和规避了问题。所以即使平时我们这样循环引用，也能够整成进行我们的coding之旅~</p> 
<h4><a id="Spring_55"></a>Spring中<code>三大循环依赖场景</code>演示</h4> 
<p>在Spring环境中，因为我们的Bean的实例化、初始化都是交给了容器，因此它的循环依赖主要表现为下面三种场景。为了方便演示，我准备了如下两个类：<br> <img src="https://images2.imgbox.com/e0/7c/ERVxJyyW_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="1_58"></a>1、构造器注入循环依赖</h6> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token function">A</span><span class="token punctuation">(</span>B b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token function">B</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果：项目启动失败抛出异常<code>BeanCurrentlyInCreationException</code></p> 
<pre><code class="prism language-java">Caused by<span class="token operator">:</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>BeanCurrentlyInCreationException<span class="token operator">:</span> Error creating bean with name <span class="token string">'a'</span><span class="token operator">:</span> Requested bean is currently in creation<span class="token operator">:</span> Is there an unresolvable circular reference<span class="token operator">?</span>
	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support<span class="token punctuation">.</span>DefaultSingletonBeanRegistry<span class="token punctuation">.</span><span class="token function">beforeSingletonCreation</span><span class="token punctuation">(</span>DefaultSingletonBeanRegistry<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">339</span><span class="token punctuation">)</span>
	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support<span class="token punctuation">.</span>DefaultSingletonBeanRegistry<span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span>DefaultSingletonBeanRegistry<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">215</span><span class="token punctuation">)</span>
	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support<span class="token punctuation">.</span>AbstractBeanFactory<span class="token punctuation">.</span><span class="token function">doGetBean</span><span class="token punctuation">(</span>AbstractBeanFactory<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">318</span><span class="token punctuation">)</span>
	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support<span class="token punctuation">.</span>AbstractBeanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>AbstractBeanFactory<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">199</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>构造器注入构成的循环依赖，此种循环依赖方式<strong>是无法解决的</strong>，只能抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖。这也是构造器注入的最大劣势（它有很多独特的优势，请小伙伴自行发掘）</p> 
</blockquote> 
<blockquote> 
 <p><code>根本原因</code>：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是<code>已经实例化</code>，但还没初始化的状态。而构造器是完成实例化的东东，所以构造器的循环依赖无法解决~~~</p> 
</blockquote> 
<h6><a id="2fieldsetter_82"></a>2、field属性注入（setter方法注入）循环依赖</h6> 
<p>这种方式是我们<strong>最最最最</strong>为常用的依赖注入方式（所以猜都能猜到它肯定不会有问题啦）：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> B b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> A a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>结果：项目启动成功，能够正常work</strong></p> 
<blockquote> 
 <p>备注：setter方法注入方式因为原理和字段注入方式类似，此处不多加演示</p> 
</blockquote> 
<h6><a id="2prototype_field_99"></a>2、<code>prototype</code> field属性注入循环依赖</h6> 
<p><code>prototype</code>在平时使用情况较少，但是也并不是不会使用到，因此此种方式也需要引起重视。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>ConfigurableBeanFactory<span class="token punctuation">.</span>SCOPE_PROTOTYPE<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> B b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>ConfigurableBeanFactory<span class="token punctuation">.</span>SCOPE_PROTOTYPE<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> A a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果：<strong>需要注意的是</strong>本例中<strong>启动时是不会报错的</strong>（因为非单例Bean<code>默认</code>不会初始化，而是使用时才会初始化），所以很简单咱们只需要手动<code>getBean()</code>或者在一个单例Bean内<code>@Autowired</code>一下它即可</p> 
<pre><code class="prism language-java"><span class="token comment">// 在单例Bean内注入</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> A a<span class="token punctuation">;</span>
</code></pre> 
<p>这样子启动就报错：</p> 
<pre><code class="prism language-java">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>UnsatisfiedDependencyException<span class="token operator">:</span> Error creating bean with name <span class="token string">'mytest.TestSpringBean'</span><span class="token operator">:</span> Unsatisfied dependency expressed through field <span class="token string">'a'</span><span class="token punctuation">;</span> nested exception is org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>UnsatisfiedDependencyException<span class="token operator">:</span> Error creating bean with name <span class="token string">'a'</span><span class="token operator">:</span> Unsatisfied dependency expressed through field <span class="token string">'b'</span><span class="token punctuation">;</span> nested exception is org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>UnsatisfiedDependencyException<span class="token operator">:</span> Error creating bean with name <span class="token string">'b'</span><span class="token operator">:</span> Unsatisfied dependency expressed through field <span class="token string">'a'</span><span class="token punctuation">;</span> nested exception is org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>BeanCurrentlyInCreationException<span class="token operator">:</span> Error creating bean with name <span class="token string">'a'</span><span class="token operator">:</span> Requested bean is currently in creation<span class="token operator">:</span> Is there an unresolvable circular reference<span class="token operator">?</span>

	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement<span class="token punctuation">.</span><span class="token function">inject</span><span class="token punctuation">(</span>AutowiredAnnotationBeanPostProcessor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">596</span><span class="token punctuation">)</span>
	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>InjectionMetadata<span class="token punctuation">.</span><span class="token function">inject</span><span class="token punctuation">(</span>InjectionMetadata<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">90</span><span class="token punctuation">)</span>
	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AutowiredAnnotationBeanPostProcessor<span class="token punctuation">.</span><span class="token function">postProcessProperties</span><span class="token punctuation">(</span>AutowiredAnnotationBeanPostProcessor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">374</span><span class="token punctuation">)</span>
</code></pre> 
<p>如何解决？？？<br> 可能有的小伙伴看到网上有说使用<code>@Lazy</code>注解解决：</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Lazy</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> A a<span class="token punctuation">;</span>
</code></pre> 
<p>此处负责任的告诉你这样是解决不了问题的(<strong>可能会掩盖问题</strong>)，<code>@Lazy</code>只是延迟初始化而已，当你真正使用到它（初始化）的时候，依旧会报如上异常。</p> 
<p>对于Spring循环依赖的情况总结如下：</p> 
<ol><li>不能解决的情况：<br> 1. 构造器注入循环依赖<br> 2. <code>prototype</code> field属性注入循环依赖</li><li>能解决的情况：<br> 1. field属性注入（setter方法注入）循环依赖</li></ol> 
<h3><a id="Spring_148"></a>Spring解决循环依赖的原理分析</h3> 
<p>在这之前需要明白java中所谓的<code>引用传递</code>和<code>值传递</code>的区别。</p> 
<blockquote> 
 <p>说明：看到这句话可能有小伙伴就想喷我了。java中明明都是传递啊，这是我初学java时背了100遍的面试题，怎么可能有错？？？<br> 这就是我做这个申明的必要性：伙计，你的说法是正确的，<code>java中只有值传递</code>。但是本文借用<code>引用传递</code>来辅助讲解，希望小伙伴明白我想表达的意思~</p> 
</blockquote> 
<p><mark><strong><code>Spring的循环依赖的理论依据基于Java的引用传递</code></strong></mark>，当获得对象的引用时，<strong>对象的属性是可以延后设置的</strong>。（但是构造器必须是在获取引用之前，毕竟你的引用是靠构造器给你生成的，儿子能先于爹出生？哈哈）</p> 
<h5><a id="SpringBean_154"></a>Spring创建Bean的流程</h5> 
<p>首先需要了解是Spring它创建Bean的流程，我把它的大致调用栈绘图如下：<br> <img src="https://images2.imgbox.com/99/2b/0uZfLGML_o.png" alt="在这里插入图片描述"><br> 对Bean的创建最为核心三个方法解释如下：</p> 
<ul><li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li><li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li><li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li></ul> 
<p>从对<code>单例Bean</code>的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p> 
<h5><a id="Spring_164"></a>Spring容器的<code>'三级缓存'</code></h5> 
<p>在Spring容器的整个声明周期中，单例Bean有且仅有一个对象。这很容易让人想到可以用缓存来加速访问。<br> 从源码中也可以看出Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至不惜使用了“三级缓存”，这也便是它设计的精妙之处~</p> 
<p><code>三级缓存</code>其实它更像是Spring容器工厂的内的<code>术语</code>，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSingletonBeanRegistry</span> <span class="token keyword">extends</span> <span class="token class-name">SimpleAliasRegistry</span> <span class="token keyword">implements</span> <span class="token class-name">SingletonBeanRegistry</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 从上至下 分表代表这“三级缓存”</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//一级缓存</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 二级缓存</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;&gt;</span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 三级缓存</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
	<span class="token comment">/** Names of beans that are currently in creation. */</span>
	<span class="token comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span>
	<span class="token comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Set<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> singletonsCurrentlyInCreation <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">newSetFromMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/** Names of beans that have already been created at least once. */</span>
	<span class="token comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span>
	<span class="token comment">// 至少被创建了一次的  都会放进这里~~~~</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Set<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> alreadyCreated <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">newSetFromMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注：<code>AbstractBeanFactory</code>继承自<code>DefaultSingletonBeanRegistry</code>~</p> 
<ol><li><code>singletonObjects</code>：用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li><li><code>earlySingletonObjects</code>：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li><li><code>singletonFactories</code>：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li></ol> 
<p><strong>获取单例Bean的源码如下：</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSingletonBeanRegistry</span> <span class="token keyword">extends</span> <span class="token class-name">SimpleAliasRegistry</span> <span class="token keyword">implements</span> <span class="token class-name">SingletonBeanRegistry</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token annotation punctuation">@Nullable</span>
	<span class="token keyword">public</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token annotation punctuation">@Nullable</span>
	<span class="token keyword">protected</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> singletonFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>singletonFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonsCurrentlyInCreation<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isActuallyInCreation</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol><li>先从<code>一级缓存singletonObjects</code>中去获取。（如果获取到就直接return）</li><li>如果获取不到或者对象正在创建中（<code>isSingletonCurrentlyInCreation()</code>），那就再从<code>二级缓存earlySingletonObjects</code>中获取。（如果获取到就直接return）</li><li>如果还是获取不到，且允许singletonFactories（allowEarlyReference=true）通过<code>getObject()</code>获取。就从<code>三级缓存singletonFactory</code>.getObject()获取。<strong>（如果获取到了就从<code>singletonFactories</code>中移除，并且放进<code>earlySingletonObjects</code>。其实也就是从三级缓存<code>移动（是剪切、不是复制哦~）</code>到了二级缓存）</strong></li></ol> 
<blockquote> 
 <p><strong>加入<code>singletonFactories</code>三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</strong></p> 
</blockquote> 
<p><code>getSingleton()</code>从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：<strong>就在于singletonFactories这个三级缓存</strong>。这个Cache里面都是<code>ObjectFactory</code>，它是解决问题的关键。</p> 
<pre><code class="prism language-java"><span class="token comment">// 它可以将创建对象的步骤封装到ObjectFactory中 交给自定义的Scope来选择是否需要创建对象来灵活的实现scope。  具体参见Scope接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ObjectFactory</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
	T <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>经过ObjectFactory.getObject()后，此时放进了二级缓存<code>earlySingletonObjects</code>内。这个时候对象已经实例化了，<code>虽然还不完美</code>，但是对象的引用已经可以被其它引用了。</p> 
</blockquote> 
<p><strong>此处说一下二级缓存<code>earlySingletonObjects</code>它里面的数据什么时候添加什么移除？？?</strong></p> 
<p><strong>添加</strong>：向里面添加数据只有一个地方，就是上面说的<code>getSingleton()</code>里从三级缓存里挪过来<br> <strong>移除</strong>：<code>addSingleton、addSingletonFactory、removeSingleton</code>从语义中可以看出添加单例、添加单例工厂<code>ObjectFactory</code>的时候都会删除二级缓存里面对应的缓存值，是互斥的</p> 
<h5><a id="_254"></a>源码解析</h5> 
<p><code>Spring</code>容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，而对于创建完毕的Bean将从<code>当前创建Bean池</code>中清除掉。<br> 这个“当前创建Bean池”指的是上面提到的<code>singletonsCurrentlyInCreation</code>那个集合。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractBeanFactory</span> <span class="token keyword">extends</span> <span class="token class-name">FactoryBeanRegistrySupport</span> <span class="token keyword">implements</span> <span class="token class-name">ConfigurableBeanFactory</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">protected</span> <span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> T <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Class<span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token keyword">boolean</span> typeCheckOnly<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{<!-- --></span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token comment">// Eagerly check singleton cache for manually registered singletons.</span>
		<span class="token comment">// 先去获取一次，如果不为null，此处就会走缓存了~~</span>
		Object sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token comment">// 如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>typeCheckOnly<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">markBeanAsCreated</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token comment">// Create bean instance.</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		
			<span class="token comment">// 这个getSingleton方法不是SingletonBeanRegistry的接口方法  属于实现类DefaultSingletonBeanRegistry的一个public重载方法~~~</span>
			<span class="token comment">// 它的特点是在执行singletonFactory.getObject();前后会执行beforeSingletonCreation(beanName);和afterSingletonCreation(beanName);  </span>
			<span class="token comment">// 也就是保证这个Bean在创建过程中，放入正在创建的缓存池里  可以看到它实际创建bean调用的是我们的createBean方法~~~~</span>
			sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">destroySingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">// 抽象方法createBean所在地  这个接口方法是属于抽象父类AbstractBeanFactory的   实现在这个抽象类里</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAutowireCapableBeanFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractBeanFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AutowireCapableBeanFactory</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">protected</span> Object <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> String beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> RootBeanDefinition mbd<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeanCreationException <span class="token punctuation">{<!-- --></span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token comment">// 创建Bean对象，并且将对象包裹在BeanWrapper 中</span>
		instanceWrapper <span class="token operator">=</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 再从Wrapper中把Bean原始对象（非代理~~~）  这个时候这个Bean就有地址值了，就能被引用了~~~</span>
		<span class="token comment">// 注意：此处是原始对象，这点非常的重要</span>
		<span class="token keyword">final</span> Object bean <span class="token operator">=</span> instanceWrapper<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token comment">// earlySingletonExposure 用于表示是否”提前暴露“原始对象的引用，用于解决循环依赖。</span>
		<span class="token comment">// 对于单例Bean，该变量一般为 true   但你也可以通过属性allowCircularReferences = false来关闭循环引用</span>
		<span class="token comment">// isSingletonCurrentlyInCreation(beanName) 表示当前bean必须在创建中才行</span>
		<span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Eagerly caching bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' to allow for resolving potential circular references"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 上面讲过调用此方法放进一个ObjectFactory，二级缓存会对应删除的</span>
			<span class="token comment">// getEarlyBeanReference的作用：调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference()这个方法  否则啥都不做</span>
			<span class="token comment">// 也就是给调用者个机会，自己去实现暴露这个bean的应用的逻辑~~~</span>
			<span class="token comment">// 比如在getEarlyBeanReference()里可以实现AOP的逻辑~~~  参考自动代理创建器AbstractAutoProxyCreator  实现了这个方法来创建代理对象</span>
			<span class="token comment">// 若不需要执行AOP的逻辑，直接返回Bean</span>
			<span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		Object exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span> <span class="token comment">//exposedObject 是最终返回的对象</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token comment">// 填充属于，解决@Autowired依赖~</span>
		<span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 执行初始化回调方法们~~~</span>
		exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span>
		<span class="token comment">// 此段代码非常重要~~~~~但大多数人都忽略了它</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span>
			<span class="token comment">//注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~</span>

			<span class="token comment">// 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句</span>
			<span class="token comment">//  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName, bean);</span>
			<span class="token comment">// 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了"偷天换日" 特别适合中间件的设计</span>
			<span class="token comment">// 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**</span>
			Object earlySingletonReference <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonReference <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			
				<span class="token comment">// 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了</span>
				<span class="token comment">// initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">==</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					exposedObject <span class="token operator">=</span> earlySingletonReference<span class="token punctuation">;</span>
				<span class="token punctuation">}</span> 

				<span class="token comment">// allowRawInjectionDespiteWrapping这个值默认是false</span>
				<span class="token comment">// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowRawInjectionDespiteWrapping <span class="token operator">&amp;&amp;</span> <span class="token function">hasDependentBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~</span>
					String<span class="token punctuation">[</span><span class="token punctuation">]</span> dependentBeans <span class="token operator">=</span> <span class="token function">getDependentBeans</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
					Set<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> actualDependentBeans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>dependentBeans<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
					
					<span class="token comment">// 一个个检查它所以Bean</span>
					<span class="token comment">// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span>
					<span class="token comment">// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span>
					<span class="token comment">// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span>
					<span class="token comment">//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span>
					<span class="token keyword">for</span> <span class="token punctuation">(</span>String dependentBean <span class="token operator">:</span> dependentBeans<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">removeSingletonIfCreatedForTypeCheckOnly</span><span class="token punctuation">(</span>dependentBean<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
							actualDependentBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>dependentBean<span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
					<span class="token punctuation">}</span>

					<span class="token comment">// 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的） </span>
					<span class="token comment">// 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>actualDependentBeans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>
								<span class="token string">"Bean with name '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' has been injected into other beans ["</span> <span class="token operator">+</span>
								StringUtils<span class="token punctuation">.</span><span class="token function">collectionToCommaDelimitedString</span><span class="token punctuation">(</span>actualDependentBeans<span class="token punctuation">)</span> <span class="token operator">+</span>
								<span class="token string">"] in its raw version as part of a circular reference, but has eventually been "</span> <span class="token operator">+</span>
								<span class="token string">"wrapped. This means that said other beans do not use the final version of the "</span> <span class="token operator">+</span>
								<span class="token string">"bean. This is often the result of over-eager type matching - consider using "</span> <span class="token operator">+</span>
								<span class="token string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">return</span> exposedObject<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 虽然是remove方法 但是它的返回值也非常重要</span>
	<span class="token comment">// 该方法唯一调用的地方就是循环依赖的最后检查处~~~~~</span>
	<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeSingletonIfCreatedForTypeCheckOnly</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>alreadyCreated<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">removeSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>这里举例：例如是<code>field</code>属性依赖注入，在<code>populateBean</code>时它就会先去完成它所依赖注入的那个bean的实例化、初始化过程，最终返回到本流程继续处理，<strong>因此Spring这样处理是不存在任何问题的。</strong></p> 
<p>这里有个小细节：</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">==</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	exposedObject <span class="token operator">=</span> earlySingletonReference<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这一句如果<code>exposedObject == bean</code>表示最终返回的对象就是原始对象，说明在<code>populateBean</code>和<code>initializeBean</code>没对他代理过，那就啥话都不说了<code>exposedObject = earlySingletonReference</code>，最终把二级缓存里的引用返回即可~</p> 
<h3><a id="_406"></a>流程总结（<code>非常重要</code>）</h3> 
<p>此处以如上的A、B类的互相依赖注入为例，在这里表达出<strong>关键代码</strong>的走势：</p> 
<p>1、入口处即是<strong>实例化、初始化A这个单例Bean</strong>。<code>AbstractBeanFactory.doGetBean("a")</code></p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> T <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
	<span class="token comment">// 标记beanName a是已经创建过至少一次的~~~ 它会一直存留在缓存里不会被移除（除非抛出了异常）</span>
	<span class="token comment">// 参见缓存Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256))</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>typeCheckOnly<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">markBeanAsCreated</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 此时a不存在任何一级缓存中，且不是在创建中  所以此处返回null</span>
	<span class="token comment">// 此处若不为null，然后从缓存里拿就可以了(主要处理FactoryBean和BeanFactory情况吧)</span>
	Object beanInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 这个getSingleton方法非常关键。</span>
	<span class="token comment">//1、标注a正在创建中~</span>
	<span class="token comment">//2、调用singletonObject = singletonFactory.getObject();（实际上调用的是createBean()方法）  因此这一步最为关键</span>
	<span class="token comment">//3、此时实例已经创建完成  会把a移除整整创建的缓存中</span>
	<span class="token comment">//4、执行addSingleton()添加进去。（备注：注册bean的接口方法为registerSingleton，它依赖于addSingleton方法）</span>
	sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>2、下面进入到最为复杂的<code>AbstractAutowireCapableBeanFactory.createBean/doCreateBean()</code>环节，创建A的实例</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> Object <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 使用构造器/工厂方法   instanceWrapper是一个BeanWrapper</span>
	instanceWrapper <span class="token operator">=</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 此处bean为"原始Bean"   也就是这里的A实例对象：A@1234</span>
	<span class="token keyword">final</span> Object bean <span class="token operator">=</span> instanceWrapper<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 是否要提前暴露（允许循环依赖）  现在此处A是被允许的</span>
	<span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 允许暴露，就把A绑定在ObjectFactory上，注册到三级缓存`singletonFactories`里面去保存着</span>
	<span class="token comment">// Tips:这里后置处理器的getEarlyBeanReference方法会被促发，自动代理创建器在此处创建代理对象（注意执行时机 为执行三级缓存的时候）</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// exposedObject 为最终返回的对象，此处为原始对象bean也就是A@1234,下面会有用处</span>
	Object exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span> 
	<span class="token comment">// 给A@1234属性完成赋值，@Autowired在此处起作用~</span>
	<span class="token comment">// 因此此处会调用getBean("b")，so 会重复上面步骤创建B类的实例</span>
	<span class="token comment">// 此处我们假设B已经创建好了 为B@5678</span>
	
	<span class="token comment">// 需要注意的是在populateBean("b")的时候依赖有beanA，所以此时候调用getBean("a")最终会调用getSingleton("a")，</span>
	<span class="token comment">//此时候上面说到的getEarlyBeanReference方法就会被执行。这也解释为何我们@Autowired是个代理对象，而不是普通对象的根本原因</span>
	
	<span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 实例化。这里会执行后置处理器BeanPostProcessor的两个方法</span>
	<span class="token comment">// 此处注意：postProcessAfterInitialization()是有可能返回一个代理对象的，这样exposedObject 就不再是原始对象了  特备注意哦~~~</span>
	<span class="token comment">// 比如处理@Aysnc的AsyncAnnotationBeanPostProcessor它就是在这个时间里生成代理对象的（有坑，请小心使用@Aysnc）</span>
	exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 至此，相当于A@1234已经实例化完成、初始化完成（属性也全部赋值了~）</span>
	<span class="token comment">// 这一步我把它理解为校验：校验：校验是否有循环引用问题~~~~~</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 注意此处第二个参数传的false，表示不去三级缓存里singletonFactories再去调用一次getObject()方法了~~~</span>
		<span class="token comment">// 上面建讲到了由于B在初始化的时候，会触发A的ObjectFactory.getObject()  所以a此处已经在二级缓存earlySingletonObjects里了</span>
		<span class="token comment">// 因此此处返回A的实例：A@1234</span>
		Object earlySingletonReference <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonReference <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		
			<span class="token comment">// 这个等式表示，exposedObject若没有再被代理过，这里就是相等的</span>
			<span class="token comment">// 显然此处我们的a对象的exposedObject它是没有被代理过的  所以if会进去~</span>
			<span class="token comment">// 这种情况至此，就全部结束了~~~</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">==</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				exposedObject <span class="token operator">=</span> earlySingletonReference<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
	
			<span class="token comment">// 继续以A为例，比如方法标注了@Aysnc注解，exposedObject此时候就是一个代理对象，因此就会进到这里来</span>
			<span class="token comment">//hasDependentBean(beanName)是肯定为true，因为getDependentBeans(beanName)得到的是["b"]这个依赖</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowRawInjectionDespiteWrapping <span class="token operator">&amp;&amp;</span> <span class="token function">hasDependentBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				String<span class="token punctuation">[</span><span class="token punctuation">]</span> dependentBeans <span class="token operator">=</span> <span class="token function">getDependentBeans</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				Set<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> actualDependentBeans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>dependentBeans<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// A@1234依赖的是["b"]，所以此处去检查b</span>
				<span class="token comment">// 如果最终存在实际依赖的bean：actualDependentBeans不为空 那就抛出异常  证明循环引用了~</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>String dependentBean <span class="token operator">:</span> dependentBeans<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 这个判断原则是：如果此时候b并还没有创建好，this.alreadyCreated.contains(beanName)=true表示此bean已经被创建过，就返回false</span>
					<span class="token comment">// 若该bean没有在alreadyCreated缓存里，就是说没被创建过(其实只有CreatedForTypeCheckOnly才会是此仓库)</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">removeSingletonIfCreatedForTypeCheckOnly</span><span class="token punctuation">(</span>dependentBean<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						actualDependentBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>dependentBean<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>actualDependentBeans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCurrentlyInCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>
							<span class="token string">"Bean with name '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span> <span class="token string">"' has been injected into other beans ["</span> <span class="token operator">+</span>
							StringUtils<span class="token punctuation">.</span><span class="token function">collectionToCommaDelimitedString</span><span class="token punctuation">(</span>actualDependentBeans<span class="token punctuation">)</span> <span class="token operator">+</span>
							<span class="token string">"] in its raw version as part of a circular reference, but has eventually been "</span> <span class="token operator">+</span>
							<span class="token string">"wrapped. This means that said other beans do not use the final version of the "</span> <span class="token operator">+</span>
							<span class="token string">"bean. This is often the result of over-eager type matching - consider using "</span> <span class="token operator">+</span>
							<span class="token string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p>由于关键代码部分的步骤不太好拆分，为了更具象表达，那么使用下面一副图示帮助小伙伴们理解：<br> <img src="https://images2.imgbox.com/04/d8/dB8rG605_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>最后的最后，由于我太暖心了<sup>_</sup>，再来个纯文字版的总结。</strong><br> 依旧以上面<code>A</code>、<code>B</code>类使用属性<code>field</code>注入循环依赖的例子为例，对整个流程做文字步骤总结如下：</p> 
<ol><li>使用<code>context.getBean(A.class)</code>，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走<strong>A的创建之路~</strong></li><li><code>实例化</code>A（注意此处仅仅是实例化），并将它放进<code>缓存</code>（此时A已经实例化完成，已经可以被引用了）</li><li><code>初始化</code>A：<code>@Autowired</code>依赖注入B（此时需要去容器内获取B）</li><li>为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内找B。但此时B在容器内不存在，就走向<strong>B的创建之路~</strong></li><li><code>实例化</code>B，并将其放入缓存。（此时B也能够被引用了）</li><li><code>初始化</code>B，<code>@Autowired</code>依赖注入A（此时需要去容器内获取A）</li><li><code>此处重要</code>：初始化B时会调用<code>getBean(A)</code>去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以<code>getBean(A)</code>能够正常返回</li><li><strong>B初始化成功</strong>（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中~）。</li><li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li><li><strong>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~</strong></li></ol> 
<p>站的角度高一点，宏观上看Spring处理循环依赖的整个流程就是如此。希望这个宏观层面的总结能更加有助于小伙伴们对Spring解决循环依赖的原理的了解，<strong>同时也顺便能解释为何构造器循环依赖就不好使的原因。</strong></p> 
<hr> 
<hr> 
<hr> 
<h4><a id="AOP_536"></a>循环依赖对AOP代理对象创建<code>流程和结果</code>的影响</h4> 
<p>我们都知道<strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。也就是说Spring最终给我们放进容器里面的是一个代理对象，<strong>而非原始对象</strong>。</p> 
<p>本文结合<code>循环依赖</code>，回头再看AOP代理对象的创建过程，和最终放进容器内的动作，非常有意思。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">HelloService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> HelloService helloService<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@Transactional</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Object <span class="token function">hello</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"service hello"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此<code>Service</code>类使用到了事务，所以最终会生成一个JDK动态代理对象<code>Proxy</code>。刚好它又存在<code>自己引用自己</code>的循环依赖。看看这个Bean的创建概要描述如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> Object <span class="token function">doCreateBean</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
	<span class="token comment">// 这段告诉我们：如果允许循环依赖的话，此处会添加一个ObjectFactory到三级缓存里面，以备创建对象并且提前暴露引用~</span>
	<span class="token comment">// 此处Tips：getEarlyBeanReference是后置处理器SmartInstantiationAwareBeanPostProcessor的一个方法，它的功效为：</span>
	<span class="token comment">// 保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象~~~~  AOP自动代理创建器此方法里会创建的代理对象~~~</span>
	<span class="token comment">// Eagerly cache singletons to be able to resolve circular references</span>
	<span class="token comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>
	<span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 需要提前暴露（支持循环依赖），就注册一个ObjectFactory到三级缓存</span>
		<span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 此处注意：如果此处自己被循环依赖了  那它会走上面的getEarlyBeanReference，从而创建一个代理对象从三级缓存转移到二级缓存里</span>
	<span class="token comment">// 注意此时候对象还在二级缓存里，并没有在一级缓存。并且此时可以知道exposedObject仍旧是原始对象~~~</span>
	<span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
	exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 经过这两大步后，exposedObject还是原始对象（注意此处以事务的AOP为例子的，</span>
	<span class="token comment">// 因为事务的AOP自动代理创建器在getEarlyBeanReference创建代理后，initializeBean就不会再重复创建了，二选一的，下面会有描述~~~）</span>
	
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
	<span class="token comment">// 循环依赖校验（非常重要）~~~~</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 前面说了因为自己被循环依赖了，所以此时候代理对象还在二级缓存里~~~（备注：本利讲解的是自己被循环依赖了的情况）</span>
		<span class="token comment">// so，此处getSingleton，就会把里面的对象拿出来，我们知道此时候它已经是个Proxy代理对象~~~</span>
		<span class="token comment">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span>
		<span class="token comment">// 这样就保证了我们容器里**最终实际上是代理对象**，而非原始对象~~~~~</span>
		Object earlySingletonReference <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonReference <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">==</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span>
				exposedObject <span class="token operator">=</span> earlySingletonReference<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span>
</code></pre> 
<p>上演示的是<code>代理对象+自己存在循环依赖</code>的case：Spring用三级缓存很巧妙的进行解决了。<br> 若是这种case：代理对象，但是自己并<strong>不存在循环依赖</strong>，过程稍微有点不一样儿了，如下描述：</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> Object <span class="token function">doCreateBean</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token comment">// 这些语句依旧会执行，三级缓存里是会加入的  表示它支持被循环引用嘛~~~</span>
		<span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
	<span class="token comment">// 此处注意，因为它没有被其它Bean循环引用（注意是循环引用，而不是直接引用~）,所以上面getEarlyBeanReference不会执行~</span>
	<span class="token comment">// 也就是说此时二级缓存里并不会存在它~~~ 知晓这点特别的重要</span>
	<span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 重点在这：AnnotationAwareAspectJAutoProxyCreator自动代理创建器此处的postProcessAfterInitialization方法里，会给创建一个代理对象返回</span>
	<span class="token comment">// 所以此部分执行完成后，exposedObject **已经是个代理对象**而不再是个原始对象了~~~~ 此时二级缓存里依旧无它，更别提一级缓存了</span>
	exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	
	<span class="token comment">// 循环依赖校验</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 前面说了一级、二级缓存里都木有它，然后这里传的又是false（表示不看三级缓存~~）</span>
		<span class="token comment">// 所以毋庸置疑earlySingletonReference = null  so下面的逻辑就不用看了，直接return出去~~</span>
		<span class="token comment">// 然后执行addSingleton()方法，由此可知  容器里最终存在的也还是代理对象~~~~~~</span>
		Object earlySingletonReference <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonReference <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>exposedObject <span class="token operator">==</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span>
				exposedObject <span class="token operator">=</span> earlySingletonReference<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>分析可知，即使自己只需要代理，并不被循环引用，最终存在Spring容器里的<strong>仍旧是</strong>代理对象。（so此时别人直接<code>@Autowired</code>进去的也是代理对象呀~~~）</p> 
<p><strong>终极case：如果我关闭Spring容器的循环依赖能力，也就是把<code>allowCircularReferences</code>设值为false，那么会不会造成什么问题呢？</strong></p> 
<pre><code class="prism language-java"><span class="token comment">// 它用于关闭循环引用（关闭后只要有循环引用现象就直接报错~~）</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactoryPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>AbstractAutowireCapableBeanFactory<span class="token punctuation">)</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAllowCircularReferences</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>若关闭了循环依赖后，还存在上面A、B的循环依赖现象，启动便会报错如下：</p> 
<pre><code class="prism language-java">Caused by<span class="token operator">:</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>BeanCurrentlyInCreationException<span class="token operator">:</span> Error creating bean with name <span class="token string">'a'</span><span class="token operator">:</span> Requested bean is currently in creation<span class="token operator">:</span> Is there an unresolvable circular reference<span class="token operator">?</span>
	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support<span class="token punctuation">.</span>DefaultSingletonBeanRegistry<span class="token punctuation">.</span><span class="token function">beforeSingletonCreation</span><span class="token punctuation">(</span>DefaultSingletonBeanRegistry<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">339</span><span class="token punctuation">)</span>
	at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>support<span class="token punctuation">.</span>DefaultSingletonBeanRegistry<span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span>DefaultSingletonBeanRegistry<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">215</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>注意此处异常类型也是<code>BeanCurrentlyInCreationException</code>异常，但是文案内容和上面强调的有所区别~~<br> 它报错位置在：<code>DefaultSingletonBeanRegistry.beforeSingletonCreation</code>这个位置~</p> 
</blockquote> 
<p><code>报错浅析</code>：在实例化A后给其属性赋值时，会去实例化B。B实例化完成后会继续给B属性赋值，这时由于此时我们<code>关闭了循环依赖</code>，所以不存在<code>提前暴露</code>引用这么一说来给实用。因此B无法直接拿到A的引用地址，因此只能又去创建A的实例。<strong>而此时我们知道A其实已经正在创建中了</strong>，不能再创建了。so，就报错了~</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">HelloService</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">// 因为管理了循环依赖，所以此处不能再依赖自己的</span>
	<span class="token comment">// 但是：我们的此bean还是需要AOP代理的~~~</span>
    <span class="token comment">//@Autowired</span>
    <span class="token comment">//private HelloService helloService;</span>
    
    <span class="token annotation punctuation">@Transactional</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Object <span class="token function">hello</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"service hello"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样它的大致运行如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> Object <span class="token function">doCreateBean</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 毫无疑问此时候earlySingletonExposure = false  也就是Bean都不会提前暴露引用了  显然就不能被循环依赖了~</span>
	<span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 若是事务的AOP  在这里会为源生Bean创建代理对象（因为上面没有提前暴露这个代理）</span>
	exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 这里更不用说，因为earlySingletonExposure<span class="token operator">=</span><span class="token boolean">false</span>  所以上面的代理对象exposedObject 直接<span class="token keyword">return</span>了<span class="token operator">~</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到即使把这个开关给关了，最终放进容器了的仍旧是代理对象，显然<code>@Autowired</code>给属性赋值的也一定是代理对象。</p> 
<p><mark>最后，以<code>AbstractAutoProxyCreator</code>为例看看自动代理创建器是怎么配合实现：循环依赖+创建代理</mark></p> 
<blockquote> 
 <p><code>AbstractAutoProxyCreator</code>是抽象类，它的三大实现子类<code>InfrastructureAdvisorAutoProxyCreator</code>、<code>AspectJAwareAdvisorAutoProxyCreator</code>、<code>AnnotationAwareAspectJAutoProxyCreator</code>小伙伴们应该会更加的熟悉些</p> 
</blockquote> 
<p>该抽象类实现了创建代理的动作：</p> 
<pre><code class="prism language-java"><span class="token comment">// @since 13.10.2003  它实现代理创建的方法有如下两个</span>
<span class="token comment">// 实现了SmartInstantiationAwareBeanPostProcessor 所以有方法getEarlyBeanReference来只能的解决循环引用问题：提前把代理对象暴露出去~</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAutoProxyCreator</span> <span class="token keyword">extends</span> <span class="token class-name">ProxyProcessorSupport</span> <span class="token keyword">implements</span> <span class="token class-name">SmartInstantiationAwareBeanPostProcessor</span><span class="token punctuation">,</span> BeanFactoryAware <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 下面两个方法是自动代理创建器创建代理对象的唯二的两个节点~</span>

	<span class="token comment">// 提前暴露代理对象的引用  它肯定在postProcessAfterInitialization之前执行</span>
	<span class="token comment">// 所以它并不需要判断啥的~~~~  创建好后放进缓存earlyProxyReferences里  注意此处value是原始Bean</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> Object <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		Object cacheKey <span class="token operator">=</span> <span class="token function">getCacheKey</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>earlyProxyReferences<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 因为它会在getEarlyBeanReference之后执行，所以此处的重要逻辑是下面的判断</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			Object cacheKey <span class="token operator">=</span> <span class="token function">getCacheKey</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// remove方法返回被移除的value，上面说了它记录的是原始bean</span>
			<span class="token comment">// 若被循环引用了，那就是执行了上面的`getEarlyBeanReference`方法，所以此时remove返回值肯定是==bean的（注意此时方法入参的bean还是原始对象）</span>
			<span class="token comment">// 若没有被循环引用，getEarlyBeanReference()不执行 所以remove方法返回null，所以就进入if执行此处的创建代理对象方法~~~</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>earlyProxyReferences<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span> <span class="token operator">!=</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> bean<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由上可知，自动代理创建器它保证了代理对象只会被创建一次，而且支持循环依赖的自动注入的依旧是代理对象。</p> 
<p><strong><code>上面分析了三种case，现给出结论如下：</code></strong><br> 不管是自己被循环依赖了还是没有，<strong>甚至是把Spring容器的循环依赖给关了</strong>，它对AOP代理的创建流程有影响，<strong>但对结果是无影响的。</strong><br> 也就是说Spring很好的对调用者屏蔽了这些实现细节，使得使用者使用起来完全的无感知~</p> 
<hr> 
<hr> 
<hr> 
<h5><a id="_734"></a>总结</h5> 
<p>解决此类问题的关键是要对<code>SpringIOC</code>和<code>DI</code>的整个流程做到心中有数，要理解好本文章，建议有【相关阅读】里文章的大量知识的铺垫，同时呢本文又能<strong>进一步</strong>的帮助小伙伴理解到Spring Bean的实例化、初始化流程。</p> 
<p>本文还是花了我一番心思的，个人觉得对Spring这部分的处理流程描述得还是比较详细的，希望我的总结能够给大家带来帮助。<br> <strong>另外为了避免循环依赖导致启动问题而又不会解决，有如下建议：</strong></p> 
<ol><li><code>业务代码中</code>尽量不要使用构造器注入，即使它有很多优点。</li><li><code>业务代码中</code>为了简洁，尽量使用field注入而非setter方法注入</li><li>若你注入的同时，立马需要处理一些逻辑（一般见于框架设计中，业务代码中不太可能出现），可以使用setter方法注入辅助完成</li></ol> 
<p>The last：如果小伙伴觉得本文还不错，不妨点个赞呗。当然也欢迎大家<strong>转发此文</strong>到群or朋友圈，共勉，多谢~</p> 
<hr> 
<h2><a id="A_747"></a>关注A哥</h2> 
<table><thead><tr><th>Author</th><th><a href="https://www.yourbatman.cn/about" rel="nofollow">A哥(YourBatman)</a></th></tr></thead><tbody><tr><td>个人站点</td><td><a href="https://www.yourbatman.cn" rel="nofollow">www.yourbatman.cn</a></td></tr><tr><td>E-mail</td><td>yourbatman@qq.com</td></tr><tr><td><strong>微 信</strong></td><td><a href="https://www.yourbatman.cn/images/wechat.png" rel="nofollow">fsx641385712</a></td></tr><tr><td><strong><code>活跃平台</code></strong></td><td><a href="https://www.yourbatman.cn" rel="nofollow"><img src="https://images2.imgbox.com/bf/55/06UvOhTu_o.png" alt=""></a> <a href="https://fangshixiang.blog.csdn.net/" rel="nofollow"><img src="https://images2.imgbox.com/0f/b7/aM1RO2mt_o.png" alt=""></a><a href="https://yourbatman.cnblogs.com" rel="nofollow"><img src="https://images2.imgbox.com/ae/22/xz0jYH13_o.png" alt=""></a><a href="https://juejin.im/user/5b44d178f265da0fa1220efe/posts" rel="nofollow"><img src="https://images2.imgbox.com/91/a7/zmpSCCyi_o.png" alt=""></a><a href="https://www.zhihu.com/people/fangshixiang/posts" rel="nofollow"><img src="https://images2.imgbox.com/d6/52/p4FeDx0T_o.png" alt=""></a><a href="https://www.jianshu.com/u/8740f1fdd684" rel="nofollow"><img src="https://images2.imgbox.com/07/18/YknFBIGW_o.png" alt=""></a><a href="https://segmentfault.com/u/yourbatman/articles" rel="nofollow"><img src="https://images2.imgbox.com/f2/0e/nTojwBtn_o.png" alt=""></a><a href="https://github.com/yourbatman"><img src="https://images2.imgbox.com/c7/58/rHdtYuBn_o.png" alt=""></a></td></tr><tr><td><strong>公众号</strong></td><td><a href="https://www.yourbatman.cn/images/wechat_channel.jpg" rel="nofollow">BAT的乌托邦（ID：BAT-utopia）</a></td></tr><tr><td>知识星球</td><td><a href="https://t.zsxq.com/nQBi66I" rel="nofollow">BAT的乌托邦</a></td></tr><tr><td>每日文章推荐</td><td><a href="https://github.com/yourbatman/reading/issues">每日文章推荐</a></td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/ce/f7/HJqmjfAE_o.gif" alt="BAT的乌托邦"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/78e167b5943e7187cc3c6d997fef5386/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用pandas删除整列为空值的列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d45715338b33677e700d2a386f47c31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【android免root脚本制作】基于控件的操作——auto.js进阶</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>