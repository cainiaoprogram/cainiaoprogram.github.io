<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉树算法题总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉树算法题总结" />
<meta property="og:description" content="1.二叉树的节点数计算
class CountNodes { public: int count(TreeNode* root) { if (!root) return 0; int size = 1 &#43;count(root-&gt;left); size &#43;= count(root-&gt;right); return size; } }; 2.二叉树的高度计算
int BinaryTree::height() { if (!Root) return 0; return ret_height_Core(Root); } int BinaryTree::ret_height_Core(TreeNode * x) { if (!x) return 0; int left_depth = ret_height_Core(x-&gt;left_child); int right_depth = ret_height_Core(x-&gt;right_child); return max(left_depth,right_depth)&#43;1; } 3.请用递归方式实现二叉树的先序，中序和后序的遍历打印。
给定一个二叉树的根结点root，请依次返回二叉树的先序，中序和后续遍历（二维数组的形式）。
/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class TreeToSequence { public: void pre_print(vector&lt;int&gt;&amp; vec,TreeNode* root) {//二叉树的递归前序遍历 if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5eb2ec913586004cf99fdf3de6b6b75d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-09T20:07:21+08:00" />
<meta property="article:modified_time" content="2018-12-09T20:07:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉树算法题总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">1.二叉树的节点数计算</font></font></p> 
<pre class="has"><code class="language-cpp">class CountNodes {
public:
    int count(TreeNode* root) {
        if (!root)
		return 0;
	int size = 1 +count(root-&gt;left);
	size += count(root-&gt;right);
	return size;
    }
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">2.二叉树的高度计算</font></font></p> 
<pre class="has"><code class="language-cpp">int BinaryTree::height()
{
	if (!Root)
		return 0;
	return ret_height_Core(Root);
}
int BinaryTree::ret_height_Core(TreeNode * x)
{
	if (!x)
		return 0;
	int left_depth = ret_height_Core(x-&gt;left_child);
	int right_depth = ret_height_Core(x-&gt;right_child);
	return max(left_depth,right_depth)+1;
}</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">3.请用递归方式实现二叉树的先序，中序和后序的遍历打印。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定一个二叉树的根结点</font></font><strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">root</font></font></strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">，请依次返回二叉树的先序，中序和后续遍历（二维数组的形式）。</font></font></p> 
<pre class="has"><code class="language-cpp">/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/

class TreeToSequence {
public:
void pre_print(vector&lt;int&gt;&amp; vec,TreeNode* root)
{//二叉树的递归前序遍历
	if (!root)
		return;
	vec.push_back(root-&gt;val);
	pre_print(vec, root-&gt;left);
	pre_print(vec, root-&gt;right);
}
void mid_print(vector&lt;int&gt;&amp; vec, TreeNode* root)
{//二叉树的递归中序遍历
	if (!root)
		return;
	mid_print(vec, root-&gt;left);
	vec.push_back(root-&gt;val);
	mid_print(vec, root-&gt;right);
}
void aft_print(vector&lt;int&gt;&amp; vec, TreeNode* root)
{//二叉树的递归后序遍历
	if (!root)
		return;
	aft_print(vec, root-&gt;left);
	aft_print(vec, root-&gt;right);
	vec.push_back(root-&gt;val);
}
vector&lt;vector&lt;int&gt; &gt; convert(TreeNode* root) {
     vector&lt;vector&lt;int&gt; &gt; vec;
	vector&lt;int&gt; A,B,C;
	pre_print(A, root);
	mid_print(B, root);
	aft_print(C, root);
        vec.push_back(A);
         vec.push_back(B);
         vec.push_back(C);
	return vec;
    }
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">4.请用非递归方式实现二叉树的先序，中序和后序的遍历打印。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定一个二叉树的根结点</font></font><strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">root</font></font></strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">，请依次返回二叉树的先序，中序和后续遍历（二维数组的形式）。</font></font></p> 
<pre class="has"><code class="language-cpp">/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/

class TreeToSequence {
public:
void pre_by_stack(vector&lt;int&gt;&amp; vec, TreeNode* root)
{
	stack&lt;TreeNode*&gt; sta;
	TreeNode* x = root;
	while (true)
	{
		while (x)
		{
			vec.push_back(x-&gt;val);
			if(x-&gt;right)
			sta.push(x-&gt;right);
			x = x-&gt;left;
		}
		if (sta.empty())
			break;
		x = sta.top();
		sta.pop();
	}
}
void mid_by_stack(vector&lt;int&gt;&amp; vec, TreeNode* root)
{
	stack&lt;TreeNode*&gt; sta;
	TreeNode* x = root;
	while (true)
	{
		while (x)
		{
			sta.push(x);
			x = x-&gt;left;
		}
		if (sta.empty())
			break;
		x = sta.top();
		sta.pop();
		vec.push_back(x-&gt;val);
		x = x-&gt;right;
	}
}
void aft_by_stack(vector&lt;int&gt;&amp; vec, TreeNode* root)
{
	stack&lt;TreeNode*&gt; sta,stb;
	TreeNode* x = root;
	if (!root)
		return;
	sta.push(root);
	while (!sta.empty())
	{
		x = sta.top();
		sta.pop();
		stb.push(x);
		if (x-&gt;left)
			sta.push(x-&gt;left);
		if (x-&gt;right)
			sta.push(x-&gt;right);	
	}
	while (!stb.empty())
	{
		TreeNode* t = stb.top();
		stb.pop();
		vec.push_back(t-&gt;val);
	}
}
vector&lt;vector&lt;int&gt; &gt; convert(TreeNode* root) {
	// write code here
	vector&lt;vector&lt;int&gt; &gt; vec;
	vector&lt;int&gt; A, B, C;
	pre_by_stack(A, root);
	mid_by_stack(B, root);
	aft_by_stack(C, root);
	vec.push_back(A);
	vec.push_back(B);
	vec.push_back(C);
	return vec;
}
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">5.有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定二叉树的根结点</font></font><strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">root</font></font></strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列。保证结点数小于等于500。</font></font></p> 
<pre class="has"><code class="language-cpp">/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/

class TreePrinter {
public:
   vector&lt;vector&lt;int&gt; &gt; printTree(TreeNode* root) {
	// write code here
	queue&lt;TreeNode*&gt; q;
	vector&lt;int&gt; vt;
	vector&lt;vector&lt;int&gt;&gt; vec;
	TreeNode* last = root;
	TreeNode* nlast = nullptr;
	q.push(root);
	while (!q.empty())
	{
		TreeNode* temp = q.front();
		cout &lt;&lt; temp-&gt;val &lt;&lt; " ";
		vt.push_back(temp-&gt;val);
		q.pop();
		if (temp-&gt;left)
		{
			q.push(temp-&gt;left);
			nlast = temp-&gt;left;
		}
		if (temp-&gt;right)
		{
			q.push(temp-&gt;right);
			nlast = temp-&gt;right;
		}
		if (last-&gt;right == nlast || last-&gt;left == nlast||temp==last)
		{
			   last = nlast;
			cout &lt;&lt; endl;
			vec.push_back(vt);
			vt.clear();
		}
	}
	return vec;
}
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答案：新设定2个指针最后，nlast.last指向当前打印这一层的最后一个节点.nlast指向下一层的最后一个节点如果持续的左孩子或者右孩子是n上次的话，说明这一层已经打印完了，最后现在等于下一层的最后一个节点（也就是此时的ñ上次）。然后将原来那一层的元素放入待输出的序列中。同时还有一种情况需要注意，我们这一层的最后一个结点如果没有左右孩子的话，那么只判断nlast肯定不会是最后的孩子结点，所以还需要增加一个条件当前打印节点是否已经打印到了这层的末尾即temp == last 。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">6.有一棵二叉树，请设计一个算法判断这棵二叉树是否为平衡二叉树。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定二叉树的根结点</font></font><strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">root</font></font></strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">，请返回一个bool值，代表这棵树是否为平衡二叉树。</font></font></p> 
<pre class="has"><code class="language-cpp">int BinaryTree::ret_height_Core(TreeNode * x)
{
	if (!x)
		return 0;
	int left_depth = ret_height_Core(x-&gt;left_child);
	int right_depth = ret_height_Core(x-&gt;right_child);
	return max(left_depth,right_depth)+1;
}

bool BinaryTree::check(TreeNode * x)
{
	if (!x)
		return true;	
	int left_depth = ret_height_Core(x-&gt;left_child);
	int right_depth = ret_height_Core(x-&gt;right_child);
    unsigned int mud= abs(left_depth - right_depth);
	if (mud &gt; 1)
		return false;
	return check(x-&gt;left_child)&amp;&amp;check(x-&gt;right_child);  
}</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">7.有一棵二叉树，请设计一个算法判断它是否是完全二叉树。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定二叉树的根结点</font></font><strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">root</font></font></strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">，请返回一个bool值代表它是否为完全二叉树。树的结点个数小于等于500。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答案：。根据完全二叉树的性质，使用按层次遍历如果遇到只有右子树没有左子树的节点就返回假如果遇到有左子树也有右子树的正常继续遍历如果遇到左右子树都为空或者左子树不为空右子树为空则将叶置为真。然后下次过来遍历到节点就必须都得是叶子节点了，如果不满足这个条件也返回假。</font></font></p> 
<pre class="has"><code class="language-cpp">class CheckCompletion {
public:
     bool chk(TreeNode* root) {
        // write code here
        if(root == NULL){
            return true;
        }
        queue&lt;TreeNode*&gt; Queue;
        TreeNode* node;
        bool leaf = false;
        Queue.push(root);
        while(!Queue.empty()){
            node = Queue.front();
            Queue.pop();
             if(node-&gt;left&amp;&amp;node-&gt;right)
             {
                 Queue.push(node-&gt;left);
                 Queue.push(node-&gt;right);
             }else if(leaf||node-&gt;left==nullptr&amp;&amp;node-&gt;right!=nullptr)
             {
                 if(node-&gt;left==nullptr&amp;&amp;node-&gt;right!=nullptr)
                     return false;
                 if(leaf&amp;&amp;(node-&gt;left!=nullptr||node-&gt;right!=nullptr))//如果不是叶子节点的话就返回false
                     return false; 
             }else
             {
                 leaf=true;
                 if(node-&gt;left)
                     Queue.push(node-&gt;left);
             }
                     
            }
         return true;
        }
        
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">8.输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1 ，2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：先保存前序序列的第一个节点作为根节点，然后在中序序列找，找到后会将其中序序列划分为两段，在中序序列中指定节点前的都属于左子树，后面都属于右子树。所以可以继续递归操作。</font></font></p> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    TreeNode* construct_tree(int* pre_order,int* in_order,int length)
    {
        if(!pre_order||!in_order||length&lt;=0)
            return nullptr;
        int val=pre_order[0];
        TreeNode* Root=new TreeNode(val);
        int left_length=0;
        int right_length=0;
        for(int i=0;i&lt;length;i++)
        {
            if(in_order[i]==val)
            {
                left_length=i;
                right_length=length-(left_length+1);
                break;
            }
        }
        int* pre_l=pre_order+1;
        int* in_l=in_order;
        int* pre_r=pre_order+left_length+1;
        int* in_r=in_order+left_length+1;
        Root-&gt;left=construct_tree(pre_l,in_l,left_length);
        Root-&gt;right=construct_tree(pre_r,in_r,right_length);
        return Root;
    }
    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) {
          if(pre.empty()||vin.empty()||pre.size()!=vin.size())
              return nullptr;
        auto sz=pre.size();
        int* pre_order=new int[sz];
        int* in_order=new int[sz];
        int length=sz;
        for(vector&lt;int&gt;::size_type i=0;i&lt;sz;i++)
        {
            pre_order[i]=pre[i];
            in_order[i]=vin[i];
        }
        return construct_tree(pre_order,in_order,length);
    }
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">9.输入两棵二叉树A，B，判断乙是不是一个的子结构（PS：我们约定空树不是任意一个树的子结构）。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：首先比较主树与匹配树的根节点，只有在根节点匹配成功后，才继续判断是否是其子树。</font></font></p> 
<pre class="has"><code class="language-cpp">bool is_subTree(TreeNode* pRoot1,TreeNode* pRoot2)
{
    if(!pRoot2)
      return true;
    if(!pRoot1)
     return false;
    if(pRoot1-&gt;val!=pRoot2-&gt;val)
       return false;
    return is_subTree(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;
          is_subTree(pRoot2-&gt;right,pRoot2-&gt;right);

}
bool has_subtree(TreeNode* pRoot1,TreeNode* pRoot2)
{
   bool result=false;
   if(pRoot1&amp;&amp;pRoot2)
   {
     if(pRoot1-&gt;val==pRoot2-&gt;val)
      {
        result=is_subTree(pRoot1,pRoot2);
       }
     if(!result)
        result=has_subtree(pRoot1-&gt;left,pRoot2);
     if(!result)
        result=has_subtree(pRoot1-&gt;right,pRoot2);
    }
    return result;
}</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">10.操作给定的二叉树，将其变换为源二叉树的镜像。</font></font></p> 
<pre><code class="language-html">二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5</code></pre> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    void Mirror(TreeNode *pRoot) {
         if(!pRoot)
             return;
         TreeNode* temp=pRoot-&gt;left;
         pRoot-&gt;left=pRoot-&gt;right;
         pRoot-&gt;right=temp;
        if(pRoot-&gt;left)
            Mirror(pRoot-&gt;left);
        if(pRoot-&gt;right)
            Mirror(pRoot-&gt;right);
    }
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">11.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出是的，否则输出号假设输入的数组的任意两个数字都互不相同。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：</font></font></p> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    bool v_bst(int* arr,int length)
    {
        if(length&lt;=0)
            return false;
        int root=arr[length-1];
        int i=0;
        for(;i&lt;length-1;i++)
            if(arr[i]&gt;root)
                break;
        int j=i;
        for(;j&lt;length-1;j++)
            if(arr[j]&lt;root)
                return false;
       bool  left=true;
            if(i&gt;0)        
                left=v_bst(arr,i);
       bool right=true; 
            if(i&lt;length-1)
                right=v_bst(arr+i,length-i-1);
        return (left&amp;&amp;right);
    }
    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) 
        {
            if(sequence.empty())
                return false;
            unsigned int length=sequence.size();
            int *arr=new int[length];
            bool res=v_bst(arr,length);
            cout&lt;&lt;(res?"Yes":"No");
           return res;
        }
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">12.输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径（注意：在返回值的列表中，数组长度大的数组靠前）。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：</font></font></p> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    void pre_order(TreeNode* root,int currentNumber,int expectNumber)
    {
        if(!root)
            return;
        sta.push_back(root-&gt;val);
        currentNumber+=root-&gt;val;
        bool leaf=(!(root-&gt;left)&amp;&amp;(!root-&gt;right));
        if(currentNumber==expectNumber&amp;&amp;leaf)
            vec.push_back(sta);
        if(root-&gt;left)
            pre_order(root-&gt;left,currentNumber,expectNumber);
        if(root-&gt;right)
            pre_order(root-&gt;right,currentNumber,expectNumber);
        sta.pop_back();
    }
    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) {
        if(!root)
            return vector&lt;vector&lt;int&gt; &gt;();
         pre_order(root,0,expectNumber);
        return vec;
    }
private:
    vector&lt;vector&lt;int&gt; &gt; vec;
    vector&lt;int&gt; sta;
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">13.输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：题目提到了已排好序，那么二叉排序树排好序的情况是中序遍历的时候，所以我们可以中序遍历一趟二叉搜索树，然后入队。然后通过不断出队。当前节点的右孩子指向队头。左孩子指向前一个出队结点使用pre来指向，每次循环不断更新这个pre。</font></font></p> 
<pre class="has"><code class="language-cpp">class Solution{
public:
	void inorder(TreeNode* pRootOfTree)
	{
		if (!pRootOfTree)
			return;
		inorder(pRootOfTree-&gt;left);
		q.push(pRootOfTree);
		inorder(pRootOfTree-&gt;right);
	}
	TreeNode* Convert(TreeNode* pRootOfTree)
	{
		if (!pRootOfTree)
			return nullptr;
		inorder(pRootOfTree);
		TreeNode* Head = q.front();
		TreeNode* pre = nullptr;
		while (!q.empty())
		{
			TreeNode* temp = q.front();
			temp-&gt;left = pre;
			q.pop();
			if (!q.empty())
				temp-&gt;right = q.front();
			else
				temp-&gt;right = nullptr;
			pre = temp;
		}
		return Head;
	}
private:
	queue&lt;TreeNode*&gt; q;
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">14.给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：其实就是求二叉树的中序遍历序列的后继：</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">    1.如果有右子树则右子树的最左孩子就是后继如果该右孩子没有左孩子那么后继就是这个该右孩子。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">    2.如果没有右孩子，如果当前节点是其父母节点的左孩子节点的话，那么后继是其父母。如果是其父母的右孩子的话，就延父母节点上溯，直到找到当前节点是其父母节点的左孩子。此刻该父母节点为后继。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">前驱：</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">    1.如果当前节点有左子树的话，前驱为该节点左子树的最右节点。如果左子树没有右孩子，则前驱就是该左孩子。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">    2.如果当前节点没有左孩子的话当前节点是其父母节点的右孩子，则前驱就是父母节点。如果当前节点是其父母节点的左孩子的话，延父母节点继续上溯，直到找到当前节点是其父母节点的右孩子，则该父母节点为前驱。</font></font></p> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(!pNode)
            return nullptr;
        if(pNode-&gt;right)
        {
            TreeLinkNode* temp=pNode-&gt;right;
            while(temp-&gt;left)
            {
                temp=temp-&gt;left;
            }
            return temp;
        }else
        {
            TreeLinkNode* par=pNode-&gt;next;
            while(par&amp;&amp;pNode==par-&gt;right)
            {
                pNode=par;
                par=par-&gt;next;
            }
            return par;
        }
    }
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">15.请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：如何判断一个二叉树是对称的，我们从左边遍历，和从右边遍历应该值是相等的。</font></font></p> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
       return isSymmetrical(pRoot,pRoot);
    }
    bool isSymmetrical(TreeNode* pRoot1,TreeNode* pRoot2)
    {
        if(!pRoot1&amp;&amp;!pRoot2)
            return true;
        if(!pRoot1||!pRoot2)
            return false;
        if(pRoot1-&gt;val!=pRoot2-&gt;val)
            return false;
        return isSymmetrical(pRoot1-&gt;left,pRoot2-&gt;right)&amp;&amp;isSymmetrical(pRoot1-&gt;right
                                                                       ,pRoot2-&gt;left);
    }
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">16.请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：与之前按行遍历的思路类似，如果我们要按之子形打印二叉树的话，我们可以定义一个标志位以便用来表示此时就从左到右打印还是从右到左打印那么如何实现从左到右打印或者从右到左打印呢？队列和栈。我们在扫描每一层的时候，元素同时入队入栈。当选择打印方式时，通过那个标志位来选择。如果从左到右打印就选择队列。从右到左打印就选择栈。需要注意的就是每次其中一个容器打印完，另一个容器需要清空。</font></font></p> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
        if(!pRoot)
            return vector&lt;vector&lt;int&gt; &gt;();
        vector&lt;vector&lt;int&gt; &gt; vec;
        vector&lt;int&gt; vt;
        TreeNode* last=pRoot;
        TreeNode* nlast=nullptr;
        int order=true;//order为true从左到右打印
        queue&lt;TreeNode*&gt; q;
        queue&lt;TreeNode*&gt; tem;
        stack&lt;TreeNode*&gt; sta;
        q.push(pRoot);
        while(!q.empty())
        {
            TreeNode* temp=q.front();
            q.pop();
            sta.push(temp);
            tem.push(temp);
            if(temp-&gt;left)
            {
                q.push(temp-&gt;left);
                nlast=temp-&gt;left;
            }
            if(temp-&gt;right)
            { 
                q.push(temp-&gt;right);
                nlast=temp-&gt;right;
            }
            if(last-&gt;left==nlast||last-&gt;right==nlast||temp==last)
            {
                last=nlast;
                if(order)
                {
                    while(!tem.empty())
                    {
                        vt.push_back(tem.front()-&gt;val);
                        tem.pop();
                    }
                     while(!sta.empty())
                    {
                        sta.pop();
                    }
                    order=false;
                }else
                {
                    while(!sta.empty())
                    {
                        vt.push_back(sta.top()-&gt;val);
                        sta.pop();
                    }
                   while(!tem.empty())
                    {
                        tem.pop();
                    }
                    order=true;
                }
                vec.push_back(vt);
                vt.clear();
            }
        }
        return vec;
    }
    
    
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">17.请实现两个函数，分别用来序列化和反序列化二叉树</font></font></p> 
<pre class="has"><code class="language-cpp">class TreeToString {
public:
string getString(int x){
		string ret;
		while(x) ret += '0' + (x % 10),x /= 10;
		reverse(ret.begin(),ret.end());
		return ret;
	}
	void convert(TreeNode* root,string &amp;ret){
		if(root == NULL){
			ret = ret + "#!";
			return;
		}
		ret = ret + getString(root-&gt;val) + "!";
		convert(root-&gt;left,ret);
		convert(root-&gt;right,ret);
	}
    string toString(TreeNode* root) {
		string ret;
		convert(root,ret);
		return ret;
    }
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">18.给定一棵二叉搜索树，请找出其中的第ķ小的结点。例如，（5,3,7,2,4,6,8）中，按结点数值大小顺序第三小结点的值为4。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">答：中序遍历序列本身就是有序的，所以我们只要不断遍历，如果当前节点为第ķ个的话，就把它标注。</font></font></p> 
<pre class="has"><code class="language-cpp">class Solution {
public:
    void inorder(TreeNode* pRoot,TreeNode* &amp;ans)
    {
        if(!pRoot)
            return;
        inorder(pRoot-&gt;left,ans);
        count--;
        if(!count) ans=pRoot;
        inorder(pRoot-&gt;right,ans);
    }
    TreeNode* KthNode(TreeNode* pRoot, int k)
    {
        if(!pRoot||k&lt;1)
            return nullptr; 
        count=k;
        TreeNode* ans=nullptr;
        inorder(pRoot,ans);
        return ans;
    }

private: 
    int count=0;
};</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">19.请把纸条竖着放在桌浑上，然后从纸条的下边向上椹对折，压出折痕后再展开。此时有1条折痕，突起的蚂向指向纸条的背Ÿ ，这条折痕叫做“下”折痕;突起的⽅向指向纸条正Ÿ的折痕叫做“上”折痕如果每次都从下边向上对折，对折ñ次请从上到下计算出所有折痕的⽅向。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定折的次数</font></font><strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">n</font></font></strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">，请返回从上到下的折痕的数组，若为下折痕则对应元素为“down”，若为上折痕则为“up”。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">测试样例：</font></font></p> 
<pre class="has"><code class="language-html">1</code></pre> 
<pre class="has"><code class="language-html">返回：["down"]</code></pre> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">20.一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个错误节点并返回他们的值。保证二叉树中结点的值各不相同。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定一棵树的根结点，请返回两个调换了位置的值，其中小的值在前。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">21.从二叉树的节点甲出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点乙时，路径上的节点数叫作甲到乙的距离。对于给定的一棵二叉树，求整棵树上节点间的最大距离。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定一个二叉树的头结点</font></font><strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">root</font></font></strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">，请返回最大距离。保证点数大于等于2小于等于500。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">22.有一棵二叉树，其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的头节点。</font></font></p> 
<p><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">给定二叉树的头结点</font></font><strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">root</font></font></strong><font style="vertical-align:inherit;"><font style="vertical-align:inherit;">，请返回所求的头结点，若出现多个节点最多的子树，返回头结点权值最大的。</font></font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d751c78654cfe89a54b51e16ed0060dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SiamFC：基于全卷积孪生网络的目标跟踪算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3d407e3508d7b800c09e58560671763/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《操作系统》试题及答案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>